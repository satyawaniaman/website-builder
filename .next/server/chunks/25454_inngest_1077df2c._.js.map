{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 7, "column": 0}, "map": {"version":3,"file":"consts.js","sources":["file:///Users/amansatyawani/Desktop/website-builder/node_modules/.pnpm/inngest%403.45.1_%40opentelemetry%2Bcore%402.2.0_%40opentelemetry%2Bapi%401.9.0__express%405.1.0_next%401_e029d374516642dd9a767b32fbb0beec/node_modules/src/helpers/consts.ts"],"sourcesContent":["import chalk from \"chalk\";\n\n/**\n * Keys for accessing query parameters included in requests from Inngest to run\n * functions.\n *\n * Used internally to create handlers using `InngestCommHandler`, but can be\n * imported to be used if creating a custom handler outside of the package.\n *\n * @public\n */\nexport enum queryKeys {\n  DeployId = \"deployId\",\n  FnId = \"fnId\",\n  Probe = \"probe\",\n  StepId = \"stepId\",\n}\n\nexport enum probe {\n  Trust = \"trust\",\n}\n\nexport enum envKeys {\n  InngestSigningKey = \"INNGEST_SIGNING_KEY\",\n  InngestSigningKeyFallback = \"INNGEST_SIGNING_KEY_FALLBACK\",\n  InngestEventKey = \"INNGEST_EVENT_KEY\",\n\n  /**\n   * @deprecated Removed in v3. Use {@link InngestBaseUrl} instead.\n   */\n  InngestDevServerUrl = \"INNGEST_DEVSERVER_URL\",\n  InngestEnvironment = \"INNGEST_ENV\",\n  InngestBaseUrl = \"INNGEST_BASE_URL\",\n  InngestEventApiBaseUrl = \"INNGEST_EVENT_API_BASE_URL\",\n  InngestApiBaseUrl = \"INNGEST_API_BASE_URL\",\n  InngestServeHost = \"INNGEST_SERVE_HOST\",\n  InngestServePath = \"INNGEST_SERVE_PATH\",\n  InngestLogLevel = \"INNGEST_LOG_LEVEL\",\n  InngestStreaming = \"INNGEST_STREAMING\",\n  InngestDevMode = \"INNGEST_DEV\",\n  InngestAllowInBandSync = \"INNGEST_ALLOW_IN_BAND_SYNC\",\n  InngestConnectMaxWorkerConcurrency = \"INNGEST_CONNECT_MAX_WORKER_CONCURRENCY\",\n\n  /**\n   * @deprecated It's unknown what this env var was used for, but we do not\n   * provide explicit support for it. Prefer using `INNGEST_ENV` instead.\n   */\n  BranchName = \"BRANCH_NAME\",\n\n  /**\n   * The git branch of the commit the deployment was triggered by. Example:\n   * `improve-about-page`.\n   *\n   * {@link https://vercel.com/docs/concepts/projects/environment-variables/system-environment-variables#system-environment-variables}\n   */\n  VercelBranch = \"VERCEL_GIT_COMMIT_REF\",\n\n  /**\n   * Expected to be `\"1\"` if defined.\n   */\n  IsVercel = \"VERCEL\",\n\n  /**\n   * The branch name of the current deployment. May only be accessible at build\n   * time, but included here just in case.\n   *\n   * {@link https://developers.cloudflare.com/pages/platform/build-configuration/#environment-variables}\n   */\n  CloudflarePagesBranch = \"CF_PAGES_BRANCH\",\n\n  /**\n   * Expected to be `\"1\"` if defined.\n   */\n  IsCloudflarePages = \"CF_PAGES\",\n\n  /**\n   * The branch name of the deployment from Git to Netlify, if available.\n   *\n   * {@link https://docs.netlify.com/configure-builds/environment-variables/#git-metadata}\n   */\n  NetlifyBranch = \"BRANCH\",\n\n  /**\n   * Expected to be `\"true\"` if defined.\n   */\n  IsNetlify = \"NETLIFY\",\n\n  /**\n   * The Git branch for a service or deploy.\n   *\n   * {@link https://render.com/docs/environment-variables#all-services}\n   */\n  RenderBranch = \"RENDER_GIT_BRANCH\",\n\n  /**\n   * Expected to be `\"true\"` if defined.\n   */\n  IsRender = \"RENDER\",\n\n  /**\n   * The branch that triggered the deployment. Example: `main`\n   *\n   * {@link https://docs.railway.app/develop/variables#railway-provided-variables}\n   */\n  RailwayBranch = \"RAILWAY_GIT_BRANCH\",\n\n  /**\n   * The railway environment for the deployment. Example: `production`\n   *\n   * {@link https://docs.railway.app/develop/variables#railway-provided-variables}\n   */\n  RailwayEnvironment = \"RAILWAY_ENVIRONMENT\",\n\n  VercelEnvKey = \"VERCEL_ENV\",\n\n  OpenAiApiKey = \"OPENAI_API_KEY\",\n  GeminiApiKey = \"GEMINI_API_KEY\",\n  AnthropicApiKey = \"ANTHROPIC_API_KEY\",\n}\n\n/**\n * Keys for accessing headers included in requests from Inngest to run\n * functions.\n *\n * Used internally to create handlers using `InngestCommHandler`, but can be\n * imported to be used if creating a custom handler outside of the package.\n *\n * @public\n */\nexport enum headerKeys {\n  ContentType = \"content-type\",\n  Host = \"host\",\n  ForwardedFor = \"x-forwarded-for\",\n  RealIp = \"x-real-ip\",\n  Location = \"location\",\n  ContentLength = \"content-length\",\n  Signature = \"x-inngest-signature\",\n  SdkVersion = \"x-inngest-sdk\",\n  Environment = \"x-inngest-env\",\n  Platform = \"x-inngest-platform\",\n  Framework = \"x-inngest-framework\",\n  NoRetry = \"x-inngest-no-retry\",\n  RequestVersion = \"x-inngest-req-version\",\n  RetryAfter = \"retry-after\",\n  InngestServerKind = \"x-inngest-server-kind\",\n  InngestExpectedServerKind = \"x-inngest-expected-server-kind\",\n  InngestSyncKind = \"x-inngest-sync-kind\",\n  EventIdSeed = \"x-inngest-event-id-seed\",\n  TraceParent = \"traceparent\",\n  TraceState = \"tracestate\",\n  InngestRunId = \"x-run-id\",\n}\n\n/**\n * Headers that are forwarded from the original request when an Inngest function\n * is invoked.\n */\nexport const forwardedHeaders = [headerKeys.TraceParent, headerKeys.TraceState];\n\nexport const defaultInngestApiBaseUrl = \"https://api.inngest.com/\";\nexport const defaultInngestEventBaseUrl = \"https://inn.gs/\";\nexport const defaultDevServerHost = \"http://localhost:8288/\";\n\n/**\n * Events that Inngest may send internally that can be used to trigger\n * functions.\n *\n * @public\n */\nexport enum internalEvents {\n  /**\n   * A function has failed after exhausting all available retries. This event\n   * will contain the original event and the error that caused the failure.\n   */\n  FunctionFailed = \"inngest/function.failed\",\n  FunctionInvoked = \"inngest/function.invoked\",\n  FunctionFinished = \"inngest/function.finished\",\n  FunctionCancelled = \"inngest/function.cancelled\",\n  ScheduledTimer = \"inngest/scheduled.timer\",\n}\n\n/**\n * Events that are known globally by the Inngest platform.\n */\nexport enum knownEvents {\n  /**\n   * An HTTP request has been received to trigger a function execution.\n   */\n  HttpRunStarted = \"http/run.started\",\n}\n\nexport const logPrefix: string = chalk.magenta.bold(\"[Inngest]\");\n\nexport const debugPrefix = \"inngest\";\n\nexport const dummyEventKey = \"NO_EVENT_KEY_SET\";\n\nexport enum serverKind {\n  Dev = \"dev\",\n  Cloud = \"cloud\",\n}\n\nexport enum syncKind {\n  InBand = \"in_band\",\n  OutOfBand = \"out_of_band\",\n}\n\n/**\n * The execution models the SDK is aware of.\n *\n * This is used in a number of places to ensure all execution versions are\n * accounted for for a given operation.\n */\nexport enum ExecutionVersion {\n  /**\n   * Very legacy, initial version of the executor. Uses hashed op objects and\n   * `pos` to determine the order of execution and which ops to run.\n   *\n   * Very stubborn about determinism.\n   */\n  V0 = 0,\n\n  /**\n   * Uses a more flexible approach to execution and is more lenient about\n   * determinism, allowing non-step async actions and non-determinism.\n   *\n   * Nowhere near as stubborn about determinism and so can silently migrate\n   * between versions after bug fixes.\n   */\n  V1 = 1,\n\n  /**\n   * Identical to V1, but allows the Executor to optimize parallel calls, hugely\n   * reducing traffic going to/from the SDK.\n   */\n  V2 = 2,\n}\n\n/**\n * Default maximum number of retries for function/step executions.\n */\nexport const defaultMaxRetries = 3;\n"],"names":["logPrefix: string"],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 220, "column": 0}, "map": {"version":3,"sources":["file:///Users/amansatyawani/Desktop/website-builder/node_modules/.pnpm/inngest%403.45.1_%40opentelemetry%2Bcore%402.2.0_%40opentelemetry%2Bapi%401.9.0__express%405.1.0_next%401_e029d374516642dd9a767b32fbb0beec/node_modules/inngest/_virtual/rolldown_runtime.js"],"sourcesContent":["//#region rolldown:runtime\nvar __defProp = Object.defineProperty;\nvar __export = (all) => {\n\tlet target = {};\n\tfor (var name in all) __defProp(target, name, {\n\t\tget: all[name],\n\t\tenumerable: true\n\t});\n\treturn target;\n};\nvar __require = /* @__PURE__ */ ((x) => typeof require !== \"undefined\" ? require : typeof Proxy !== \"undefined\" ? new Proxy(x, { get: (a, b) => (typeof require !== \"undefined\" ? require : a)[b] }) : x)(function(x) {\n\tif (typeof require !== \"undefined\") return require.apply(this, arguments);\n\tthrow Error(\"Calling `require` for \\\"\" + x + \"\\\" in an environment that doesn't expose the `require` function.\");\n});\n\n//#endregion\nexport { __export, __require };"],"names":[],"mappings":"AAAA,0BAA0B;;;;;AAC1B,IAAI,YAAY,OAAO,cAAc;AACrC,IAAI,WAAW,CAAC;IACf,IAAI,SAAS,CAAC;IACd,IAAK,IAAI,QAAQ,IAAK,UAAU,QAAQ,MAAM;QAC7C,KAAK,GAAG,CAAC,KAAK;QACd,YAAY;IACb;IACA,OAAO;AACR;AACA,IAAI,YAAY,aAAa,GAAG,CAAC,CAAC,IAAM,uIAAgK,EAAE,SAAS,CAAC;IACnN,wCAAoC,OAAO,0DAAQ,KAAK,CAAC,IAAI,EAAE;;AAEhE","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 245, "column": 0}, "map": {"version":3,"file":"types.js","sources":["file:///Users/amansatyawani/Desktop/website-builder/node_modules/.pnpm/inngest%403.45.1_%40opentelemetry%2Bcore%402.2.0_%40opentelemetry%2Bapi%401.9.0__express%405.1.0_next%401_e029d374516642dd9a767b32fbb0beec/node_modules/src/types.ts"],"sourcesContent":["/**\n * Internal types and schemas used throughout the Inngest SDK.\n *\n * Note that types intended to be imported and utilized in userland code will be\n * exported from the main entrypoint of the SDK, `inngest`; importing types\n * directly from this file may result in breaking changes in non-major bumps as\n * only those exported from `inngest` are considered stable.\n *\n * @module\n */\n\nimport { z } from \"zod/v3\";\nimport type { EventSchemas } from \"./components/EventSchemas.ts\";\nimport type {\n  builtInMiddleware,\n  GetEvents,\n  Inngest,\n} from \"./components/Inngest.ts\";\nimport type { InngestFunction } from \"./components/InngestFunction.ts\";\nimport type { InngestFunctionReference } from \"./components/InngestFunctionReference.ts\";\nimport type {\n  ExtendSendEventWithMiddleware,\n  InngestMiddleware,\n} from \"./components/InngestMiddleware.ts\";\nimport type { createStepTools } from \"./components/InngestStepTools.ts\";\nimport type { internalEvents, knownEvents } from \"./helpers/consts.ts\";\nimport type {\n  AsTuple,\n  IsEqual,\n  IsNever,\n  Public,\n  Simplify,\n  WithoutInternal,\n} from \"./helpers/types.ts\";\nimport type { Logger } from \"./middleware/logger.ts\";\n\nexport type { Jsonify } from \"./helpers/jsonify.ts\";\nexport type { SimplifyDeep } from \"./helpers/types.ts\";\n\nconst baseJsonErrorSchema = z.object({\n  name: z.string().trim().optional(),\n  error: z.string().trim().optional(),\n  message: z.string().trim().optional(),\n  stack: z.string().trim().optional(),\n});\n\nconst maybeJsonErrorSchema: z.ZodType<{\n  name: string;\n  message: string;\n  stack?: string;\n  cause?: unknown;\n}> = z.lazy(() =>\n  z.object({\n    name: z.string().trim(),\n    message: z.string().trim(),\n    stack: z.string().trim().optional(),\n    cause: z.union([maybeJsonErrorSchema, z.unknown()]).optional(),\n  }),\n);\n\nexport type JsonError = z.infer<typeof baseJsonErrorSchema> & {\n  name: string;\n  message: string;\n  cause?: unknown;\n};\n\nexport const jsonErrorSchema = baseJsonErrorSchema\n  .extend({\n    cause: z.union([maybeJsonErrorSchema, z.unknown()]).optional(),\n  })\n  .passthrough()\n  .catch({})\n  .transform((val) => {\n    return {\n      ...val,\n      name: val.name || \"Error\",\n      message: val.message || val.error || \"Unknown error\",\n      stack: val.stack,\n    };\n  }) as z.ZodType<JsonError>;\n\n/**\n * The payload for an API endpoint running steps.\n */\nexport type APIStepPayload = {\n  name: `${knownEvents.HttpRunStarted}`;\n  data: {\n    /**\n     * The domain that served the original request.\n     */\n    domain: string;\n\n    /**\n     * The method used to trigger the original request.\n     */\n    method: string;\n\n    /**\n     * The URL path of the original request.\n     */\n    path: string;\n\n    /**\n     * The IP that made the original request, fetched from headers.\n     */\n    ip: string;\n\n    /**\n     * The \"Content-Type\" header of the original request.\n     */\n    content_type: string;\n\n    /**\n     * The query parameters of the original request, as a single string without\n     * the leading `\"?\"`.\n     */\n    query_params: string;\n\n    /**\n     * The body of the original request.\n     */\n    body?: string;\n\n    /**\n     * An optional function ID to use for this endpoint. If not provided,\n     * Inngest will generate a function ID based on the method and path, e.g.\n     * `\"GET /api/hello\"`.\n     */\n    fn?: string; // maybe explicit fn ID from user, else empty\n  };\n};\n\n/**\n * The payload for an internal Inngest event that is sent when a function fails.\n *\n * @public\n */\nexport type FailureEventPayload<P extends EventPayload = EventPayload> = {\n  name: `${internalEvents.FunctionFailed}`;\n  data: {\n    function_id: string;\n    run_id: string;\n    error: z.output<typeof jsonErrorSchema>;\n    event: P;\n  };\n};\n\n/**\n * Context arguments specific to a failure event.\n *\n * @public\n */\nexport type FailureEventArgs<P extends EventPayload = EventPayload> = {\n  /**\n   * The event data present in the payload.\n   */\n  event: FailureEventPayload<P>;\n\n  /**\n   * The final error that caused this function to exhaust all retries.\n   */\n  error: Error;\n};\n\n/**\n * The payload for an internal Inngest event that is sent when a function\n * finishes, either by completing successfully or failing.\n *\n * @public\n */\nexport type FinishedEventPayload = {\n  name: `${internalEvents.FunctionFinished}`;\n  data: {\n    function_id: string;\n    run_id: string;\n    correlation_id?: string;\n  } & (\n    | {\n        error: z.output<typeof jsonErrorSchema>;\n      }\n    | {\n        result: unknown;\n      }\n  );\n};\n\n/**\n * The payload for an internal Inngest event that is sent when a function is\n * cancelled.\n */\nexport type CancelledEventPayload = {\n  name: `${internalEvents.FunctionCancelled}`;\n  data: {\n    function_id: string;\n    run_id: string;\n    correlation_id?: string;\n  };\n};\n\n/**\n * The payload for any generic function invocation event. In practice, the event\n * data will be more specific to the function being invoked.\n *\n * @public\n */\nexport type InvokedEventPayload = Simplify<\n  Omit<EventPayload, \"name\"> & {\n    name: `${internalEvents.FunctionInvoked}`;\n  }\n>;\n\n/**\n * The payload for the event sent to a function when it is triggered by a cron.\n *\n * @public\n */\nexport type ScheduledTimerEventPayload = Simplify<\n  Omit<EventPayload, \"name\" | \"data\" | \"id\"> & {\n    name: `${internalEvents.ScheduledTimer}`;\n    data: {\n      cron: string;\n    };\n    id: string;\n  }\n>;\n\n/**\n * Unique codes for the different types of operation that can be sent to Inngest\n * from SDK step functions.\n */\nexport enum StepOpCode {\n  WaitForSignal = \"WaitForSignal\",\n\n  WaitForEvent = \"WaitForEvent\",\n\n  /**\n   * Legacy equivalent to `\"StepRun\"`. Has mixed data wrapping (e.g. `data` or\n   * `data.data` depending on SDK version), so this is phased out in favour of\n   * `\"StepRun\"`, which never wraps.\n   *\n   * Note that it is still used for v0 executions for backwards compatibility.\n   *\n   * @deprecated Only used for v0 executions; use `\"StepRun\"` instead.\n   */\n  Step = \"Step\",\n  StepRun = \"StepRun\",\n  StepError = \"StepError\",\n  StepFailed = \"StepFailed\",\n  StepPlanned = \"StepPlanned\",\n  Sleep = \"Sleep\",\n\n  /**\n   * Used to signify that the executor has requested that a step run, but we\n   * could not find that step.\n   *\n   * This is likely indicative that a step was renamed or removed from the\n   * function.\n   */\n  StepNotFound = \"StepNotFound\",\n\n  InvokeFunction = \"InvokeFunction\",\n  AiGateway = \"AIGateway\",\n  Gateway = \"Gateway\",\n\n  RunComplete = \"RunComplete\",\n}\n\n/**\n * StepModes are used to specify how the SDK should execute a function.\n */\nexport enum StepMode {\n  /**\n   * A synchronous method of execution, where steps are executed immediately and\n   * their results are \"checkpointed\" back to Inngest in real-time.\n   */\n  Sync = \"sync\",\n\n  /**\n   * The traditional, background method of execution, where all steps are queued\n   * and executed asynchronously and always triggered by Inngest.\n   */\n  Async = \"async\",\n}\n\n/**\n * The type of response you wish to return to an API endpoint when using steps\n * within it and we must transition to {@link StepMode.Async}.\n *\n * In most cases, this defaults to {@link AsyncResponseType.Redirect}.\n */\nexport enum AsyncResponseType {\n  /**\n   * When switching to {@link StepMode.Async}, respond with a 302 redirect which\n   * will end the request once the run has completed asynchronously in the\n   * background.\n   */\n  Redirect = \"redirect\",\n\n  /**\n   * When switching to {@link StepMode.Async}, respond with a token and run ID\n   * which can be used to poll for the status of the run.\n   */\n  Token = \"token\",\n\n  /**\n   * TODO Comment\n   */\n  // Custom = \"custom\",\n}\n\n/**\n * The type of response you wish to return to an API endpoint when using steps\n * within it and we must transition to {@link StepMode.Async}.\n *\n * In most cases, this defaults to {@link AsyncResponseType.Redirect}.\n */\nexport type AsyncResponseValue =\n  | AsyncResponseType.Redirect\n  | AsyncResponseType.Token;\n// | (() => null);\n\n/**\n * The shape of a single operation in a step function. Used to communicate\n * desired and received operations to Inngest.\n */\nexport type Op = {\n  /**\n   * The unique code for this operation.\n   */\n  op: StepOpCode;\n\n  /**\n   * What {@link StepMode} this step supports. If a step is marked as supporting\n   * {@link StepMode.Async} we must be in (or switch to) async mode in order to\n   * execute it.\n   */\n  mode: StepMode;\n\n  /**\n   * The unhashed step name for this operation. This is a legacy field that is\n   * sometimes used for critical data, like the sleep duration for\n   * `step.sleep()`.\n   *\n   * @deprecated For display name, use `displayName` instead.\n   */\n  name?: string;\n\n  /**\n   * An optional name for this step that can be used to display in the Inngest\n   * UI.\n   */\n  displayName?: string;\n\n  /**\n   * Any additional data required for this operation to send to Inngest. This\n   * is not compared when confirming that the operation was completed; use `id`\n   * for this.\n   */\n  opts?: Record<string, unknown>;\n\n  /**\n   * Any data present for this operation. If data is present, this operation is\n   * treated as completed.\n   */\n  data?: unknown;\n\n  /**\n   * An error present for this operation. If an error is present, this operation\n   * is treated as completed, but failed. When this is read from the op stack,\n   * the SDK will throw the error via a promise rejection when it is read.\n   *\n   * This allows users to handle step failures using common tools such as\n   * try/catch or `.catch()`.\n   */\n  error?: unknown;\n\n  /**\n   * Extra info used to annotate spans associated with this operation.\n   */\n  userland: OpUserland;\n\n  /**\n   * Golang-compatibile `interval.Interval` timing information for this operation.\n   */\n  timing?: {\n    /**\n     * UNIX nanosecond timestamp for when the operation started.\n     */\n    a: number;\n\n    /**\n     * The duration of the operation in nanoseconds.\n     */\n    b: number;\n  };\n};\n\n/**\n * Extra info attached to an operation.\n */\nexport type OpUserland = {\n  /**\n   * The unhashed, user-defined ID of the step.\n   */\n  id: string;\n  /**\n   * The auto-incremented index for repeated steps (if repeated).\n   */\n  index?: number;\n};\n\nexport const incomingOpSchema = z.object({\n  id: z.string().min(1),\n  data: z.any().optional(),\n  error: z.any().optional(),\n  input: z.any().optional(),\n});\n\nexport type IncomingOp = z.output<typeof incomingOpSchema>;\n\n/**\n * The shape of a step operation that is sent to an Inngest Server from an SDK.\n *\n * @public\n */\nexport type OutgoingOp = Pick<\n  Omit<HashedOp, \"userland\"> & { userland?: OpUserland },\n  | \"id\"\n  | \"op\"\n  | \"name\"\n  | \"opts\"\n  | \"data\"\n  | \"error\"\n  | \"displayName\"\n  | \"userland\"\n  | \"timing\"\n>;\n\n/**\n * The shape of a hashed operation in a step function. Used to communicate\n * desired and received operations to Inngest.\n */\nexport type HashedOp = Op & {\n  /**\n   * The hashed identifier for this operation, used to confirm that the\n   * operation was completed when it is received from Inngest.\n   */\n  id: string;\n};\n\n/**\n * A helper type to represent a stack of operations that will accumulate\n * throughout a step function's run.  This stack contains an object of\n * op hashes to data.\n */\nexport type OpStack = IncomingOp[];\n\n/**\n * A function that can be used to submit an operation to Inngest internally.\n */\nexport type SubmitOpFn = (op: Op) => void;\n\n/**\n * A sleep-compatible time string such as `\"1h30m15s\"` that can be sent to\n * Inngest to sleep for a given amount of time.\n *\n * This type includes an empty string too, so make sure to exclude that via\n * `Exclude<TimeStr, \"\">` if you don't want to allow empty strings.\n *\n * @public\n */\nexport type TimeStr = `${`${number}w` | \"\"}${`${number}d` | \"\"}${\n  | `${number}h`\n  | \"\"}${`${number}m` | \"\"}${`${number}s` | \"\"}`;\n\nexport type TimeStrBatch = `${`${number}s`}`;\n\n/**\n * Mutates an {@link EventPayload} `T` to include invocation events.\n */\nexport type WithInvocation<T extends EventPayload> = Simplify<\n  { name: T[\"name\"] | `${internalEvents.FunctionInvoked}` } & Omit<T, \"name\">\n>;\n\n/**\n * Makes sure that all event names are stringified and not enums or other\n * values.\n */\ntype StringifyAllEvents<T> = {\n  [K in keyof T as `${K & string}`]: Simplify<\n    Omit<T[K], \"name\"> & { name: `${K & string}` }\n  >;\n};\n\n/**\n * Given a client and a set of triggers, returns a record of all the events that\n * can be used to trigger a function. This will also include invocation events,\n * which currently could represent any of the triggers.\n */\ntype GetSelectedEvents<\n  TClient extends Inngest.Any,\n  TTriggers extends TriggersFromClient<TClient>,\n> = Pick<GetEvents<TClient, true>, TTriggers> &\n  StringifyAllEvents<{\n    // Invocation events could (currently) represent any of the payloads that\n    // could be used to trigger the function. We use a distributive `Pick` over allto\n    // ensure this is represented correctly in typing.\n    [internalEvents.FunctionInvoked]: Simplify<{\n      name: `${internalEvents.FunctionInvoked}`;\n    }> &\n      Pick<\n        Pick<GetEvents<TClient, true>, TTriggers>[keyof Pick<\n          GetEvents<TClient, true>,\n          TTriggers\n        >],\n        AssertKeysAreFrom<EventPayload, \"id\" | \"data\" | \"user\" | \"v\" | \"ts\">\n      >;\n  }>;\n\n/**\n * Returns a union of all the events that can be used to trigger a function\n * based on the given `TClient` and `TTriggers`.\n *\n * Can optionally include or exclude internal events with `TExcludeInternal`.\n */\ntype GetContextEvents<\n  TClient extends Inngest.Any,\n  TTriggers extends TriggersFromClient<TClient>,\n  TExcludeInternal extends boolean = false,\n  // TInvokeSchema extends ValidSchemaInput = never,\n> = Simplify<\n  TExcludeInternal extends true\n    ? WithoutInternal<\n        GetSelectedEvents<TClient, TTriggers>\n      >[keyof WithoutInternal<GetSelectedEvents<TClient, TTriggers>>]\n    : GetSelectedEvents<TClient, TTriggers>[keyof GetSelectedEvents<\n        TClient,\n        TTriggers\n      >]\n>;\n\n/**\n * Base context object, omitting any extras that may be added by middleware or\n * function configuration.\n *\n * @public\n */\nexport type BaseContext<\n  TClient extends Inngest.Any,\n  TTriggers extends TriggersFromClient<TClient> = TriggersFromClient<TClient>,\n> = {\n  /**\n   * The event data present in the payload.\n   */\n  event: GetContextEvents<TClient, TTriggers>;\n  events: AsTuple<GetContextEvents<TClient, TTriggers, true>>;\n\n  /**\n   * The run ID for the current function execution\n   */\n  runId: string;\n\n  step: ReturnType<typeof createStepTools<TClient>>;\n\n  /**\n   * The current zero-indexed attempt number for this function execution. The\n   * first attempt will be `0`, the second `1`, and so on. The attempt number\n   * is incremented every time the function throws an error and is retried.\n   */\n  attempt: number;\n\n  /**\n   * The maximum number of attempts allowed for this function.\n   */\n  maxAttempts?: number;\n};\n\n/**\n * Builds a context object for an Inngest handler, optionally overriding some\n * keys.\n *\n * @internal\n */\nexport type Context<\n  TClient extends Inngest.Any = Inngest.Any,\n  TTriggers extends TriggersFromClient<TClient> = TriggersFromClient<TClient>,\n  TOverrides extends Record<string, unknown> = Record<never, never>,\n> = Omit<BaseContext<TClient, TTriggers>, keyof TOverrides> & TOverrides;\n\n/**\n * Builds a context object for an Inngest handler, optionally overriding some\n * keys.\n *\n * @internal\n */\nexport namespace Context {\n  /**\n   * Represents any `Context` object, regardless of generics and inference.\n   */\n  export type Any = Context;\n}\n\n/**\n * The shape of a Inngest function, taking in event, step, ctx, and step\n * tooling.\n *\n * @public\n */\nexport type Handler<\n  TClient extends Inngest.Any,\n  TTriggers extends TriggersFromClient<TClient> = TriggersFromClient<TClient>,\n  TOverrides extends Record<string, unknown> = Record<never, never>,\n> = (\n  /**\n   * The context argument provides access to all data and tooling available to\n   * the function.\n   */\n  ctx: Context<TClient, TTriggers, TOverrides>,\n) => unknown;\n\nexport type TriggersFromClient<TClient extends Inngest.Any = Inngest.Any> =\n  keyof GetEvents<TClient, true> & string;\n\n/**\n * The shape of a Inngest function, taking in event, step, ctx, and step\n * tooling.\n *\n * @public\n */\nexport namespace Handler {\n  /**\n   * Represents any `Handler`, regardless of generics and inference.\n   */\n  // biome-ignore lint/suspicious/noExplicitAny: <explanation>\n  export type Any = Handler<Inngest.Any, any, any>;\n}\n\n/**\n * Asserts that the given keys `U` are all present in the given object `T`.\n *\n * Used as an internal type guard to ensure that changes to keys are accounted\n * for\n */\ntype AssertKeysAreFrom<T, K extends keyof T> = K;\n\n/**\n * The shape of a single event's payload without any fields used to identify the\n * actual event being sent.\n *\n * This is used to represent an event payload when invoking a function, as the\n * event name is not known or needed.\n */\n// biome-ignore lint/suspicious/noExplicitAny: <explanation>\nexport interface MinimalEventPayload<TData = any> {\n  /**\n   * A unique id used to idempotently process a given event payload.\n   *\n   * Set this when sending events to ensure that the event is only processed\n   * once; if an event with the same ID is sent again, it will not invoke\n   * functions.\n   */\n  id?: string;\n\n  /**\n   * Any data pertinent to the event\n   */\n  data?: TData;\n\n  /**\n   * Any user data associated with the event\n   * All fields ending in \"_id\" will be used to attribute the event to a particular user\n   */\n  // biome-ignore lint/suspicious/noExplicitAny: <explanation>\n  user?: any;\n\n  /**\n   * A specific event schema version\n   * (optional)\n   */\n  v?: string;\n}\n\n/**\n * The shape of a single event's payload. It should be extended to enforce\n * adherence to given events and not used as a method of creating them (i.e. as\n * a generic).\n *\n * @public\n */\n// biome-ignore lint/suspicious/noExplicitAny: <explanation>\nexport interface EventPayload<TData = any> extends MinimalEventPayload<TData> {\n  /**\n   * A unique identifier for the type of event. We recommend using lowercase dot\n   * notation for names, prepending `prefixes/` with a slash for organization.\n   *\n   * e.g. `cloudwatch/alarms/triggered`, `cart/session.created`\n   */\n  name: string;\n\n  /**\n   * An integer representing the milliseconds since the unix epoch at which this\n   * event occurred.\n   *\n   * Defaults to the current time.\n   * (optional)\n   */\n  ts?: number;\n}\n\nexport const sendEventResponseSchema = z.object({\n  /**\n   * Event IDs\n   */\n  ids: z.array(z.string()).default([]),\n\n  /**\n   * HTTP Status Code. Will be undefined if no request was sent.\n   */\n  status: z.number().default(0),\n\n  /**\n   * Error message. Will be undefined if no error occurred.\n   */\n  error: z.string().optional(),\n});\n\n/**\n * The response from the Inngest Event API\n */\nexport type SendEventResponse = z.output<typeof sendEventResponseSchema>;\n\n/**\n * The response in code from sending an event to Inngest.\n *\n * @public\n */\nexport type SendEventBaseOutput = {\n  ids: SendEventResponse[\"ids\"];\n};\n\nexport type SendEventOutput<TOpts extends ClientOptions> = Omit<\n  SendEventBaseOutput,\n  keyof SendEventOutputWithMiddleware<TOpts>\n> &\n  SendEventOutputWithMiddleware<TOpts>;\n\nexport type SendEventOutputWithMiddleware<TOpts extends ClientOptions> =\n  ExtendSendEventWithMiddleware<\n    [typeof builtInMiddleware, NonNullable<TOpts[\"middleware\"]>],\n    SendEventBaseOutput\n  >;\n\n/**\n * An HTTP-like, standardised response format that allows Inngest to help\n * orchestrate steps and retries.\n *\n * @internal\n */\nexport interface Response {\n  /**\n   * A step response must contain an HTTP status code.\n   *\n   * A `2xx` response indicates success; this is not a failure and no retry is\n   * necessary.\n   *\n   * A `4xx` response indicates a bad request; this step will not be retried as\n   * it is deemed irrecoverable. Examples of this might be an event with\n   * insufficient data or concerning a user that no longer exists.\n   *\n   * A `5xx` status indicates a temporary internal error; this will be retried\n   * according to the step and function's retry policy (3 times, by default).\n   *\n   * {@link https://www.inngest.com/docs/functions/function-input-and-output#response-format}\n   * {@link https://www.inngest.com/docs/functions/retries}\n   */\n  status: number;\n\n  /**\n   * The output of the function - the `body` - can be any arbitrary\n   * JSON-compatible data. It is then usable by any future steps.\n   *\n   * {@link https://www.inngest.com/docs/functions/function-input-and-output#response-format}\n   */\n  body?: unknown;\n}\n\n/**\n * A single step within a function.\n *\n * @internal\n */\nexport type Step<TContext = unknown> = (\n  /**\n   * The context for this step, including the triggering event and any previous\n   * step output.\n   */\n  context: TContext,\n) => Promise<Response> | Response;\n\n/**\n * A set of options for configuring the Inngest client.\n *\n * @public\n */\nexport interface ClientOptions {\n  /**\n   * The ID of this instance, most commonly a reference to the application it\n   * resides in.\n   *\n   * The ID of your client should remain the same for its lifetime; if you'd\n   * like to change the name of your client as it appears in the Inngest UI,\n   * change the `name` property instead.\n   */\n  id: string;\n\n  /**\n   * Inngest event key, used to send events to Inngest Cloud. If not provided,\n   * will search for the `INNGEST_EVENT_KEY` environment variable. If neither\n   * can be found, however, a warning will be shown and any attempts to send\n   * events will throw an error.\n   */\n  eventKey?: string;\n\n  /**\n   * The base URL to use when contacting Inngest.\n   *\n   * Defaults to https://inn.gs/ for sending events and https://api.inngest.com\n   * for all other communication with Inngest.\n   */\n  baseUrl?: string;\n\n  /**\n   * If provided, will override the used `fetch` implementation. Useful for\n   * giving the library a particular implementation if accessing it is not done\n   * via globals.\n   *\n   * By default the library will try to use the native Web API fetch, falling\n   * back to a Node implementation if no global fetch can be found.\n   *\n   * If you wish to specify your own fetch, make sure that you preserve its\n   * binding, either by using `.bind` or by wrapping it in an anonymous\n   * function.\n   */\n  fetch?: typeof fetch;\n\n  /**\n   * Provide an `EventSchemas` class to type events, providing type safety when\n   * sending events and running functions via Inngest.\n   *\n   * You can provide generated Inngest types, custom types, types using Zod, or\n   * a combination of the above. See {@link EventSchemas} for more information.\n   *\n   * @example\n   *\n   * ```ts\n   * export const inngest = new Inngest({\n   *   id: \"my-app\",\n   *   schemas: new EventSchemas().fromZod({\n   *     \"app/user.created\": {\n   *       data: z.object({\n   *         id: z.string(),\n   *         name: z.string(),\n   *       }),\n   *     },\n   *   }),\n   * });\n   * ```\n   */\n  schemas?: EventSchemas<Record<string, EventPayload>>;\n\n  /**\n   * The Inngest environment to send events to. Defaults to whichever\n   * environment this client's event key is associated with.\n   *\n   * It's likely you never need to change this unless you're trying to sync\n   * multiple systems together using branch names.\n   */\n  env?: string;\n\n  /**\n   * The logger provided by the user.\n   * The user can passed in their winston, pino, and other loggers for\n   * handling log delivery to external services.\n   *\n   * The provider logger is expected to implement the following API interfaces\n   * - .info()\n   * - .warn()\n   * - .debug()\n   * - .error()\n   * which most loggers already do.\n   *\n   * Defaults to a dummy logger that just log things to the console if nothing is provided.\n   */\n  logger?: Logger;\n  middleware?: InngestMiddleware.Stack;\n\n  /**\n   * Can be used to explicitly set the client to Development Mode, which will\n   * turn off signature verification and default to using a local URL to access\n   * a local Dev Server.\n   *\n   * This is useful for forcing the client to use a local Dev Server while also\n   * running in a production-like environment.\n   */\n  isDev?: boolean;\n\n  /**\n   * The application-specific version identifier. This can be an arbitrary value\n   * such as a version string, a Git commit SHA, or any other unique identifier.\n   */\n  appVersion?: string;\n\n  /**\n   * If `true`, parallel steps within functions are optimized to reduce traffic\n   * during `Promise` resolution, which can hugely reduce the time taken and\n   * number of requests for each run.\n   *\n   * Note that this will be the default behaviour in v4 and in its current form\n   * will cause `Promise.*()` to wait for all promises to settle before\n   * resolving.\n   *\n   * @default false\n   */\n  optimizeParallelism?: boolean;\n}\n\n/**\n * A set of log levels that can be used to control the amount of logging output\n * from various parts of the Inngest library.\n *\n * @public\n */\nexport const logLevels = [\n  \"fatal\",\n  \"error\",\n  \"warn\",\n  \"info\",\n  \"debug\",\n  \"silent\",\n] as const;\n\n/**\n * A set of log levels that can be used to control the amount of logging output\n * from various parts of the Inngest library.\n *\n * @public\n */\nexport type LogLevel = (typeof logLevels)[number];\n\n/**\n * A set of options for configuring the registration of Inngest functions.\n *\n * @public\n */\nexport interface RegisterOptions {\n  /**\n   * A key used to sign requests to and from Inngest in order to prove that the\n   * source is legitimate.\n   *\n   * You must provide a signing key to communicate securely with Inngest. If\n   * your key is not provided here, we'll try to retrieve it from the\n   * `INNGEST_SIGNING_KEY` environment variable.\n   *\n   * You can retrieve your signing key from the Inngest UI inside the \"Secrets\"\n   * section at {@link https://app.inngest.com/secrets}. We highly recommend\n   * that you add this to your platform's available environment variables as\n   * `INNGEST_SIGNING_KEY`.\n   *\n   * If no key can be found, you will not be able to register your functions or\n   * receive events from Inngest.\n   */\n  signingKey?: string;\n\n  /**\n   * The same as signingKey, except used as a fallback when auth fails using the\n   * primary signing key.\n   */\n  signingKeyFallback?: string;\n\n  /**\n   * The URL used to register functions with Inngest.\n   * Defaults to https://api.inngest.com/fn/register\n   */\n  baseUrl?: string;\n\n  /**\n   * If provided, will override the used `fetch` implementation. Useful for\n   * giving the library a particular implementation if accessing it is not done\n   * via globals.\n   *\n   * By default the library will try to use the native Web API fetch, falling\n   * back to a Node implementation if no global fetch can be found.\n   */\n  fetch?: typeof fetch;\n\n  /**\n   * The path to the Inngest serve endpoint. e.g.:\n   *\n   *     \"/some/long/path/to/inngest/endpoint\"\n   *\n   * By default, the library will try to infer this using request details such\n   * as the \"Host\" header and request path, but sometimes this isn't possible\n   * (e.g. when running in a more controlled environments such as AWS Lambda or\n   * when dealing with proxies/rediects).\n   *\n   * Provide the custom path (excluding the hostname) here to ensure that the\n   * path is reported correctly when registering functions with Inngest.\n   *\n   * To also provide a custom hostname, use `serveHost`.\n   */\n  servePath?: string;\n\n  /**\n   * The host used to access the Inngest serve endpoint, e.g.:\n   *\n   *     \"https://myapp.com\"\n   *\n   * By default, the library will try to infer this using request details such\n   * as the \"Host\" header and request path, but sometimes this isn't possible\n   * (e.g. when running in a more controlled environments such as AWS Lambda or\n   * when dealing with proxies/redirects).\n   *\n   * Provide the custom hostname here to ensure that the path is reported\n   * correctly when registering functions with Inngest.\n   *\n   * To also provide a custom path, use `servePath`.\n   */\n  serveHost?: string;\n\n  /**\n   * The minimum level to log from the Inngest serve endpoint.\n   *\n   * Default level: \"info\"\n   */\n  logLevel?: LogLevel;\n\n  /**\n   * Some serverless providers (especially those with edge compute) may support\n   * streaming responses back to Inngest. This can be used to circumvent\n   * restrictive request timeouts and other limitations. It is only available if\n   * the serve handler being used supports streaming.\n   *\n   * If this is `\"allow\"`, the SDK will attempt to stream responses back to\n   * Inngest if it can confidently detect support for it by verifyng that the\n   * platform and the serve handler supports streaming.\n   *\n   * If this is `\"force\"`, the SDK will always attempt to stream responses back\n   * to Inngest regardless of whether we can detect support for it or not. This\n   * will override `allowStreaming`, but will still not attempt to stream if\n   * the serve handler does not support it.\n   *\n   * If this is `false`, streaming will never be used.\n   *\n   * Defaults to `false`.\n   */\n  streaming?: \"allow\" | \"force\" | false;\n\n  /**\n   * The ID of this app. This is used to group functions together in the Inngest\n   * UI. The ID of the passed client is used by default.\n   * @deprecated Will be removed in v4.\n   */\n  id?: string;\n}\n\n/**\n * This schema is used internally to share the shape of a concurrency option\n * when validating config. We cannot add comments to Zod fields, so we just use\n * an extra type check to ensure it matches our exported expectations.\n */\nconst concurrencyOptionSchema = z.strictObject({\n  limit: z.number(),\n  key: z.string().optional(),\n  scope: z.enum([\"fn\", \"env\", \"account\"]).optional(),\n});\n\nconst _checkConcurrencySchemaAligns: IsEqual<\n  ConcurrencyOption,\n  z.output<typeof concurrencyOptionSchema>\n> = true;\n\nexport interface ConcurrencyOption {\n  /**\n   * The concurrency limit for this option, adding a limit on how many concurrent\n   * steps can execute at once.\n   */\n  limit: number;\n\n  /**\n   * An optional concurrency key, as an expression using the common expression language\n   * (CEL).  The result of this expression is used to create new concurrency groups, or\n   * sub-queues, for each function run.\n   *\n   * The event is passed into this expression as \"event\".\n   *\n   * Examples:\n   * - `event.data.user_id`:  this evaluates to the user_id in the event.data object.\n   * - `event.data.user_id + \"-\" + event.data.account_id`: creates a new group per user/account\n   * - `\"ai\"`:  references a custom string\n   */\n  key?: string;\n\n  /**\n   * An optional scope for the concurrency group.  By default, concurrency limits are\n   * scoped to functions - one function's concurrency limits do not impact other functions.\n   *\n   * Changing this \"scope\" allows concurrency limits to work across environments (eg. production\n   * vs branch environments) or across your account (global).\n   */\n  scope?: \"fn\" | \"env\" | \"account\";\n}\n\n/**\n * Configuration for cancelling a function run based on an incoming event.\n *\n * @public\n */\nexport type Cancellation<Events extends Record<string, EventPayload>> = {\n  [K in keyof Events & string]: {\n    /**\n     * The name of the event that should cancel the function run.\n     */\n    event: K;\n\n    /**\n     * The expression that must evaluate to true in order to cancel the function run. There\n     * are two variables available in this expression:\n     * - event, referencing the original function's event trigger\n     * - async, referencing the new cancel event.\n     *\n     * @example\n     *\n     * Ensures the cancel event's data.user_id field matches the triggering event's data.user_id\n     * field:\n     *\n     * ```ts\n     * \"async.data.user_id == event.data.user_id\"\n     * ```\n     */\n    if?: string;\n\n    /**\n     * If provided, the step function will wait for the incoming event to match\n     * particular criteria. If the event does not match, it will be ignored and\n     * the step function will wait for another event.\n     *\n     * It must be a string of a dot-notation field name within both events to\n     * compare, e.g. `\"data.id\"` or `\"user.email\"`.\n     *\n     * ```\n     * // Wait for an event where the `user.email` field matches\n     * match: \"user.email\"\n     * ```\n     *\n     * All of these are helpers for the `if` option, which allows you to specify\n     * a custom condition to check. This can be useful if you need to compare\n     * multiple fields or use a more complex condition.\n     *\n     * See the Inngest expressions docs for more information.\n     *\n     * {@link https://www.inngest.com/docs/functions/expressions}\n     *\n     * @deprecated Use `if` instead.\n     */\n    match?: string;\n\n    /**\n     * An optional timeout that the cancel is valid for.  If this isn't\n     * specified, cancellation triggers are valid for up to a year or until the\n     * function ends.\n     *\n     * The time to wait can be specified using a `number` of milliseconds, an\n     * `ms`-compatible time string like `\"1 hour\"`, `\"30 mins\"`, or `\"2.5d\"`, or\n     * a `Date` object.\n     *\n     * {@link https://npm.im/ms}\n     */\n    timeout?: number | string | Date;\n  };\n}[keyof Events & string];\n\n/**\n * The response to send to Inngest when pushing function config either directly\n * or when pinged by Inngest Cloud.\n *\n * @internal\n */\nexport interface RegisterRequest {\n  /**\n   * The API handler's URL to invoke SDK based functions.\n   */\n  url: string;\n\n  /**\n   * Response version, allowing Inngest to change any top-level field.\n   */\n  v: `${number}.${number}`;\n\n  /**\n   * SDK version from `package.json` for our internal metrics and to warn users\n   * they need to upgrade.\n   */\n  sdk: `js:v${number}.${number}.${number}${\"\" | `-${string}.${number}`}`;\n\n  /**\n   * The method used to deploy these functions.\n   */\n  deployType: \"ping\";\n\n  /**\n   * The name of the framework being used for this instance, e.g. \"nextjs\",\n   * \"vercel\", \"netlify\", \"lambda\", etc. Uses the `framework` specified when\n   * creating a new `InngestCommHandler`.\n   */\n  framework: string;\n\n  /**\n   * The name of this particular app, used for grouping and easier viewing in\n   * the UI.\n   */\n  appName: string;\n\n  /**\n   * AppVersion represents an optional application version identifier. This should change\n   * whenever code within one of your Inngest function or any dependency thereof changes.\n   */\n  appVersion?: string;\n\n  /**\n   * The functions available at this particular handler.\n   */\n  functions: FunctionConfig[];\n\n  /**\n   * The deploy ID used to identify this particular deployment.\n   */\n  deployId?: string;\n\n  /**\n   * Capabilities of the SDK.\n   */\n  capabilities: Capabilities;\n}\n\nexport interface Capabilities {\n  trust_probe: \"v1\";\n  connect: \"v1\";\n}\n\nexport interface InBandRegisterRequest\n  extends Pick<\n      RegisterRequest,\n      \"capabilities\" | \"framework\" | \"functions\" | \"sdk\" | \"url\" | \"appVersion\"\n    >,\n    Pick<AuthenticatedIntrospection, \"sdk_language\" | \"sdk_version\" | \"env\"> {\n  /**\n   * The ID of the app that this handler is associated with.\n   */\n  app_id: string;\n\n  /**\n   * The result of the introspection request.\n   */\n  inspection: AuthenticatedIntrospection | UnauthenticatedIntrospection;\n\n  /**\n   * ?\n   */\n  platform?: string;\n\n  /**\n   * The person or organization that authored this SDK. Ideally this is\n   * synonymous with a GitHub username or organization name.\n   */\n  sdk_author: \"inngest\";\n}\n\n/**\n * The response to send to the local SDK UI when an introspection request is\n * made.\n *\n * @internal\n */\nexport interface UnauthenticatedIntrospection {\n  authentication_succeeded: false | null;\n  extra: {\n    is_mode_explicit: boolean;\n  };\n  function_count: number;\n  has_event_key: boolean;\n  has_signing_key: boolean;\n  mode: \"cloud\" | \"dev\";\n  schema_version: \"2024-05-24\";\n}\n\nexport interface AuthenticatedIntrospection\n  extends Omit<UnauthenticatedIntrospection, \"authentication_succeeded\"> {\n  api_origin: string;\n  app_id: string;\n  authentication_succeeded: true;\n  capabilities: Capabilities;\n  env: string | null;\n  event_api_origin: string;\n  event_key_hash: string | null;\n  extra: UnauthenticatedIntrospection[\"extra\"] & {\n    is_streaming: boolean;\n  };\n  framework: string;\n  sdk_language: string;\n  sdk_version: string;\n  serve_origin: string | null;\n  serve_path: string | null;\n  signing_key_fallback_hash: string | null;\n  signing_key_hash: string | null;\n}\n\n/**\n * The schema used to represent an individual function being synced with\n * Inngest.\n *\n * Note that this should only be used to validate the shape of a config object\n * and not used for feature compatibility, such as feature X being exclusive\n * with feature Y; these should be handled on the Inngest side.\n */\nexport const functionConfigSchema = z.strictObject({\n  name: z.string().optional(),\n  id: z.string(),\n  triggers: z.array(\n    z.union([\n      z.strictObject({\n        event: z.string(),\n        expression: z.string().optional(),\n      }),\n      z.strictObject({\n        cron: z.string(),\n      }),\n    ]),\n  ),\n  steps: z.record(\n    z.strictObject({\n      id: z.string(),\n      name: z.string(),\n      runtime: z.strictObject({\n        type: z.union([z.literal(\"http\"), z.literal(\"ws\")]),\n        url: z.string(),\n      }),\n      retries: z\n        .strictObject({\n          attempts: z.number().optional(),\n        })\n        .optional(),\n    }),\n  ),\n  idempotency: z.string().optional(),\n  batchEvents: z\n    .strictObject({\n      maxSize: z.number(),\n      timeout: z.string(),\n      key: z.string().optional(),\n      if: z.string().optional(),\n    })\n    .optional(),\n  rateLimit: z\n    .strictObject({\n      key: z.string().optional(),\n      limit: z.number(),\n      period: z.string().transform((x) => x as TimeStr),\n    })\n    .optional(),\n  throttle: z\n    .strictObject({\n      key: z.string().optional(),\n      limit: z.number(),\n      period: z.string().transform((x) => x as TimeStr),\n      burst: z.number().optional(),\n    })\n    .optional(),\n  singleton: z\n    .strictObject({\n      key: z.string().optional(),\n      mode: z.enum([\"skip\", \"cancel\"]),\n    })\n    .optional(),\n  cancel: z\n    .array(\n      z.strictObject({\n        event: z.string(),\n        if: z.string().optional(),\n        timeout: z.string().optional(),\n      }),\n    )\n    .optional(),\n  debounce: z\n    .strictObject({\n      key: z.string().optional(),\n      period: z.string().transform((x) => x as TimeStr),\n      timeout: z\n        .string()\n        .transform((x) => x as TimeStr)\n        .optional(),\n    })\n    .optional(),\n  timeouts: z\n    .strictObject({\n      start: z\n        .string()\n        .transform((x) => x as TimeStr)\n        .optional(),\n      finish: z\n        .string()\n        .transform((x) => x as TimeStr)\n        .optional(),\n    })\n    .optional(),\n  priority: z\n    .strictObject({\n      run: z.string().optional(),\n    })\n    .optional(),\n  concurrency: z\n    .union([\n      z.number(),\n      concurrencyOptionSchema.transform((x) => x as ConcurrencyOption),\n      z\n        .array(concurrencyOptionSchema.transform((x) => x as ConcurrencyOption))\n        .min(1)\n        .max(2),\n    ])\n    .optional(),\n});\n\n/**\n * The shape of an individual function being synced with Inngest.\n *\n * @internal\n */\nexport type FunctionConfig = z.output<typeof functionConfigSchema>;\n\nexport interface DevServerInfo {\n  /**\n   * The version of the dev server.\n   */\n  version: string;\n  authed: boolean;\n  startOpts: {\n    dir?: string;\n    autodiscover: boolean;\n    urls: string[];\n  };\n  functions: FunctionConfig[];\n  handlers: RegisterRequest[];\n}\n\n/**\n * Given a set of events and a user-friendly trigger paramter, returns the name\n * of the event that the user intends to listen to.\n *\n * @public\n */\nexport type EventNameFromTrigger<\n  Events extends Record<string, EventPayload>,\n  T extends InngestFunction.Trigger<keyof Events & string>,\n> = IsNever<T> extends true // `never` indicates there are no triggers, so the payload could be anything\n  ? `${internalEvents.FunctionInvoked}`\n  : T extends string // `string` indicates a migration from v2 to v3\n    ? T\n    : T extends { event: infer IEvent } // an event trigger\n      ? IEvent\n      : T extends { cron: string } // a cron trigger\n        ? `${internalEvents.ScheduledTimer}`\n        : never;\n\n/**\n * A union to represent known names of supported frameworks that we can use\n * internally to assess functionality based on a mix of framework and platform.\n */\nexport type SupportedFrameworkName =\n  | \"astro\"\n  | \"bun\"\n  | \"cloudflare-pages\"\n  | \"digitalocean\"\n  | \"edge\"\n  | \"express\"\n  | \"aws-lambda\"\n  | \"nextjs\"\n  | \"nodejs\"\n  | \"nuxt\"\n  | \"h3\"\n  | \"redwoodjs\"\n  | \"remix\"\n  | \"deno/fresh\"\n  | \"sveltekit\"\n  | \"fastify\"\n  | \"koa\"\n  | \"hono\"\n  | \"nitro\";\n\n/**\n * A set of options that can be passed to any step to configure it.\n *\n * @public\n */\nexport interface StepOptions {\n  /**\n   * The ID to use to memoize the result of this step, ensuring it is run only\n   * once. Changing this ID in an existing function will cause the step to be\n   * run again for in-progress runs; it is recommended to use a stable ID.\n   */\n  id: string;\n\n  /**\n   * The display name to use for this step in the Inngest UI. This can be\n   * changed at any time without affecting the step's behaviour.\n   */\n  name?: string;\n}\n\n/**\n * Either a step ID or a set of step options.\n *\n * @public\n */\nexport type StepOptionsOrId = StepOptions[\"id\"] | StepOptions;\n\nexport type EventsFromFunction<T extends InngestFunction.Any> =\n  // biome-ignore lint/suspicious/noExplicitAny: <explanation>\n  T extends InngestFunction<any, any, any, infer IClient, any, any>\n    ? GetEvents<IClient, true>\n    : never;\n\n/**\n * A function that can be invoked by Inngest.\n *\n * @public\n */\nexport type InvokeTargetFunctionDefinition =\n  | Public<InngestFunctionReference.Any>\n  | Public<InngestFunction.Any>\n  | string;\n\n/**\n * Given an invocation target, extract the payload that will be used to trigger\n * it.\n *\n * If we could not find a payload, will return `never`.\n */\nexport type TriggerEventFromFunction<\n  TFunction extends InvokeTargetFunctionDefinition,\n> = TFunction extends InngestFunction.Any\n  ? PayloadForAnyInngestFunction<TFunction>\n  : TFunction extends InngestFunctionReference<\n        infer IInput extends MinimalEventPayload,\n        // biome-ignore lint/suspicious/noExplicitAny: <explanation>\n        any\n      >\n    ? IInput\n    : MinimalEventPayload;\n\n/**\n * Given an {@link InngestFunction} instance, extract the {@link MinimalPayload}\n * that will be used to trigger it.\n *\n * This is intended to see what **input** a developer is expected to give to\n * invoke a function; it should not be used for evaluating the payload received\n * inside an invoked function.\n *\n * If we could not find a payload or the function does not require a payload\n * (e.g. a cron), then will return `{}`, as this is intended to be used to\n * spread into other arguments.\n *\n * @internal\n */\nexport type PayloadForAnyInngestFunction<\n  TFunction extends InngestFunction.Any,\n  TEvents extends Record<\n    string,\n    EventPayload\n  > = TFunction extends InngestFunction.Any\n    ? EventsFromFunction<TFunction>\n    : never,\n> = TFunction extends InngestFunction<\n  // biome-ignore lint/suspicious/noExplicitAny: <explanation>\n  any,\n  // biome-ignore lint/suspicious/noExplicitAny: <explanation>\n  any,\n  // biome-ignore lint/suspicious/noExplicitAny: <explanation>\n  any,\n  // biome-ignore lint/suspicious/noExplicitAny: <explanation>\n  any,\n  // biome-ignore lint/suspicious/noExplicitAny: <explanation>\n  any,\n  infer ITriggers extends InngestFunction.Trigger<keyof TEvents & string>[]\n>\n  ? IsEqual<\n      TEvents[EventNameFromTrigger<TEvents, ITriggers[number]>][\"name\"],\n      `${internalEvents.ScheduledTimer}`\n    > extends true\n    ? object // If this is ONLY a cron trigger, then we don't need to provide a payload\n    : Simplify<\n        Omit<\n          TEvents[EventNameFromTrigger<TEvents, ITriggers[number]>],\n          \"name\" | \"ts\"\n        >\n      >\n  : never;\n\nexport type InvocationResult<TReturn> = Promise<TReturn>;\n// TODO Types ready for when we expand this.\n// & {\n//   result: InvocationResult<TReturn>;\n//   cancel: (reason: string) => Promise<void>; // TODO Need to be a Promise? \n//   queued: Promise<{ runId: string }>;\n// };\n\n/**\n * Simplified version of Rust style `Result`\n *\n * Make it easier to wrap functions with some kind of result.\n * e.g. API calls\n */\nexport type Result<T, E = undefined> =\n  | { ok: true; value: T }\n  | { ok: false; error: E | undefined };\n\nexport const ok = <T>(data: T): Result<T, never> => {\n  return { ok: true, value: data };\n};\n\nexport const err = <E>(error?: E): Result<never, E> => {\n  return { ok: false, error };\n};\n\nexport const inBandSyncRequestBodySchema = z.strictObject({\n  url: z.string(),\n});\n"],"names":["maybeJsonErrorSchema: z.ZodType<{\n  name: string;\n  message: string;\n  stack?: string;\n  cause?: unknown;\n}>"],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 520, "column": 0}, "map": {"version":3,"file":"NonRetriableError.js","sources":["file:///Users/amansatyawani/Desktop/website-builder/node_modules/.pnpm/inngest%403.45.1_%40opentelemetry%2Bcore%402.2.0_%40opentelemetry%2Bapi%401.9.0__express%405.1.0_next%401_e029d374516642dd9a767b32fbb0beec/node_modules/src/components/NonRetriableError.ts"],"sourcesContent":["/**\n * An error that, when thrown, indicates to Inngest that the function should\n * cease all execution and not retry.\n *\n * A `message` must be provided, and an optional `cause` can be provided to\n * provide more context to the error.\n *\n * @public\n */\nexport class NonRetriableError extends Error {\n  /**\n   * The underlying cause of the error, if any.\n   *\n   * This will be serialized and sent to Inngest.\n   */\n  public override readonly cause?: unknown;\n\n  constructor(\n    message: string,\n    options?: {\n      /**\n       * The underlying cause of the error, if any.\n       *\n       * This will be serialized and sent to Inngest.\n       */\n      cause?: unknown;\n    },\n  ) {\n    super(message);\n\n    this.cause = options?.cause;\n\n    this.name = \"NonRetriableError\";\n  }\n}\n"],"names":[],"mappings":";;;;;;;;;;;;AASA,IAAa,oBAAb,cAAuC,MAAM;;;;;IAMlB,MAAA;IAEzB,YACE,OAAA,EACA,OAAA,CAQA;QACA,KAAA,CAAM,QAAQ;QAEd,IAAA,CAAK,KAAA,GAAQ,SAAS;QAEtB,IAAA,CAAK,IAAA,GAAO","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 552, "column": 0}, "map": {"version":3,"file":"errors.js","sources":["file:///Users/amansatyawani/Desktop/website-builder/node_modules/.pnpm/inngest%403.45.1_%40opentelemetry%2Bcore%402.2.0_%40opentelemetry%2Bapi%401.9.0__express%405.1.0_next%401_e029d374516642dd9a767b32fbb0beec/node_modules/src/helpers/errors.ts"],"sourcesContent":["import chalk from \"chalk\";\nimport stringify from \"json-stringify-safe\";\nimport {\n  type SerializedError as CjsSerializedError,\n  deserializeError as cjsDeserializeError,\n  serializeError as cjsSerializeError,\n  errorConstructors,\n} from \"serialize-error-cjs\";\nimport stripAnsi from \"strip-ansi\";\nimport { z } from \"zod/v3\";\nimport type { Inngest } from \"../components/Inngest.ts\";\nimport { NonRetriableError } from \"../components/NonRetriableError.ts\";\nimport type { ClientOptions, OutgoingOp } from \"../types.ts\";\n\nconst SERIALIZED_KEY = \"__serialized\";\nconst SERIALIZED_VALUE = true;\n\n/**\n * Add first-class support for certain errors that we control, in addition to\n * built-in errors such as `TypeError`.\n *\n * Adding these allows these non-standard errors to be correctly serialized,\n * sent to Inngest, then deserialized back into the correct error type for users\n * to react to correctly.\n *\n * Note that these errors only support `message?: string | undefined` as the\n * input; more custom errors are not supported with this current strategy.\n */\nerrorConstructors.set(\n  \"NonRetriableError\",\n  NonRetriableError as ErrorConstructor,\n);\n\nexport interface SerializedError extends Readonly<CjsSerializedError> {\n  readonly [SERIALIZED_KEY]: typeof SERIALIZED_VALUE;\n}\n\n/**\n * Serialise an error to a serialized JSON string.\n *\n * Errors do not serialise nicely to JSON, so we use this function to convert\n * them to a serialized JSON string. Doing this is also non-trivial for some\n * errors, so we use the `serialize-error` package to do it for us.\n *\n * See {@link https://www.npmjs.com/package/serialize-error}\n *\n * This function is a small wrapper around that package to also add a `type`\n * property to the serialised error, so that we can distinguish between\n * serialised errors and other objects.\n *\n * Will not reserialise existing serialised errors.\n */\nexport const serializeError = <\n  TAllowUnknown extends boolean = false,\n  TOutput extends TAllowUnknown extends true\n    ? unknown\n    : SerializedError = TAllowUnknown extends true ? unknown : SerializedError,\n>(\n  /**\n   * The suspected error to serialize.\n   */\n  subject: unknown,\n\n  /**\n   * If `true` and the error is not serializable, will return the original value\n   * as `unknown` instead of coercing it to a serialized error.\n   */\n  allowUnknown: TAllowUnknown = false as TAllowUnknown,\n): TOutput => {\n  try {\n    // Try to understand if this is already done.\n    // Will handle stringified errors.\n    const existingSerializedError = isSerializedError(subject);\n\n    if (existingSerializedError) {\n      return existingSerializedError as TOutput;\n    }\n\n    if (typeof subject === \"object\" && subject !== null) {\n      // Is an object, so let's try and serialize it.\n      const serializedErr = cjsSerializeError(subject as Error);\n\n      // Not a proper error was caught, so give us a chance to return `unknown`.\n      if (!serializedErr.name && allowUnknown) {\n        return subject as TOutput;\n      }\n\n      // Serialization can succeed but assign no name or message, so we'll\n      // map over the result here to ensure we have everything.\n      // We'll just stringify the entire subject for the message, as this at\n      // least provides some context for the user.\n      const ret = {\n        // Ensure we spread to also capture additional properties such as\n        // `cause`.\n        ...serializedErr,\n\n        name: serializedErr.name || \"Error\",\n        message:\n          serializedErr.message ||\n          stringify(subject) ||\n          \"Unknown error; error serialization could not find a message.\",\n        stack: serializedErr.stack || \"\",\n        [SERIALIZED_KEY]: SERIALIZED_VALUE,\n      } as const;\n\n      // If we have a cause, make sure we recursively serialize them too. We are\n      // lighter with causes though; attempt to recursively serialize them, but\n      // stop if we find something that doesn't work and just return `unknown`.\n      let target: unknown = ret;\n      const maxDepth = 5;\n      for (let i = 0; i < maxDepth; i++) {\n        if (\n          typeof target === \"object\" &&\n          target !== null &&\n          \"cause\" in target &&\n          target.cause\n        ) {\n          target = target.cause = serializeError(target.cause, true);\n          continue;\n        }\n\n        break;\n      }\n\n      return ret as TOutput;\n    }\n\n    // If it's not an object, it's hard to parse this as an Error. In this case,\n    // we'll throw an error to start attempting backup strategies.\n    throw new Error(\"Error is not an object; strange throw value.\");\n  } catch {\n    if (allowUnknown) {\n      // If we are allowed to return unknown, we'll just return the original\n      // value.\n      return subject as TOutput;\n    }\n\n    try {\n      // If serialization fails, fall back to a regular Error and use the\n      // original object as the message for an Error. We don't know what this\n      // object looks like, so we can't do anything else with it.\n      return {\n        ...serializeError(\n          new Error(typeof subject === \"string\" ? subject : stringify(subject)),\n          false,\n        ),\n        // Remove the stack; it's not relevant here\n        stack: \"\",\n        [SERIALIZED_KEY]: SERIALIZED_VALUE,\n      } as TOutput;\n    } catch {\n      // If this failed, then stringifying the object also failed, so we'll just\n      // return a completely generic error.\n      // Failing to stringify the object is very unlikely.\n      return {\n        name: \"Could not serialize source error\",\n        message: \"Serializing the source error failed.\",\n        stack: \"\",\n        [SERIALIZED_KEY]: SERIALIZED_VALUE,\n      } as TOutput;\n    }\n  }\n};\n\n/**\n * Check if an object or a string is a serialised error created by\n * {@link serializeError}.\n */\nexport const isSerializedError = (\n  value: unknown,\n): SerializedError | undefined => {\n  try {\n    if (typeof value === \"string\") {\n      const parsed = z\n        .object({\n          [SERIALIZED_KEY]: z.literal(SERIALIZED_VALUE),\n          name: z.enum([...Array.from(errorConstructors.keys())] as [\n            string,\n            ...string[],\n          ]),\n          message: z.string(),\n          stack: z.string(),\n        })\n        .passthrough()\n        .safeParse(JSON.parse(value));\n\n      if (parsed.success) {\n        return parsed.data as SerializedError;\n      }\n    }\n\n    if (typeof value === \"object\" && value !== null) {\n      const objIsSerializedErr =\n        Object.hasOwn(value, SERIALIZED_KEY) &&\n        (value as { [SERIALIZED_KEY]: unknown })[SERIALIZED_KEY] ===\n          SERIALIZED_VALUE;\n\n      if (objIsSerializedErr) {\n        return value as SerializedError;\n      }\n    }\n  } catch {\n    // no-op; we'll return undefined if parsing failed, as it isn't a serialized\n    // error\n  }\n\n  return;\n};\n\n/**\n * Deserialise an error created by {@link serializeError}.\n *\n * Ensures we only deserialise errors that meet a minimum level of\n * applicability, inclusive of error handling to ensure that badly serialized\n * errors are still handled.\n */\nexport const deserializeError = <\n  TAllowUnknown extends boolean = false,\n  TOutput extends TAllowUnknown extends true\n    ? unknown\n    : Error = TAllowUnknown extends true ? unknown : Error,\n>(\n  subject: Partial<SerializedError>,\n  allowUnknown: TAllowUnknown = false as TAllowUnknown,\n): TOutput => {\n  const requiredFields: (keyof SerializedError)[] = [\"name\", \"message\"];\n\n  try {\n    const hasRequiredFields = requiredFields.every((field) => {\n      return Object.hasOwn(subject, field);\n    });\n\n    if (!hasRequiredFields) {\n      throw new Error();\n    }\n\n    const deserializedErr = cjsDeserializeError(subject as SerializedError);\n\n    if (\"cause\" in deserializedErr) {\n      deserializedErr.cause = deserializeError(\n        deserializedErr.cause as Partial<SerializedError>,\n        true,\n      );\n    }\n\n    return deserializedErr as TOutput;\n  } catch {\n    if (allowUnknown) {\n      // If we are allowed to return unknown, we'll just return the original\n      // value.\n      return subject as TOutput;\n    }\n\n    const err = new Error(\"Unknown error; could not reserialize\");\n\n    /**\n     * Remove the stack so that it's not misleadingly shown as the Inngest\n     * internals.\n     */\n    err.stack = undefined;\n\n    return err as TOutput;\n  }\n};\n\nexport enum ErrCode {\n  NESTING_STEPS = \"NESTING_STEPS\",\n\n  /**\n   * Legacy v0 execution error code for when a function has changed and no\n   * longer matches its in-progress state.\n   *\n   * @deprecated Not for use in latest execution method.\n   */\n  NON_DETERMINISTIC_FUNCTION = \"NON_DETERMINISTIC_FUNCTION\",\n\n  /**\n   * Legacy v0 execution error code for when a function is found to be using\n   * async actions after memoziation has occurred, which v0 doesn't support.\n   *\n   * @deprecated Not for use in latest execution method.\n   */\n  ASYNC_DETECTED_AFTER_MEMOIZATION = \"ASYNC_DETECTED_AFTER_MEMOIZATION\",\n\n  /**\n   * Legacy v0 execution error code for when a function is found to be using\n   * steps after a non-step async action has occurred.\n   *\n   * @deprecated Not for use in latest execution method.\n   */\n  STEP_USED_AFTER_ASYNC = \"STEP_USED_AFTER_ASYNC\",\n\n  AUTOMATIC_PARALLEL_INDEXING = \"AUTOMATIC_PARALLEL_INDEXING\",\n}\n\nexport interface PrettyError {\n  /**\n   * The type of message, used to decide on icon and color use.\n   */\n  type?: \"error\" | \"warn\";\n\n  /**\n   * A short, succinct description of what happened. Will be used as the error's\n   * header, so should be short and to the point with no trailing punctuation.\n   */\n  whatHappened: string;\n\n  /**\n   * If applicable, provide a full sentence to reassure the user about certain\n   * details, for example if an error occurred whilst uploading a file, but we\n   * can assure the user that uploading succeeded and something internal failed.\n   */\n  reassurance?: string;\n\n  /**\n   * Tell the user why the error happened if we can. This should be a full\n   * sentence or paragraph that explains the error in more detail, for example\n   * to explain that a file failed to upload because it was too large and that\n   * the maximum size is 10MB.\n   */\n  why?: string;\n\n  /**\n   * If applicable, tell the user what the consequences of the error are, for\n   * example to tell them that their file was not uploaded and that they will\n   * need to try again.\n   */\n  consequences?: string;\n\n  /**\n   * If we can, tell the user what they can do to fix the error now. This should\n   * be a full sentence or paragraph that explains what the user can do to fix\n   * the error, for example to tell them to try uploading a smaller file or\n   * upgrade to a paid plan.\n   */\n  toFixNow?: string | string[];\n\n  /**\n   * If applicable, tell the user what to do if the error persists, they want\n   * more information, or the fix we've given them doesn't work.\n   *\n   * This should be a full sentence or paragraph, and will likely refer users\n   * to contact us for support, join our Discord, or read documentation.\n   */\n  otherwise?: string;\n\n  /**\n   * Add a stack trace to the message so that the user knows what line of code\n   * the error is in relation to.\n   */\n  stack?: true;\n\n  /**\n   * If applicable, provide a code that the user can use to reference the error\n   * when contacting support.\n   */\n  code?: ErrCode;\n}\n\nexport const prettyErrorSplitter =\n  \"=================================================\";\n\n/**\n * Given an unknown `err`, mutate it to minify any pretty errors that it\n * contains.\n */\nexport const minifyPrettyError = <T>(err: T): T => {\n  try {\n    if (!isError(err)) {\n      return err;\n    }\n\n    const isPrettyError = err.message.includes(prettyErrorSplitter);\n    if (!isPrettyError) {\n      return err;\n    }\n\n    const sanitizedMessage = stripAnsi(err.message);\n\n    const message =\n      sanitizedMessage.split(\"  \")[1]?.split(\"\\n\")[0]?.trim() || err.message;\n    const code =\n      sanitizedMessage.split(\"\\n\\nCode: \")[1]?.split(\"\\n\\n\")[0]?.trim() ||\n      undefined;\n\n    err.message = [code, message].filter(Boolean).join(\" - \");\n\n    if (err.stack) {\n      const sanitizedStack = stripAnsi(err.stack);\n      const stackRest = sanitizedStack\n        .split(`${prettyErrorSplitter}\\n`)\n        .slice(2)\n        .join(\"\\n\");\n\n      err.stack = `${err.name}: ${err.message}\\n${stackRest}`;\n    }\n\n    return err;\n  } catch (_noopErr) {\n    return err;\n  }\n};\n\n/**\n * Given an `err`, return a boolean representing whether it is in the shape of\n * an `Error` or not.\n */\nconst isError = (err: unknown): err is Error => {\n  try {\n    if (err instanceof Error) {\n      return true;\n    }\n\n    if (typeof err !== \"object\" || err === null) {\n      return false;\n    }\n\n    const hasName = Object.hasOwn(err, \"name\");\n    const hasMessage = Object.hasOwn(err, \"message\");\n\n    return hasName && hasMessage;\n  } catch (_noopErr) {\n    return false;\n  }\n};\n\n/**\n * Given an `unknown` object, retrieve the `message` property from it, or fall\n * back to the `fallback` string if it doesn't exist or is empty.\n */\nexport const getErrorMessage = (err: unknown, fallback: string): string => {\n  const { message } = z\n    .object({ message: z.string().min(1) })\n    .catch({ message: fallback })\n    .parse(err);\n\n  return message;\n};\n\n/**\n * Given a {@link PrettyError}, return a nicely-formatted string ready to log\n * or throw.\n *\n * Useful for ensuring that errors are logged in a consistent, helpful format\n * across the SDK by prompting for key pieces of information.\n */\nexport const prettyError = ({\n  type = \"error\",\n  whatHappened,\n  otherwise,\n  reassurance,\n  toFixNow,\n  why,\n  consequences,\n  stack,\n  code,\n}: PrettyError): string => {\n  const { icon, colorFn } = (\n    {\n      error: { icon: \"\", colorFn: chalk.red },\n      warn: { icon: \"\", colorFn: chalk.yellow },\n    } satisfies Record<\n      NonNullable<PrettyError[\"type\"]>,\n      { icon: string; colorFn: (s: string) => string }\n    >\n  )[type];\n\n  let header = `${icon}  ${chalk.bold.underline(whatHappened.trim())}`;\n  if (stack) {\n    header +=\n      \"\\n\" +\n      [...(new Error().stack?.split(\"\\n\").slice(1).filter(Boolean) || [])].join(\n        \"\\n\",\n      );\n  }\n\n  let toFixNowStr =\n    (Array.isArray(toFixNow)\n      ? toFixNow\n          .map((s) => s.trim())\n          .filter(Boolean)\n          .map((s, i) => `\\t${i + 1}. ${s}`)\n          .join(\"\\n\")\n      : toFixNow?.trim()) ?? \"\";\n\n  if (Array.isArray(toFixNow) && toFixNowStr) {\n    toFixNowStr = `To fix this, you can take one of the following courses of action:\\n\\n${toFixNowStr}`;\n  }\n\n  let body = [reassurance?.trim(), why?.trim(), consequences?.trim()]\n    .filter(Boolean)\n    .join(\" \");\n  body += body ? `\\n\\n${toFixNowStr}` : toFixNowStr;\n\n  const trailer = [otherwise?.trim()].filter(Boolean).join(\" \");\n\n  const message = [\n    prettyErrorSplitter,\n    header,\n    body,\n    trailer,\n    code ? `Code: ${code}` : \"\",\n    prettyErrorSplitter,\n  ]\n    .filter(Boolean)\n    .join(\"\\n\\n\");\n\n  return colorFn(message);\n};\n\nexport const fixEventKeyMissingSteps = [\n  \"Set the `INNGEST_EVENT_KEY` environment variable\",\n  `Pass a key to the \\`new Inngest()\\` constructor using the \\`${\n    \"eventKey\" satisfies keyof ClientOptions\n  }\\` option`,\n  `Use \\`inngest.${\"setEventKey\" satisfies keyof Inngest.Any}()\\` at runtime`,\n];\n\n/**\n * An error that, when thrown, indicates internally that an outgoing operation\n * contains an error.\n *\n * We use this because serialized `data` sent back to Inngest may differ from\n * the error instance itself due to middleware.\n *\n * @internal\n */\nexport class OutgoingResultError extends Error {\n  public readonly result: Pick<OutgoingOp, \"data\" | \"error\">;\n\n  constructor(result: Pick<OutgoingOp, \"data\" | \"error\">) {\n    super(\"OutgoingOpError\");\n    this.result = result;\n  }\n}\n\n/**\n * Create a function that will rethrow an error with a prefix added to the\n * message.\n *\n * Useful for adding context to errors that are rethrown.\n *\n * @example\n * ```ts\n * await doSomeAction().catch(rethrowError(\"Failed to do some action\"));\n * ```\n */\n// biome-ignore lint/suspicious/noExplicitAny: <explanation>\nexport const rethrowError = (prefix: string): ((err: any) => never) => {\n  return (err) => {\n    try {\n      err.message &&= `${prefix}; ${err.message}`;\n    } catch (_noopErr) {\n      // no-op\n    } finally {\n      // biome-ignore lint/correctness/noUnsafeFinally: <explanation>\n      throw err;\n    }\n  };\n};\n\n/**\n * Legacy v0 execution error for functions that don't support mixing steps and\n * regular async actions.\n */\nexport const functionStoppedRunningErr = (code: ErrCode) => {\n  return prettyError({\n    whatHappened: \"Your function was stopped from running\",\n    why: \"We detected a mix of asynchronous logic, some using step tooling and some not.\",\n    consequences:\n      \"This can cause unexpected behaviour when a function is paused and resumed and is therefore strongly discouraged; we stopped your function to ensure nothing unexpected happened!\",\n    stack: true,\n    toFixNow:\n      \"Ensure that your function is either entirely step-based or entirely non-step-based, by either wrapping all asynchronous logic in `step.run()` calls or by removing all `step.*()` calls.\",\n    otherwise:\n      \"For more information on why step functions work in this manner, see https://www.inngest.com/docs/functions/multi-step#gotchas\",\n    code,\n  });\n};\n"],"names":["serializeError","cjsSerializeError","target: unknown","deserializeError","requiredFields: (keyof SerializedError)[]","cjsDeserializeError"],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 884, "column": 0}, "map": {"version":3,"file":"schema.js","sources":["file:///Users/amansatyawani/Desktop/website-builder/node_modules/.pnpm/inngest%403.45.1_%40opentelemetry%2Bcore%402.2.0_%40opentelemetry%2Bapi%401.9.0__express%405.1.0_next%401_e029d374516642dd9a767b32fbb0beec/node_modules/src/api/schema.ts"],"sourcesContent":["import { z } from \"zod/v3\";\nimport { ExecutionVersion } from \"../helpers/consts.ts\";\nimport { type EventPayload, jsonErrorSchema } from \"../types.ts\";\n\nexport const errorSchema = z.object({\n  error: z.string(),\n  status: z.number(),\n});\nexport type ErrorResponse = z.infer<typeof errorSchema>;\n\nconst v0StepSchema = z\n  .record(\n    z.any().refine((v) => typeof v !== \"undefined\", {\n      message: \"Values in steps must be defined\",\n    }),\n  )\n  .optional()\n  .nullable();\n\nconst v1StepSchema = z\n  .record(\n    z\n      .object({\n        type: z.literal(\"data\").optional().default(\"data\"),\n        data: z.any().refine((v) => typeof v !== \"undefined\", {\n          message: \"Data in steps must be defined\",\n        }),\n      })\n      .strict()\n      .or(\n        z\n          .object({\n            type: z.literal(\"error\").optional().default(\"error\"),\n            error: jsonErrorSchema,\n          })\n          .strict(),\n      )\n      .or(\n        z\n          .object({\n            type: z.literal(\"input\").optional().default(\"input\"),\n            input: z.any().refine((v) => typeof v !== \"undefined\", {\n              message: \"If input is present it must not be `undefined`\",\n            }),\n          })\n          .strict(),\n      )\n\n      /**\n       * If the result isn't a distcint `data` or `error` object, then it's\n       * likely that the executor has set this directly to a value, for example\n       * in the case of `sleep` or `waitForEvent`.\n       *\n       * In this case, pull the entire value through as data.\n       */\n\n      .or(z.any().transform((v) => ({ type: \"data\" as const, data: v }))),\n  )\n  .default({});\n\nconst v2StepSchema = v1StepSchema;\n\nexport const stepsSchemas = {\n  [ExecutionVersion.V0]: v0StepSchema,\n  [ExecutionVersion.V1]: v1StepSchema,\n  [ExecutionVersion.V2]: v2StepSchema,\n} satisfies Record<ExecutionVersion, z.ZodSchema>;\n\nexport type StepsResponse = {\n  [V in ExecutionVersion]: z.infer<(typeof stepsSchemas)[V]>;\n}[ExecutionVersion];\n\nexport const batchSchema = z.array(\n  z.record(z.any()).transform((v) => v as EventPayload),\n);\nexport type BatchResponse = z.infer<typeof batchSchema>;\n"],"names":[],"mappings":";;;;;;;;;;;;AAIA,MAAa,qOAAc,IAAA,CAAE,MAAA,CAAO;IAClC,8NAAO,IAAA,CAAE,MAAA,EAAQ;IACjB,+NAAQ,IAAA,CAAE,MAAA,EAAQ;CACnB,CAAC;AAGF,MAAM,sOAAe,IAAA,CAClB,MAAA,wNACC,IAAA,CAAE,GAAA,EAAK,CAAC,MAAA,CAAA,CAAQ,IAAM,OAAO,MAAM,aAAa;IAC9C,SAAS;AAAA,CACV,CAAC,CACH,CACA,QAAA,EAAU,CACV,QAAA,EAAU;AAEb,MAAM,sOAAe,IAAA,CAClB,MAAA,wNACC,IAAA,CACG,MAAA,CAAO;IACN,6NAAM,IAAA,CAAE,OAAA,CAAQ,OAAO,CAAC,QAAA,EAAU,CAAC,OAAA,CAAQ,OAAO;IAClD,6NAAM,IAAA,CAAE,GAAA,EAAK,CAAC,MAAA,CAAA,CAAQ,IAAM,OAAO,MAAM,aAAa;QACpD,SAAS;IAAA,CACV,CAAC;CACH,CAAC,CACD,MAAA,EAAQ,CACR,EAAA,wNACC,IAAA,CACG,MAAA,CAAO;IACN,6NAAM,IAAA,CAAE,OAAA,CAAQ,QAAQ,CAAC,QAAA,EAAU,CAAC,OAAA,CAAQ,QAAQ;IACpD,sVAAO,kBAAA;CACR,CAAC,CACD,MAAA,EAAQ,CACZ,CACA,EAAA,wNACC,IAAA,CACG,MAAA,CAAO;IACN,6NAAM,IAAA,CAAE,OAAA,CAAQ,QAAQ,CAAC,QAAA,EAAU,CAAC,OAAA,CAAQ,QAAQ;IACpD,8NAAO,IAAA,CAAE,GAAA,EAAK,CAAC,MAAA,CAAA,CAAQ,IAAM,OAAO,MAAM,aAAa;QACrD,SAAS;IAAA,CACV,CAAC;CACH,CAAC,CACD,MAAA,EAAQ,CACZ,CAUA,EAAA,wNAAG,IAAA,CAAE,GAAA,EAAK,CAAC,SAAA,CAAA,CAAW,IAAA,CAAO;QAAE,MAAM;QAAiB,MAAM;KAAG,EAAE,CAAC,CACtE,CACA,OAAA,CAAQ,CAAA,CAAE,CAAC;AAEd,MAAM,eAAe;AAErB,MAAa,eAAe;gWACzB,mBAAA,CAAiB,EAAA,CAAA,EAAK;gWACtB,mBAAA,CAAiB,EAAA,CAAA,EAAK;gWACtB,mBAAA,CAAiB,EAAA,CAAA,EAAK;CACxB;AAMD,MAAa,qOAAc,IAAA,CAAE,KAAA,wNAC3B,IAAA,CAAE,MAAA,wNAAO,IAAA,CAAE,GAAA,EAAK,CAAC,CAAC,SAAA,CAAA,CAAW,IAAM,EAAkB,CACtD","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 935, "column": 0}, "map": {"version":3,"file":"InngestExecution.js","sources":["file:///Users/amansatyawani/Desktop/website-builder/node_modules/.pnpm/inngest%403.45.1_%40opentelemetry%2Bcore%402.2.0_%40opentelemetry%2Bapi%401.9.0__express%405.1.0_next%401_e029d374516642dd9a767b32fbb0beec/node_modules/src/components/execution/InngestExecution.ts"],"sourcesContent":["import Debug, { type Debugger } from \"debug\";\nimport { debugPrefix, ExecutionVersion } from \"../../helpers/consts.ts\";\nimport type { ServerTiming } from \"../../helpers/ServerTiming.ts\";\nimport type { MaybePromise, Simplify } from \"../../helpers/types.ts\";\nimport type { Context, IncomingOp, OutgoingOp, StepMode } from \"../../types.ts\";\nimport type { Inngest } from \"../Inngest.ts\";\nimport type { ActionResponse } from \"../InngestCommHandler.ts\";\nimport type { InngestFunction } from \"../InngestFunction.ts\";\n\n// Re-export ExecutionVersion so it's correctly recognized as an enum and not\n// just a type. This can be lost when bundling if we don't re-export it here.\n// See `pnpm run test:dist`.\nexport { ExecutionVersion };\n\n/**\n * The possible results of an execution.\n */\nexport interface ExecutionResults {\n  \"function-resolved\": { data: unknown };\n  \"step-ran\": { step: OutgoingOp; retriable?: boolean | string };\n  \"function-rejected\": { error: unknown; retriable: boolean | string };\n  \"steps-found\": { steps: [OutgoingOp, ...OutgoingOp[]] };\n  \"step-not-found\": { step: OutgoingOp };\n\n  /**\n   * Indicates that we need to relinquish control back to Inngest in order to\n   * change step modes.\n   */\n  \"change-mode\": {\n    to: StepMode;\n    token: string;\n  };\n}\n\nexport type ExecutionResult = {\n  [K in keyof ExecutionResults]: Simplify<\n    {\n      type: K;\n      ctx: Context.Any;\n      ops: Record<string, MemoizedOp>;\n    } & ExecutionResults[K]\n  >;\n}[keyof ExecutionResults];\n\nexport type ExecutionResultHandler<T = ActionResponse> = (\n  result: ExecutionResult,\n) => MaybePromise<T>;\n\nexport type ExecutionResultHandlers<T = ActionResponse> = {\n  [E in ExecutionResult as E[\"type\"]]: (result: E) => MaybePromise<T>;\n};\n\nexport interface MemoizedOp extends IncomingOp {\n  /**\n   * If the step has been hit during this run, these will be the arguments\n   * passed to it.\n   */\n  rawArgs?: unknown[];\n  fulfilled?: boolean;\n\n  /**\n   * The promise that has been returned to userland code.\n   */\n  promise?: Promise<unknown>;\n  seen?: boolean;\n}\n\n/**\n * The preferred execution version that will be used by the SDK when handling\n * brand new runs where the Executor is allowing us to choose.\n *\n * Changing this should not ever be a breaking change, as this will only change\n * new runs, not existing ones.\n */\nexport const PREFERRED_EXECUTION_VERSION =\n  ExecutionVersion.V1 satisfies ExecutionVersion;\n\n/**\n * Options for creating a new {@link InngestExecution} instance.\n */\nexport interface InngestExecutionOptions {\n  client: Inngest.Any;\n  fn: InngestFunction.Any;\n  reqArgs: unknown[];\n  runId: string;\n  data: Omit<Context.Any, \"step\">;\n  stepState: Record<string, MemoizedOp>;\n  stepCompletionOrder: string[];\n  stepMode: StepMode;\n\n  /**\n   * Headers to be sent with any request to Inngest during this execution.\n   */\n  headers: Record<string, string>;\n  requestedRunStep?: string;\n  timer?: ServerTiming;\n  isFailureHandler?: boolean;\n  disableImmediateExecution?: boolean;\n\n  /**\n   * Provide the ability to transform the context passed to the function before\n   * the execution starts.\n   */\n  transformCtx?: (ctx: Readonly<Context.Any>) => Context.Any;\n\n  /**\n   * A hook that is called to create an {@link ActionResponse} from the returned\n   * value of an execution.\n   *\n   * This is required for checkpointing executions.\n   */\n  createResponse?: (data: unknown) => MaybePromise<ActionResponse>;\n}\n\nexport type InngestExecutionFactory = (\n  options: InngestExecutionOptions,\n) => IInngestExecution;\n\nexport class InngestExecution {\n  protected debug: Debugger;\n\n  constructor(protected options: InngestExecutionOptions) {\n    this.debug = Debug(`${debugPrefix}:${this.options.runId}`);\n  }\n}\n\nexport interface IInngestExecution {\n  version: ExecutionVersion;\n  start(): Promise<ExecutionResult>;\n}\n"],"names":["options: InngestExecutionOptions","Debug"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;GA0EA,MAAa,yXACX,mBAAA,CAAiB,EAAA;AA2CnB,IAAa,mBAAb,MAA8B;IAClB,MAAA;IAEV,YAAsBA,OAAAA,CAAkC;QAAlC,IAAA,CAAA,OAAA,GAAA;QACpB,IAAA,CAAK,KAAA,iMAAQC,UAAAA,EAAM,8VAAG,cAAA,CAAY,CAAA,EAAG,IAAA,CAAK,OAAA,CAAQ,KAAA,EAAA,CAAQ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 974, "column": 0}, "map": {"version":3,"file":"functions.js","sources":["file:///Users/amansatyawani/Desktop/website-builder/node_modules/.pnpm/inngest%403.45.1_%40opentelemetry%2Bcore%402.2.0_%40opentelemetry%2Bapi%401.9.0__express%405.1.0_next%401_e029d374516642dd9a767b32fbb0beec/node_modules/src/helpers/functions.ts"],"sourcesContent":["import { ZodError, z } from \"zod/v3\";\nimport type { InngestApi } from \"../api/api.ts\";\nimport { stepsSchemas } from \"../api/schema.ts\";\nimport { PREFERRED_EXECUTION_VERSION } from \"../components/execution/InngestExecution.ts\";\nimport { err, ok, type Result } from \"../types.ts\";\nimport { ExecutionVersion } from \"./consts.ts\";\nimport { prettyError } from \"./errors.ts\";\nimport type { Await } from \"./types.ts\";\n\n/**\n * Wraps a function with a cache. When the returned function is run, it will\n * cache the result and return it on subsequent calls.\n */\n// biome-ignore lint/suspicious/noExplicitAny: <explanation>\nexport const cacheFn = <T extends (...args: any[]) => any>(fn: T): T => {\n  const key = \"value\";\n  const cache = new Map<typeof key, unknown>();\n\n  return ((...args) => {\n    if (!cache.has(key)) {\n      cache.set(key, fn(...args));\n    }\n\n    return cache.get(key);\n  }) as T;\n};\n\n/**\n * Given an array of functions, return a new function that will run each\n * function in series and return the result of the final function. Regardless of\n * if the functions are synchronous or asynchronous, they'll be made into an\n * async promise chain.\n *\n * If an error is thrown, the waterfall will stop and return the error.\n *\n * Because this needs to support both sync and async functions, it only allows\n * functions that accept a single argument.\n */\n// biome-ignore lint/suspicious/noExplicitAny: <explanation>\nexport const waterfall = <TFns extends ((arg?: any) => any)[]>(\n  fns: TFns,\n\n  /**\n   * A function that transforms the result of each function in the waterfall,\n   * ready for the next function.\n   *\n   * Will not be called on the final function.\n   */\n  // biome-ignore lint/suspicious/noExplicitAny: <explanation>\n  transform?: (prev: any, output: any) => any,\n): ((...args: Parameters<TFns[number]>) => Promise<Await<TFns[number]>>) => {\n  return (...args) => {\n    const chain = fns.reduce(async (acc, fn) => {\n      const prev = await acc;\n      const output = (await fn(prev)) as Promise<Await<TFns[number]>>;\n\n      if (transform) {\n        return await transform(prev, output);\n      }\n\n      if (typeof output === \"undefined\") {\n        return prev;\n      }\n\n      return output;\n    }, Promise.resolve(args[0]));\n\n    return chain;\n  };\n};\n\n/**\n * Given a value `v`, return `v` if it's not undefined, otherwise return `null`.\n */\nexport const undefinedToNull = (v: unknown) => {\n  const isUndefined = typeof v === \"undefined\";\n  return isUndefined ? null : v;\n};\n\nconst fnDataVersionSchema = z.object({\n  version: z\n    .literal(-1)\n    .or(z.literal(0))\n    .or(z.literal(1))\n    .or(z.literal(2))\n    .optional()\n    .transform<ExecutionVersion>((v) => {\n      if (typeof v === \"undefined\") {\n        console.debug(\n          `No request version specified by executor; defaulting to v${PREFERRED_EXECUTION_VERSION}`,\n        );\n\n        return PREFERRED_EXECUTION_VERSION;\n      }\n\n      return v === -1 ? PREFERRED_EXECUTION_VERSION : v;\n    }),\n});\n\nexport const parseFnData = (data: unknown) => {\n  let version: ExecutionVersion;\n\n  try {\n    ({ version } = fnDataVersionSchema.parse(data));\n\n    const versionHandlers = {\n      [ExecutionVersion.V0]: () =>\n        ({\n          version: ExecutionVersion.V0,\n          ...z\n            .object({\n              event: z.record(z.any()),\n              events: z.array(z.record(z.any())).default([]),\n              steps: stepsSchemas[ExecutionVersion.V0],\n              ctx: z\n                .object({\n                  run_id: z.string(),\n                  attempt: z.number().default(0),\n                  stack: z\n                    .object({\n                      stack: z\n                        .array(z.string())\n                        .nullable()\n                        .transform((v) => (Array.isArray(v) ? v : [])),\n                      current: z.number(),\n                    })\n                    .passthrough()\n                    .optional()\n                    .nullable(),\n                })\n                .optional()\n                .nullable(),\n              use_api: z.boolean().default(false),\n            })\n            .parse(data),\n        }) as const,\n\n      [ExecutionVersion.V1]: () =>\n        ({\n          version: ExecutionVersion.V1,\n          ...z\n            .object({\n              event: z.record(z.any()),\n              events: z.array(z.record(z.any())).default([]),\n              steps: stepsSchemas[ExecutionVersion.V1],\n              ctx: z\n                .object({\n                  run_id: z.string(),\n                  attempt: z.number().default(0),\n                  max_attempts: z.number().optional(),\n                  disable_immediate_execution: z.boolean().default(false),\n                  use_api: z.boolean().default(false),\n                  stack: z\n                    .object({\n                      stack: z\n                        .array(z.string())\n                        .nullable()\n                        .transform((v) => (Array.isArray(v) ? v : [])),\n                      current: z.number(),\n                    })\n                    .passthrough()\n                    .optional()\n                    .nullable(),\n                })\n                .optional()\n                .nullable(),\n            })\n            .parse(data),\n        }) as const,\n\n      [ExecutionVersion.V2]: () =>\n        ({\n          version: ExecutionVersion.V2,\n          ...z\n            .object({\n              event: z.record(z.any()),\n              events: z.array(z.record(z.any())).default([]),\n              steps: stepsSchemas[ExecutionVersion.V2],\n              ctx: z\n                .object({\n                  run_id: z.string(),\n                  attempt: z.number().default(0),\n                  max_attempts: z.number().optional(),\n                  disable_immediate_execution: z.boolean().default(false),\n                  use_api: z.boolean().default(false),\n                  stack: z\n                    .object({\n                      stack: z\n                        .array(z.string())\n                        .nullable()\n                        .transform((v) => (Array.isArray(v) ? v : [])),\n                      current: z.number(),\n                    })\n                    .passthrough()\n                    .optional()\n                    .nullable(),\n                })\n                .optional()\n                .nullable(),\n            })\n            .parse(data),\n        }) as const,\n    } satisfies Record<ExecutionVersion, () => unknown>;\n\n    return versionHandlers[version]();\n  } catch (err) {\n    throw new Error(parseFailureErr(err));\n  }\n};\nexport type FnData = ReturnType<typeof parseFnData>;\n\ntype ParseErr = string;\nexport const fetchAllFnData = async ({\n  data,\n  api,\n  version,\n}: {\n  data: FnData;\n  api: InngestApi;\n  version: ExecutionVersion;\n}): Promise<Result<FnData, ParseErr>> => {\n  const result = { ...data };\n\n  try {\n    if (\n      (result.version === ExecutionVersion.V0 && result.use_api) ||\n      (result.version === ExecutionVersion.V1 && result.ctx?.use_api)\n    ) {\n      if (!result.ctx?.run_id) {\n        return err(\n          prettyError({\n            whatHappened: \"failed to attempt retrieving data from API\",\n            consequences: \"function execution can't continue\",\n            why: \"run_id is missing from context\",\n            stack: true,\n          }),\n        );\n      }\n\n      const [evtResp, stepResp] = await Promise.all([\n        api.getRunBatch(result.ctx.run_id),\n        api.getRunSteps(result.ctx.run_id, version),\n      ]);\n\n      if (evtResp.ok) {\n        result.events = evtResp.value;\n      } else {\n        return err(\n          prettyError({\n            whatHappened: \"failed to retrieve list of events\",\n            consequences: \"function execution can't continue\",\n            why: evtResp.error?.error,\n            stack: true,\n          }),\n        );\n      }\n\n      if (stepResp.ok) {\n        result.steps = stepResp.value;\n      } else {\n        return err(\n          prettyError({\n            whatHappened: \"failed to retrieve steps for function run\",\n            consequences: \"function execution can't continue\",\n            why: stepResp.error?.error,\n            stack: true,\n          }),\n        );\n      }\n    }\n\n    // If we don't have a stack here, we need to at least set something.\n    // TODO We should be passed this by the steps API.\n    const stepIds = Object.keys(result.steps || {});\n    if (stepIds.length && !result.ctx?.stack?.length) {\n      result.ctx = {\n        ...(result.ctx as NonNullable<typeof result.ctx>),\n        stack: {\n          stack: stepIds,\n          current: stepIds.length - 1,\n        },\n      };\n    }\n\n    return ok(result);\n  } catch (error) {\n    // print it out for now.\n    // move to something like protobuf so we don't have to deal with this\n    console.error(error);\n\n    return err(parseFailureErr(error));\n  }\n};\n\nconst parseFailureErr = (err: unknown) => {\n  let why: string | undefined;\n  if (err instanceof ZodError) {\n    why = err.toString();\n  }\n\n  return prettyError({\n    whatHappened: \"Failed to parse data from executor.\",\n    consequences: \"Function execution can't continue.\",\n    toFixNow:\n      \"Make sure that your API is set up to parse incoming request bodies as JSON, like body-parser for Express (https://expressjs.com/en/resources/middleware/body-parser.html).\",\n    stack: true,\n    why,\n  });\n};\n"],"names":["version: ExecutionVersion","err","why: string | undefined"],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1170, "column": 0}, "map": {"version":3,"file":"InngestMiddleware.js","sources":["file:///Users/amansatyawani/Desktop/website-builder/node_modules/.pnpm/inngest%403.45.1_%40opentelemetry%2Bcore%402.2.0_%40opentelemetry%2Bapi%401.9.0__express%405.1.0_next%401_e029d374516642dd9a767b32fbb0beec/node_modules/src/components/InngestMiddleware.ts"],"sourcesContent":["import { cacheFn, waterfall } from \"../helpers/functions.ts\";\nimport type {\n  Await,\n  MaybePromise,\n  ObjectAssign,\n  PartialK,\n  Simplify,\n} from \"../helpers/types.ts\";\nimport type {\n  BaseContext,\n  EventPayload,\n  IncomingOp,\n  OutgoingOp,\n  SendEventBaseOutput,\n  TriggersFromClient,\n} from \"../types.ts\";\nimport type { Inngest } from \"./Inngest.ts\";\nimport type { InngestFunction } from \"./InngestFunction.ts\";\n\n/**\n * A middleware that can be registered with Inngest to hook into various\n * lifecycles of the SDK and affect input and output of Inngest functionality.\n *\n * See {@link https://innge.st/middleware}\n *\n * @example\n *\n * ```ts\n * export const inngest = new Inngest({\n *   middleware: [\n *     new InngestMiddleware({\n *       name: \"My Middleware\",\n *       init: () => {\n *         // ...\n *       }\n *     })\n *   ]\n * });\n * ```\n *\n * @public\n */\nexport class InngestMiddleware<TOpts extends MiddlewareOptions>\n  implements InngestMiddleware.Like\n{\n  get [Symbol.toStringTag](): typeof InngestMiddleware.Tag {\n    return InngestMiddleware.Tag;\n  }\n\n  /**\n   * The name of this middleware. Used primarily for debugging and logging\n   * purposes.\n   */\n  public readonly name: TOpts[\"name\"];\n\n  /**\n   * This function is used to initialize your middleware and register any hooks\n   * you want to use. It will be called once when the SDK is initialized, and\n   * should be used to store any state you want to use in other parts of your\n   * middleware.\n   *\n   * It can be synchronous or asynchronous, in which case the client will wait\n   * for it to resolve before continuing to initialize the next middleware.\n   *\n   * Multiple clients could be used in the same application with differing\n   * middleware, so do not store state in global variables or assume that your\n   * middleware will only be used once.\n   *\n   * Must return an object detailing the hooks you want to register.\n   */\n  public readonly init: TOpts[\"init\"];\n\n  constructor({ name, init }: TOpts) {\n    this.name = name;\n    this.init = init;\n  }\n}\n\nexport namespace InngestMiddleware {\n  export const Tag = \"Inngest.Middleware\" as const;\n\n  export type Any = InngestMiddleware<MiddlewareOptions>;\n  export interface Like {\n    readonly [Symbol.toStringTag]: typeof InngestMiddleware.Tag;\n  }\n  export type Stack = [InngestMiddleware.Like, ...InngestMiddleware.Like[]];\n}\n\ntype FnsWithSameInputAsOutput<\n  // biome-ignore lint/suspicious/noExplicitAny: <explanation>\n  TRecord extends Record<string, (arg: any) => any>,\n> = {\n  [K in keyof TRecord as Await<TRecord[K]> extends Parameters<TRecord[K]>[0]\n    ? K\n    : // biome-ignore lint/suspicious/noConfusingVoidType: <explanation>\n      Await<TRecord[K]> extends undefined | void\n      ? // biome-ignore lint/suspicious/noConfusingVoidType: <explanation>\n        Parameters<TRecord[K]>[0] extends undefined | void\n        ? K\n        : never\n      : never]: TRecord[K];\n};\n\ntype PromisifiedFunctionRecord<\n  // biome-ignore lint/suspicious/noExplicitAny: <explanation>\n  TRecord extends Record<string, (arg: any) => any>,\n> = Pick<\n  Partial<{\n    [K in keyof TRecord]: (\n      ...args: Parameters<TRecord[K]>\n    ) => Promise<Await<TRecord[K]>>;\n  }>,\n  keyof FnsWithSameInputAsOutput<TRecord>\n> &\n  Omit<\n    Partial<{\n      [K in keyof TRecord]: (\n        ...args: Parameters<TRecord[K]>\n      ) => Promise<Parameters<TRecord[K]>[0]>;\n    }>,\n    keyof FnsWithSameInputAsOutput<TRecord>\n  >;\n\nexport type RunHookStack = PromisifiedFunctionRecord<\n  Await<MiddlewareRegisterReturn[\"onFunctionRun\"]>\n>;\n\nexport type SendEventHookStack = PromisifiedFunctionRecord<\n  Await<MiddlewareRegisterReturn[\"onSendEvent\"]>\n>;\n\n/**\n * Given some middleware and an entrypoint, runs the initializer for the given\n * `key` and returns functions that will pass arguments through a stack of each\n * given hook in a middleware's lifecycle.\n *\n * Lets the middleware initialize before starting.\n */\nexport const getHookStack = async <\n  // biome-ignore lint/suspicious/noExplicitAny: <explanation>\n  TMiddleware extends Record<string, (arg: any) => any>,\n  TKey extends keyof TMiddleware,\n  TResult extends Await<TMiddleware[TKey]>,\n  TRet extends\n    PromisifiedFunctionRecord<TResult> = PromisifiedFunctionRecord<TResult>,\n>(\n  /**\n   * The stack of middleware that will be used to run hooks.\n   */\n  middleware: Promise<TMiddleware[]>,\n\n  /**\n   * The hook type to initialize.\n   */\n  key: TKey,\n\n  /**\n   * Arguments for the initial hook.\n   */\n  arg: Parameters<TMiddleware[TKey]>[0],\n\n  transforms: PartialK<\n    {\n      [K in keyof TResult]-?: (\n        prev: Parameters<TResult[K]>[0],\n        output: Await<TResult[K]>,\n      ) => Parameters<TResult[K]>[0];\n    },\n    keyof {\n      [K in keyof TResult as Await<TResult[K]> extends Parameters<TResult[K]>[0]\n        ? K\n        : // biome-ignore lint/suspicious/noConfusingVoidType: <explanation>\n          Await<TResult[K]> extends undefined | void\n          ? K\n          : never]: undefined;\n    }\n  >,\n): Promise<TRet> => {\n  // Get directions of hooks before we start running the middleware.\n  const hookDirs = hookDirections[key as keyof typeof hookDirections];\n  if (!hookDirs) {\n    throw new Error(\n      `No hook directions found for key \"${String(key)}\". This is likely a bug in the Inngest SDK.`,\n    );\n  }\n\n  // Wait for middleware to initialize\n  const mwStack = await middleware;\n\n  // Step through each middleware and get the hook for the given key\n  const keyFns = mwStack.reduce(\n    (acc, mw) => {\n      const fn = mw[key];\n\n      if (fn) {\n        return [...acc, fn];\n      }\n\n      return acc;\n    },\n    [] as NonNullable<TMiddleware[TKey]>[],\n  );\n\n  // Run each hook found in sequence and collect the results\n  const hooksRegistered = await keyFns.reduce<\n    Promise<Await<TMiddleware[TKey]>[]>\n  >(async (acc, fn) => {\n    return [...(await acc), await fn(arg)];\n  }, Promise.resolve([]));\n\n  // Prepare the return object - mutating this instead of using reduce as it\n  // results in cleaner code.\n  const ret = {} as TRet;\n\n  // Step through each hook result and create a waterfall joining each key\n  for (const hook of hooksRegistered) {\n    const hookKeys = Object.keys(hook) as (keyof TRet)[];\n\n    for (const key of hookKeys) {\n      let fns = [hook[key]];\n\n      const existingWaterfall = ret[key];\n      if (existingWaterfall) {\n        if (hookDirs[key as keyof typeof hookDirs] === \"forward\") {\n          fns = [existingWaterfall, hook[key]];\n        } else {\n          // For backward hooks, put the new hook before the existing waterfall\n          // This creates the proper onion pattern: [foo, bar] -> [bar, foo] for after* hooks\n          fns = [hook[key], existingWaterfall];\n        }\n      }\n\n      const transform = transforms[key as keyof typeof transforms] as (\n        arg: Await<(typeof fns)[number]>,\n      ) => Parameters<(typeof fns)[number]>;\n\n      ret[key] = waterfall(fns, transform) as TRet[keyof TRet];\n    }\n  }\n\n  // Cache each function in the stack to ensure each can only be called once\n  for (const k of Object.keys(ret)) {\n    const key = k as keyof typeof ret;\n\n    ret[key] = cacheFn(\n      ret[key] as (...args: unknown[]) => unknown,\n    ) as unknown as TRet[keyof TRet];\n  }\n\n  return ret;\n};\n\n/**\n * Options passed to new {@link InngestMiddleware} instance.\n *\n * @public\n */\nexport interface MiddlewareOptions {\n  /**\n   * The name of this middleware. Used primarily for debugging and logging\n   * purposes.\n   */\n  name: string;\n\n  /**\n   * This function is used to initialize your middleware and register any hooks\n   * you want to use. It will be called once when the SDK is initialized, and\n   * should be used to store any state you want to use in other parts of your\n   * middleware.\n   *\n   * It can be synchronous or asynchronous, in which case the client will wait\n   * for it to resolve before continuing to initialize the next middleware.\n   *\n   * Multiple clients could be used in the same application with differing\n   * middleware, so do not store state in global variables or assume that your\n   * middleware will only be used once.\n   *\n   * Must return an object detailing the hooks you want to register.\n   */\n  init: MiddlewareRegisterFn;\n}\n\n/**\n * @public\n */\nexport type MiddlewareRegisterReturn = {\n  /**\n   * This hook is called for every function execution and allows you to hook\n   * into various stages of a run's lifecycle. Use this to store any state you\n   * want to use for the entirety of a particular run.\n   *\n   * It can be synchronous or asynchronous, in which case the client will wait\n   * for it to resolve before continuing to initialize the next middleware.\n   *\n   * Must return an object detailing the hooks you want to register.\n   */\n  onFunctionRun?: (ctx: InitialRunInfo) => MaybePromise<{\n    /**\n     * The `input` hook is called once the input for the function has been\n     * properly set up. This is where you can modify the input before the\n     * function starts to memoize or execute by returning an object containing\n     * changes to the context.\n     *\n     * For example, to add `foo` to the context, you'd return\n     * `{ ctx: { foo: \"bar\" } }`.\n     *\n     * @param ctx - The context for the incoming request.\n     * @param steps - The step data in state. Does not include internal IDs.\n     */\n    transformInput?: MiddlewareRunInput;\n\n    /**\n     * The `beforeMemoization` hook is called before the function starts to\n     * memoize.\n     */\n    beforeMemoization?: BlankHook;\n\n    /**\n     * The `afterMemoization` hook is called after the function has finished\n     * memoizing.\n     */\n    afterMemoization?: BlankHook;\n\n    /**\n     * The `beforeExecution` hook is called before the function starts to\n     * execute. Execution here means that new code is being seen/run for the\n     * first time.\n     */\n    beforeExecution?: BlankHook;\n\n    /**\n     * The `afterExecution` hook is called after the function has finished\n     * executing.\n     */\n    afterExecution?: BlankHook;\n\n    /**\n     * The `output` hook is called after the function has finished executing\n     * and before the response is sent back to Inngest. This is where you\n     * can modify the output before it's sent back to Inngest by returning\n     * an object containing changes.\n     *\n     * @param err - The raw error that was thrown by the function, if any, so\n     * that you can capture exact error messages and stack traces.\n     *\n     * @param data - The prepared-but-unserialized data that was returned by\n     * the function, if any, so that you can modify the output.\n     */\n    transformOutput?: MiddlewareRunOutput;\n\n    /**\n     * The `finished` hook is called when the function has finished executing\n     * and has returned a final response that will end the run, either a\n     * successful or error response. In the case of an error response, further\n     * retries may be attempted and call this hook again.\n     *\n     * The output provided will be after `transformOutput` has been applied.\n     *\n     * This is not guaranteed to be called on every execution, and may be called\n     * multiple times if many parallel executions reach the end of the function;\n     * for a guaranteed single execution, create a function with an event\n     * trigger of `\"inngest/function.finished\"`.\n     */\n    finished?: MiddlewareRunFinished;\n\n    /**\n     * The `beforeResponse` hook is called after the output has been set and\n     * before the response is sent back to Inngest. This is where you can\n     * perform any final actions before the response is sent back to Inngest and\n     * is the final hook called.\n     */\n    beforeResponse?: BlankHook;\n  }>;\n\n  /**\n   * The `sendEvent` hook is called every time an event is sent to Inngest.\n   */\n  onSendEvent?: () => MaybePromise<{\n    /**\n     * The `input` hook is called before the event is sent to Inngest. This\n     * is where you can modify the event before it's sent to Inngest by\n     * returning an object containing changes.\n     */\n    transformInput?: MiddlewareSendEventInput;\n\n    /**\n     * The `output` hook is called after the event has been sent to Inngest.\n     * This is where you can perform any final actions after the event has\n     * been sent to Inngest and can modify the output the SDK sees.\n     */\n    transformOutput?: MiddlewareSendEventOutput;\n  }>;\n};\n\n/**\n * The direction of each hook that exists in the middleware lifecycle.\n * This is used to determine whether hooks found in a stack run forwards or\n * backwards, creating onion-like behaviour.\n */\nconst hookDirections: {\n  [K in keyof MiddlewareRegisterReturn]: Record<\n    keyof Await<NonNullable<MiddlewareRegisterReturn[K]>>,\n    \"forward\" | \"backward\"\n  >;\n} = {\n  onFunctionRun: {\n    transformInput: \"forward\",\n    beforeMemoization: \"forward\",\n    afterMemoization: \"backward\",\n    beforeExecution: \"forward\",\n    afterExecution: \"backward\",\n    transformOutput: \"backward\",\n    beforeResponse: \"forward\",\n    finished: \"forward\",\n  },\n  onSendEvent: {\n    transformInput: \"forward\",\n    transformOutput: \"backward\",\n  },\n};\n\n/**\n * @public\n */\nexport type MiddlewareRegisterFn = (ctx: {\n  /**\n   * The client this middleware is being registered on.\n   */\n  client: Inngest.Any;\n\n  /**\n   * If defined, this middleware has been applied directly to an Inngest\n   * function rather than on the client.\n   */\n  fn?: InngestFunction.Any;\n}) => MaybePromise<MiddlewareRegisterReturn>;\n\n/**\n * A blank, no-op hook that passes nothing and expects nothing in return.\n *\n * @internal\n */\ntype BlankHook = () => MaybePromise<void>;\n\n/**\n * Arguments sent to some `run` lifecycle hooks of a middleware.\n *\n * @internal\n */\ntype MiddlewareRunArgs = Readonly<{\n  /**\n   * The context object that will be passed to the function. This contains\n   * event data, some contextual data such as the run's ID, and step tooling.\n   */\n  ctx: Record<string, unknown> &\n    Readonly<BaseContext<Inngest.Any, TriggersFromClient<Inngest.Any>>>; // TODO Acceptable?\n\n  /**\n   * The step data that will be passed to the function.\n   */\n  steps: Readonly<IncomingOp>[];\n\n  /**\n   * The function that is being executed.\n   */\n  fn: InngestFunction.Any;\n\n  /**\n   * The raw arguments given to serve handler being used to execute the\n   * function.\n   */\n  reqArgs: Readonly<unknown[]>;\n}>;\n\n/**\n * The specific arguments sent to the `run` hook when an execution has begun.\n * Differs from {@link MiddlewareRunArgs} in that we don't have a complete\n * context yet.\n *\n * @internal\n */\ntype InitialRunInfo = Readonly<\n  Simplify<\n    Omit<MiddlewareRunArgs, \"ctx\"> & {\n      /**\n       * A partial context object that will be passed to the function. Does not\n       * necessarily contain all the data that will be passed to the function.\n       */\n      ctx: Readonly<{\n        event: EventPayload;\n        runId: string;\n      }>;\n    }\n  >\n>;\n\n/**\n * The shape of an `input` hook within a `run`, optionally returning change to\n * the context or steps.\n *\n * @internal\n */\ntype MiddlewareRunInput = (ctx: MiddlewareRunArgs) => MaybePromise<\n  | {\n      ctx?: Record<string, unknown>;\n      steps?: Pick<IncomingOp, \"data\">[];\n      // We need these in the future to allow users to specify their own complex\n      // types for transforming data above using just inference. e.g. every field\n      // ending with \"_at\" is transformed to a Date.\n      //\n      // transformEvent?: (event: EventPayload) => unknown;\n      // transformStep?: (data: unknown) => unknown;\n    }\n  | undefined\n  // biome-ignore lint/suspicious/noConfusingVoidType: <explanation>\n  | void\n>;\n\n/**\n * Arguments for the SendEventInput hook\n *\n * @internal\n */\ntype MiddlewareSendEventInputArgs = Readonly<{\n  payloads: ReadonlyArray<EventPayload>;\n}>;\n\n/**\n * The shape of an `input` hook within a `sendEvent`, optionally returning\n * change to the payloads.\n *\n * @internal\n */\ntype MiddlewareSendEventInput = (\n  ctx: MiddlewareSendEventInputArgs,\n) => MaybePromise<\n  | {\n      payloads?: EventPayload[];\n    }\n  | undefined\n  // biome-ignore lint/suspicious/noConfusingVoidType: <explanation>\n  | void\n>;\n\n/**\n * Arguments for the SendEventOutput hook\n *\n * @internal\n */\ntype MiddlewareSendEventOutputArgs = { result: Readonly<SendEventBaseOutput> };\n\n/**\n * The shape of an `output` hook within a `sendEvent`, optionally returning a\n * change to the result value.\n */\ntype MiddlewareSendEventOutput = (\n  ctx: MiddlewareSendEventOutputArgs,\n  // biome-ignore lint/suspicious/noConfusingVoidType: <explanation>\n) => MaybePromise<{ result?: Record<string, unknown> } | undefined | void>;\n\n/**\n * @internal\n */\ntype MiddlewareRunOutput = (ctx: {\n  result: Readonly<Pick<OutgoingOp, \"error\" | \"data\">>;\n  step?: Readonly<Omit<OutgoingOp, \"id\">>;\n}) => MaybePromise<\n  | {\n      result?: Partial<Pick<OutgoingOp, \"data\" | \"error\">>;\n    }\n  | undefined\n  // biome-ignore lint/suspicious/noConfusingVoidType: <explanation>\n  | void\n>;\n\ntype MiddlewareRunFinished = (ctx: {\n  result: Readonly<Pick<OutgoingOp, \"error\" | \"data\">>;\n}) => MaybePromise<void>;\n\n/**\n * @internal\n */\ntype GetMiddlewareRunInputMutation<TMiddleware extends InngestMiddleware.Like> =\n  TMiddleware extends InngestMiddleware<infer TOpts>\n    ? TOpts[\"init\"] extends MiddlewareRegisterFn\n      ? Await<\n          Await<Await<TOpts[\"init\"]>[\"onFunctionRun\"]>[\"transformInput\"]\n        > extends {\n          ctx: infer TCtx;\n        }\n        ? {\n            [K in keyof TCtx]: TCtx[K];\n          }\n        : {}\n      : {}\n    : {};\n\n/**\n * @internal\n */\ntype GetMiddlewareSendEventOutputMutation<\n  TMiddleware extends InngestMiddleware.Like,\n> = TMiddleware extends InngestMiddleware<infer TOpts>\n  ? TOpts[\"init\"] extends MiddlewareRegisterFn\n    ? Await<\n        Await<Await<TOpts[\"init\"]>[\"onSendEvent\"]>[\"transformOutput\"]\n      > extends {\n        result: infer TResult;\n      }\n      ? {\n          [K in keyof TResult]: TResult[K];\n        }\n      : {}\n    : {}\n  : {};\n\n/**\n * @internal\n */\nexport type MiddlewareStackSendEventOutputMutation<\n  TContext,\n  TMiddleware extends InngestMiddleware.Stack,\n> = ObjectAssign<\n  {\n    [K in keyof TMiddleware]: GetMiddlewareSendEventOutputMutation<\n      TMiddleware[K]\n    >;\n  },\n  TContext\n>;\n\nexport type ExtendWithMiddleware<\n  TMiddlewareStacks extends InngestMiddleware.Stack[],\n  TContext = {},\n> = ObjectAssign<\n  {\n    [K in keyof TMiddlewareStacks]: MiddlewareStackRunInputMutation<\n      {},\n      TMiddlewareStacks[K]\n    >;\n  },\n  TContext\n>;\n\nexport type ExtendSendEventWithMiddleware<\n  TMiddlewareStacks extends InngestMiddleware.Stack[],\n  TContext = {},\n> = ObjectAssign<\n  {\n    [K in keyof TMiddlewareStacks]: MiddlewareStackSendEventOutputMutation<\n      {},\n      TMiddlewareStacks[K]\n    >;\n  },\n  TContext\n>;\n\n/**\n * @internal\n */\nexport type MiddlewareStackRunInputMutation<\n  TContext,\n  TMiddleware extends InngestMiddleware.Stack,\n> = ObjectAssign<\n  {\n    [K in keyof TMiddleware]: GetMiddlewareRunInputMutation<TMiddleware[K]>;\n  },\n  TContext\n>;\n"],"names":["key","hookDirections: {\n  [K in keyof MiddlewareRegisterReturn]: Record<\n    keyof Await<NonNullable<MiddlewareRegisterReturn[K]>>,\n    \"forward\" | \"backward\"\n  >;\n}"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;GA0CA,IAAa,oBAAb,MAAa,kBAEb;IACE,IAAA,CAAK,OAAO,WAAA,CAAA,GAA6C;QACvD,OAAO,kBAAkB,GAAA;;;;;IAOX,KAAA;;;;;;;;;;;;;;;IAiBA,KAAA;IAEhB,YAAY,EAAE,IAAA,EAAM,IAAA,EAAA,CAAe;QACjC,IAAA,CAAK,IAAA,GAAO;QACZ,IAAA,CAAK,IAAA,GAAO;;;;6BAKK;;;;;;;;GA2DrB,MAAa,eAAe,OAW1B,YAKA,KAKA,KAEA,eAgBkB;IAElB,MAAM,WAAW,cAAA,CAAe,IAAA;IAChC,IAAI,CAAC,SACH,CAAA,MAAM,IAAI,MACR,CAAA,kCAAA,EAAqC,OAAO,IAAI,CAAC,2CAAA,CAAA,CAClD;IAqBH,MAAM,kBAAkB,MAAA,CAjBR,MAAM,UAAA,EAGC,MAAA,CAAA,CACpB,KAAK,OAAO;QACX,MAAM,KAAK,EAAA,CAAG,IAAA;QAEd,IAAI,GACF,CAAA,OAAO,CAAC;eAAG;YAAK;SAAG;QAGrB,OAAO;OAET,EAAE,CACH,CAGoC,MAAA,CAEnC,OAAO,KAAK,OAAO;QACnB,OAAO,CAAC;eAAI,MAAM;YAAM,MAAM,GAAG,IAAI;SAAC;OACrC,QAAQ,OAAA,CAAQ,EAAE,CAAC,CAAC;IAIvB,MAAM,MAAM,CAAA,CAAE;IAGd,KAAK,MAAM,QAAQ,gBAAiB;QAClC,MAAM,WAAW,OAAO,IAAA,CAAK,KAAK;QAElC,KAAK,MAAMA,SAAO,SAAU;YAC1B,IAAI,MAAM;gBAAC,IAAA,CAAKA,MAAAA;aAAK;YAErB,MAAM,oBAAoB,GAAA,CAAIA,MAAAA;YAC9B,IAAI,kBACF,CAAA,IAAI,QAAA,CAASA,MAAAA,KAAkC,UAC7C,CAAA,MAAM;gBAAC;gBAAmB,IAAA,CAAKA,MAAAA;aAAK;iBAIpC,MAAM;gBAAC,IAAA,CAAKA,MAAAA;gBAAM;aAAkB;YAIxC,MAAM,YAAY,UAAA,CAAWA,MAAAA;YAI7B,GAAA,CAAIA,MAAAA,qWAAO,YAAA,EAAU,KAAK,UAAU;;;IAKxC,KAAK,MAAM,KAAK,OAAO,IAAA,CAAK,IAAI,CAAE;QAChC,MAAMA,QAAM;QAEZ,GAAA,CAAIA,MAAAA,qWAAO,UAAA,EACT,GAAA,CAAIA,MAAAA,CACL;;IAGH,OAAO;;;;;;GAsJT,MAAMC,iBAKF;IACF,eAAe;QACb,gBAAgB;QAChB,mBAAmB;QACnB,kBAAkB;QAClB,iBAAiB;QACjB,gBAAgB;QAChB,iBAAiB;QACjB,gBAAgB;QAChB,UAAU;KACX;IACD,aAAa;QACX,gBAAgB;QAChB,iBAAiB;KAClB;CACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1306, "column": 0}, "map": {"version":3,"file":"strings.js","sources":["file:///Users/amansatyawani/Desktop/website-builder/node_modules/.pnpm/inngest%403.45.1_%40opentelemetry%2Bcore%402.2.0_%40opentelemetry%2Bapi%401.9.0__express%405.1.0_next%401_e029d374516642dd9a767b32fbb0beec/node_modules/src/helpers/strings.ts"],"sourcesContent":["import hashjs from \"hash.js\";\nimport { default as safeStringify } from \"json-stringify-safe\";\nimport ms from \"ms\";\nimport type { TimeStr } from \"../types.ts\";\n\nconst { sha256 } = hashjs;\n\n/**\n * Safely `JSON.stringify()` an `input`, handling circular refernences and\n * removing `BigInt` values.\n */\n// biome-ignore lint/suspicious/noExplicitAny: <explanation>\nexport const stringify = (input: any): string => {\n  return safeStringify(input, (_key, value) => {\n    if (typeof value !== \"bigint\") {\n      return value;\n    }\n  });\n};\n\n/**\n * Returns a slugified string used to generate consistent IDs.\n *\n * This can be used to generate a consistent ID for a function when migrating\n * from v2 to v3 of the SDK.\n *\n * @public\n */\nexport const slugify = (str: string): string => {\n  const join = \"-\";\n  return str\n    .toLowerCase()\n    .replace(/[^a-z0-9-]+/g, join)\n    .replace(/-+/g, join)\n    .split(join)\n    .filter(Boolean)\n    .join(join);\n};\n\nconst millisecond = 1;\nconst second = millisecond * 1000;\nconst minute = second * 60;\nconst hour = minute * 60;\nconst day = hour * 24;\nconst week = day * 7;\n\n/**\n * A collection of periods in milliseconds and their suffixes used when creating\n * time strings.\n */\nconst periods = [\n  [\"w\", week],\n  [\"d\", day],\n  [\"h\", hour],\n  [\"m\", minute],\n  [\"s\", second],\n] as const;\n\n/**\n * Convert a given `Date`, `number`, or `ms`-compatible `string` to a\n * Inngest sleep-compatible time string (e.g. `\"1d\"` or `\"2h3010s\"`).\n *\n * Can optionally provide a `now` date to use as the base for the calculation,\n * otherwise a new date will be created on invocation.\n */\nexport const timeStr = (\n  /**\n   * The future date to use to convert to a time string.\n   */\n  input: string | number | Date,\n): string => {\n  if (input instanceof Date) {\n    return input.toISOString();\n  }\n\n  const milliseconds: number =\n    typeof input === \"string\" ? ms(input as `${number}`) : input;\n\n  const [, timeStr] = periods.reduce<[number, string]>(\n    ([num, str], [suffix, period]) => {\n      const numPeriods = Math.floor(num / period);\n\n      if (numPeriods > 0) {\n        return [num % period, `${str}${numPeriods}${suffix}`];\n      }\n\n      return [num, str];\n    },\n    [milliseconds, \"\"],\n  );\n\n  return timeStr as TimeStr;\n};\n\n/**\n * Given an unknown input, stringify it if it's a boolean, a number, or a\n * string, else return `undefined`.\n */\nexport const stringifyUnknown = (input: unknown): string | undefined => {\n  if (\n    typeof input === \"boolean\" ||\n    typeof input === \"number\" ||\n    typeof input === \"string\"\n  ) {\n    return input.toString();\n  }\n\n  return;\n};\n\nexport const hashEventKey = (eventKey: string): string => {\n  return sha256().update(eventKey).digest(\"hex\");\n};\n\nexport const hashSigningKey = (signingKey: string | undefined): string => {\n  if (!signingKey) {\n    return \"\";\n  }\n\n  const prefix = signingKey.match(/^signkey-[\\w]+-/)?.shift() || \"\";\n  const key = signingKey.replace(/^signkey-[\\w]+-/, \"\");\n\n  // Decode the key from its hex representation into a bytestream\n  return `${prefix}${sha256().update(key, \"hex\").digest(\"hex\")}`;\n};\n"],"names":["stringify","safeStringify","milliseconds: number","timeStr"],"mappings":";;;;;;;;;;;;;;;AAKA,MAAM,EAAE,MAAA,EAAA,sMAAW,UAAA;;;;GAOnB,MAAaA,cAAAA,CAAa,UAAuB;IAC/C,yOAAOC,WAAAA,EAAc,OAAA,CAAQ,MAAM,UAAU;QAC3C,IAAI,OAAO,UAAU,SACnB,CAAA,OAAO;MAET;;;;;;;;;GAWJ,MAAa,UAAA,CAAW,QAAwB;IAC9C,MAAM,OAAO;IACb,OAAO,IACJ,WAAA,EAAa,CACb,OAAA,CAAQ,gBAAgB,KAAK,CAC7B,OAAA,CAAQ,OAAO,KAAK,CACpB,KAAA,CAAM,KAAK,CACX,MAAA,CAAO,QAAQ,CACf,IAAA,CAAK,KAAK;;AAIf,MAAM,SADc,IACS;AAC7B,MAAM,SAAS,SAAS;AACxB,MAAM,OAAO,SAAS;AACtB,MAAM,MAAM,OAAO;;;;GAOnB,MAAM,UAAU;IACd;QAAC;QAPU,MAAM;KAON;IACX;QAAC;QAAK;KAAI;IACV;QAAC;QAAK;KAAK;IACX;QAAC;QAAK;KAAO;IACb;QAAC;QAAK;KAAO;CACd;;;;;;;GASD,MAAa,UAAA,CAIX,UACW;IACX,IAAI,iBAAiB,KACnB,CAAA,OAAO,MAAM,WAAA,EAAa;IAG5B,MAAMC,eACJ,OAAO,UAAU,4LAAW,UAAA,EAAG,MAAqB,GAAG;IAEzD,MAAM,GAAGC,UAAAA,GAAW,QAAQ,MAAA,CAAA,CACzB,CAAC,KAAK,IAAA,EAAM,CAAC,QAAQ,OAAA,KAAY;QAChC,MAAM,aAAa,KAAK,KAAA,CAAM,MAAM,OAAO;QAE3C,IAAI,aAAa,EACf,CAAA,OAAO;YAAC,MAAM;YAAQ,GAAG,MAAM,aAAa,QAAA;SAAS;QAGvD,OAAO;YAAC;YAAK;SAAI;OAEnB;QAAC;QAAc;KAAG,CACnB;IAED,OAAOA;;;;;GAOT,MAAa,mBAAA,CAAoB,UAAuC;IACtE,IACE,OAAO,UAAU,aACjB,OAAO,UAAU,YACjB,OAAO,UAAU,SAEjB,CAAA,OAAO,MAAM,QAAA,EAAU;;AAM3B,MAAa,eAAA,CAAgB,aAA6B;IACxD,OAAO,QAAQ,CAAC,MAAA,CAAO,SAAS,CAAC,MAAA,CAAO,MAAM;;AAGhD,MAAa,iBAAA,CAAkB,eAA2C;IACxE,IAAI,CAAC,WACH,CAAA,OAAO;IAGT,MAAM,SAAS,WAAW,KAAA,CAAM,kBAAkB,EAAE,OAAO,IAAI;IAC/D,MAAM,MAAM,WAAW,OAAA,CAAQ,mBAAmB,GAAG;IAGrD,OAAO,GAAG,SAAS,QAAQ,CAAC,MAAA,CAAO,KAAK,MAAM,CAAC,MAAA,CAAO,MAAM,EAAA","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1418, "column": 0}, "map": {"version":3,"file":"version.js","sources":["file:///Users/amansatyawani/Desktop/website-builder/node_modules/.pnpm/inngest%403.45.1_%40opentelemetry%2Bcore%402.2.0_%40opentelemetry%2Bapi%401.9.0__express%405.1.0_next%401_e029d374516642dd9a767b32fbb0beec/node_modules/src/version.ts"],"sourcesContent":["// Generated by genversion.\nexport const version = \"3.45.1\";\n"],"names":[],"mappings":";;;;AACA,MAAa,UAAU","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1431, "column": 0}, "map": {"version":3,"file":"env.js","sources":["file:///Users/amansatyawani/Desktop/website-builder/node_modules/.pnpm/inngest%403.45.1_%40opentelemetry%2Bcore%402.2.0_%40opentelemetry%2Bapi%401.9.0__express%405.1.0_next%401_e029d374516642dd9a767b32fbb0beec/node_modules/src/helpers/env.ts"],"sourcesContent":["// This file exists to help normalize process.env amongst the backend\n// and frontend.  Many frontends (eg. Next, CRA) utilize webpack's DefinePlugin\n// along with prefixes, meaning we have to explicitly use the full `process.env.FOO`\n// string in order to read variables.\n\nimport type { Inngest } from \"../components/Inngest.ts\";\nimport type { SupportedFrameworkName } from \"../types.ts\";\nimport { version } from \"../version.ts\";\nimport { defaultDevServerHost, envKeys, headerKeys } from \"./consts.ts\";\nimport { stringifyUnknown } from \"./strings.ts\";\n\n/**\n * @public\n */\nexport type Env = Record<string, EnvValue>;\n\n/**\n * @public\n */\nexport type EnvValue = string | undefined;\n\n/**\n * devServerHost returns the dev server host by searching for the INNGEST_DEVSERVER_URL\n * environment variable (plus project prefixces for eg. react, such as REACT_APP_INNGEST_DEVSERVER_URL).\n *\n * If not found this returns undefined, indicating that the env var has not been set.\n *\n * @example devServerHost()\n */\nexport const devServerHost = (env: Env = allProcessEnv()): EnvValue => {\n  // devServerKeys are the env keys we search for to discover the dev server\n  // URL.  This includes the standard key first, then includes prefixed keys\n  // for use within common frameworks (eg. CRA, next).\n  //\n  // We have to fully write these using process.env as they're typically\n  // processed using webpack's DefinePlugin, which is dumb and does a straight\n  // text replacement instead of actually understanding the AST, despite webpack\n  // being fully capable of understanding the AST.\n  const prefixes = [\"REACT_APP_\", \"NEXT_PUBLIC_\"];\n  const keys = [envKeys.InngestBaseUrl, envKeys.InngestDevMode];\n\n  const values = keys.flatMap((key) => {\n    return prefixes.map((prefix) => {\n      return env[prefix + key];\n    });\n  });\n\n  return values.find((v) => {\n    if (!v) {\n      return;\n    }\n\n    try {\n      return Boolean(new URL(v));\n    } catch {\n      // no-op\n    }\n\n    return;\n  });\n};\n\nconst checkFns = (<\n  T extends Record<string, (actual: EnvValue, expected: EnvValue) => boolean>,\n>(\n  checks: T,\n): T => checks)({\n  equals: (actual, expected) => actual === expected,\n  \"starts with\": (actual, expected) =>\n    expected ? (actual?.startsWith(expected) ?? false) : false,\n  \"is truthy\": (actual) => Boolean(actual),\n  \"is truthy but not\": (actual, expected) =>\n    Boolean(actual) && actual !== expected,\n});\n\nconst prodChecks: [\n  key: string,\n  customCheck: keyof typeof checkFns,\n  value?: string,\n][] = [\n  [\"CF_PAGES\", \"equals\", \"1\"],\n  [\"CONTEXT\", \"starts with\", \"prod\"],\n  [\"ENVIRONMENT\", \"starts with\", \"prod\"],\n  [\"NODE_ENV\", \"starts with\", \"prod\"],\n  [\"VERCEL_ENV\", \"starts with\", \"prod\"],\n  [\"DENO_DEPLOYMENT_ID\", \"is truthy\"],\n  [envKeys.VercelEnvKey, \"is truthy but not\", \"development\"],\n  [envKeys.IsNetlify, \"is truthy\"],\n  [envKeys.IsRender, \"is truthy\"],\n  [envKeys.RailwayBranch, \"is truthy\"],\n  [envKeys.IsCloudflarePages, \"is truthy\"],\n];\n\ninterface IsProdOptions {\n  /**\n   * The optional environment variables to use instead of `process.env`.\n   */\n  env?: Record<string, EnvValue>;\n\n  /**\n   * The Inngest client that's being used when performing this check. This is\n   * used to check if the client has an explicit mode set, and if so, to use\n   * that mode instead of inferring it from the environment.\n   */\n  client?: Inngest.Any;\n\n  /**\n   * If specified as a `boolean`, this will be returned as the result of the\n   * function. Useful for options that may or may not be set by users.\n   */\n  explicitMode?: Mode[\"type\"];\n}\n\nexport interface ModeOptions {\n  type: \"cloud\" | \"dev\";\n\n  /**\n   * Whether the mode was explicitly set, or inferred from other sources.\n   */\n  isExplicit: boolean;\n\n  /**\n   * If the mode was explicitly set as a dev URL, this is the URL that was set.\n   */\n  explicitDevUrl?: URL;\n\n  /**\n   * Environment variables to use when determining the mode.\n   */\n  env?: Env;\n}\n\nexport class Mode {\n  public readonly type: \"cloud\" | \"dev\";\n\n  /**\n   * Whether the mode was explicitly set, or inferred from other sources.\n   */\n  public readonly isExplicit: boolean;\n\n  public readonly explicitDevUrl?: URL;\n\n  // biome-ignore lint/correctness/noUnusedPrivateClassMembers: used in the SDK\n  private readonly env: Env;\n\n  constructor({\n    type,\n    isExplicit,\n    explicitDevUrl,\n    env = allProcessEnv(),\n  }: ModeOptions) {\n    this.env = env;\n    this.type = type;\n    this.isExplicit = isExplicit || Boolean(explicitDevUrl);\n    this.explicitDevUrl = explicitDevUrl;\n  }\n\n  public get isDev(): boolean {\n    return this.type === \"dev\";\n  }\n\n  public get isCloud(): boolean {\n    return this.type === \"cloud\";\n  }\n\n  public get isInferred(): boolean {\n    return !this.isExplicit;\n  }\n\n  /**\n   * If we are explicitly in a particular mode, retrieve the URL that we are\n   * sure we should be using, not considering any environment variables or other\n   * influences.\n   */\n  public getExplicitUrl(defaultCloudUrl: string): string | undefined {\n    if (!this.isExplicit) {\n      return undefined;\n    }\n\n    if (this.explicitDevUrl) {\n      return this.explicitDevUrl.href;\n    }\n\n    if (this.isCloud) {\n      return defaultCloudUrl;\n    }\n\n    if (this.isDev) {\n      return defaultDevServerHost;\n    }\n\n    return undefined;\n  }\n}\n\n/**\n * Returns the mode of the current environment, based off of either passed\n * environment variables or `process.env`, or explicit settings.\n */\nexport const getMode = ({\n  env = allProcessEnv(),\n  client,\n  explicitMode,\n}: IsProdOptions = {}): Mode => {\n  if (explicitMode) {\n    return new Mode({ type: explicitMode, isExplicit: true, env });\n  }\n\n  if (client?.[\"mode\"].isExplicit) {\n    return client[\"mode\"];\n  }\n\n  if (envKeys.InngestDevMode in env) {\n    if (typeof env[envKeys.InngestDevMode] === \"string\") {\n      try {\n        const explicitDevUrl = new URL(env[envKeys.InngestDevMode]);\n        return new Mode({ type: \"dev\", isExplicit: true, explicitDevUrl, env });\n      } catch {\n        // no-op\n      }\n    }\n\n    const envIsDev = parseAsBoolean(env[envKeys.InngestDevMode]);\n    if (typeof envIsDev === \"boolean\") {\n      return new Mode({\n        type: envIsDev ? \"dev\" : \"cloud\",\n        isExplicit: true,\n        env,\n      });\n    }\n  }\n\n  const isProd = prodChecks.some(([key, checkKey, expected]) => {\n    return checkFns[checkKey](stringifyUnknown(env[key]), expected);\n  });\n\n  return new Mode({ type: isProd ? \"cloud\" : \"dev\", isExplicit: false, env });\n};\n\n/**\n * getEnvironmentName returns the suspected branch name for this environment by\n * searching through a set of common environment variables.\n *\n * This could be used to determine if we're on a branch deploy or not, though it\n * should be noted that we don't know if this is the default branch or not.\n */\nexport const getEnvironmentName = (env: Env = allProcessEnv()): EnvValue => {\n  /**\n   * Order is important; more than one of these env vars may be set, so ensure\n   * that we check the most specific, most reliable env vars first.\n   */\n  return (\n    env[envKeys.InngestEnvironment] ||\n    env[envKeys.BranchName] ||\n    env[envKeys.VercelBranch] ||\n    env[envKeys.NetlifyBranch] ||\n    env[envKeys.CloudflarePagesBranch] ||\n    env[envKeys.RenderBranch] ||\n    env[envKeys.RailwayBranch]\n  );\n};\n\nexport const processEnv = (key: string): EnvValue => {\n  return allProcessEnv()[key];\n};\n\n/**\n * The Deno environment, which is not always available.\n */\ndeclare const Deno: {\n  env: { toObject: () => Env };\n};\n\n/**\n * The Netlify environment, which is not always available.\n */\ndeclare const Netlify: {\n  env: { toObject: () => Env };\n};\n\n/**\n * allProcessEnv returns the current process environment variables, or an empty\n * object if they cannot be read, making sure we support environments other than\n * Node such as Deno, too.\n *\n * Using this ensures we don't dangerously access `process.env` in environments\n * where it may not be defined, such as Deno or the browser.\n */\nexport const allProcessEnv = (): Env => {\n  // Node, or Node-like environments\n  try {\n    if (process.env) {\n      return process.env;\n    }\n  } catch (_err) {\n    // noop\n  }\n\n  // Deno\n  try {\n    const env = Deno.env.toObject();\n\n    if (env) {\n      return env;\n    }\n  } catch (_err) {\n    // noop\n  }\n\n  // Netlify\n  try {\n    const env = Netlify.env.toObject();\n\n    if (env) {\n      return env;\n    }\n  } catch (_err) {\n    // noop\n  }\n\n  return {};\n};\n\n/**\n * Generate a standardised set of headers based on input and environment\n * variables.\n *\n *\n */\nexport const inngestHeaders = (opts?: {\n  /**\n   * The environment variables to use instead of `process.env` or any other\n   * default source. Useful for platforms where environment variables are passed\n   * in alongside requests.\n   */\n  env?: Env;\n\n  /**\n   * The framework name to use in the `X-Inngest-Framework` header. This is not\n   * always available, hence being optional.\n   */\n  framework?: string;\n\n  /**\n   * The environment name to use in the `X-Inngest-Env` header. This is likely\n   * to be representative of the target preview environment.\n   */\n  inngestEnv?: string;\n\n  /**\n   * The Inngest client that's making the request. The client itself will\n   * generate a set of headers; specifying it here will ensure that the client's\n   * headers are included in the returned headers.\n   */\n  client?: Inngest;\n\n  /**\n   * The Inngest server we expect to be communicating with, used to ensure that\n   * various parts of a handshake are all happening with the same type of\n   * participant.\n   */\n  expectedServerKind?: string;\n\n  /**\n   * Any additional headers to include in the returned headers.\n   */\n  extras?: Record<string, string>;\n}): Record<string, string> => {\n  const sdkVersion = `inngest-js:v${version}`;\n  const headers: Record<string, string> = {\n    \"Content-Type\": \"application/json\",\n    \"User-Agent\": sdkVersion,\n    [headerKeys.SdkVersion]: sdkVersion,\n  };\n\n  if (opts?.framework) {\n    headers[headerKeys.Framework] = opts.framework;\n  }\n\n  if (opts?.expectedServerKind) {\n    headers[headerKeys.InngestExpectedServerKind] = opts.expectedServerKind;\n  }\n\n  const env = {\n    ...allProcessEnv(),\n    ...opts?.env,\n  };\n\n  const inngestEnv = opts?.inngestEnv || getEnvironmentName(env);\n  if (inngestEnv) {\n    headers[headerKeys.Environment] = inngestEnv;\n  }\n\n  const platform = getPlatformName(env);\n  if (platform) {\n    headers[headerKeys.Platform] = platform;\n  }\n\n  return {\n    ...headers,\n    ...opts?.client?.[\"headers\"],\n    ...opts?.extras,\n  };\n};\n\n/**\n * A set of checks that, given an environment, will return `true` if the current\n * environment is running on the platform with the given name.\n */\nconst platformChecks = {\n  /**\n   * Vercel Edge Functions don't have access to environment variables unless\n   * they are explicitly referenced in the top level code, but they do have a\n   * global `EdgeRuntime` variable set that we can use to detect this.\n   */\n  vercel: (env) =>\n    env[envKeys.IsVercel] === \"1\" || typeof EdgeRuntime === \"string\",\n  netlify: (env) => env[envKeys.IsNetlify] === \"true\",\n  \"cloudflare-pages\": (env) => env[envKeys.IsCloudflarePages] === \"1\",\n  render: (env) => env[envKeys.IsRender] === \"true\",\n  railway: (env) => Boolean(env[envKeys.RailwayEnvironment]),\n} satisfies Record<string, (env: Env) => boolean>;\n\ndeclare const EdgeRuntime: string | undefined;\n\n/**\n * A set of checks that, given an environment, will return `true` if the current\n * environment and platform supports streaming responses back to Inngest.\n *\n * Streaming capability is both framework and platform-based. Frameworks are\n * supported in serve handlers, and platforms are checked here.\n *\n * As such, this record declares which platforms we explicitly support for\n * streaming and is used by {@link platformSupportsStreaming}.\n */\nconst streamingChecks: Partial<\n  Record<\n    keyof typeof platformChecks,\n    (framework: SupportedFrameworkName, env: Env) => boolean\n  >\n> = {\n  /**\n   * \"Vercel supports streaming for Serverless Functions, Edge Functions, and\n   * React Server Components in Next.js projects.\"\n   *\n   * In practice, however, there are many reports of streaming not working as\n   * expected on Serverless Functions, so we resort to only allowing streaming\n   * for Edge Functions here.\n   *\n   * See {@link https://vercel.com/docs/frameworks/nextjs#streaming}\n   */\n  vercel: (_framework, _env) => typeof EdgeRuntime === \"string\",\n  \"cloudflare-pages\": () => true,\n};\n\nexport const getPlatformName = (env: Env) => {\n  return (Object.keys(platformChecks) as (keyof typeof platformChecks)[]).find(\n    (key) => {\n      return platformChecks[key](env);\n    },\n  );\n};\n\n/**\n * Returns `true` if we believe the current environment supports streaming\n * responses back to Inngest.\n *\n * We run a check directly related to the platform we believe we're running on,\n * usually based on environment variables.\n */\nexport const platformSupportsStreaming = (\n  framework: SupportedFrameworkName,\n  env: Env = allProcessEnv(),\n): boolean => {\n  return (\n    streamingChecks[getPlatformName(env) as keyof typeof streamingChecks]?.(\n      framework,\n      env,\n    ) ?? false\n  );\n};\n\n/**\n * A unique symbol used to mark a custom fetch implementation. We wrap the\n * implementations to provide some extra control when handling errors.\n */\nconst CUSTOM_FETCH_MARKER = Symbol(\"Custom fetch implementation\");\n\n/**\n * Given a potential fetch function, return the fetch function to use based on\n * this and the environment.\n */\nexport const getFetch = (givenFetch?: typeof fetch): typeof fetch => {\n  /**\n   * If we've explicitly been given a fetch function, use that.\n   */\n  if (givenFetch) {\n    if (CUSTOM_FETCH_MARKER in givenFetch) {\n      return givenFetch;\n    }\n\n    /**\n     * We wrap the given fetch function to provide some extra control when\n     * handling errors.\n     */\n    const customFetch: typeof fetch = async (...args) => {\n      try {\n        return await givenFetch(...args);\n      } catch (err) {\n        /**\n         * Capture warnings that are not simple fetch failures and highlight\n         * them for the user.\n         *\n         * We also use this opportunity to log the causing error, as code higher\n         * up the stack will likely abstract this.\n         */\n        if (\n          !(err instanceof Error) ||\n          !err.message?.startsWith(\"fetch failed\")\n        ) {\n          console.warn(\n            \"A request failed when using a custom fetch implementation; this may be a misconfiguration. Make sure that your fetch client is correctly bound to the global scope.\",\n          );\n          console.error(err);\n        }\n\n        throw err;\n      }\n    };\n\n    /**\n     * Mark the custom fetch implementation so that we can identify it later, in\n     * addition to adding some runtime properties to it to make it seem as much\n     * like the original fetch as possible.\n     */\n    Object.defineProperties(customFetch, {\n      [CUSTOM_FETCH_MARKER]: {},\n      name: { value: givenFetch.name },\n      length: { value: givenFetch.length },\n    });\n\n    return customFetch;\n  }\n\n  /**\n   * Browser or Node 18+\n   */\n  try {\n    if (typeof globalThis !== \"undefined\" && \"fetch\" in globalThis) {\n      return fetch.bind(globalThis);\n    }\n  } catch (_err) {\n    // no-op\n  }\n\n  /**\n   * Existing polyfilled fetch\n   */\n  if (typeof fetch !== \"undefined\") {\n    return fetch;\n  }\n\n  /**\n   * Environments where fetch cannot be found and must be polyfilled\n   */\n  return require(\"cross-fetch\") as typeof fetch;\n};\n\n/**\n * If `Response` isn't included in this environment, it's probably an earlier\n * Node env that isn't already polyfilling. This function returns either the\n * native `Response` or a polyfilled one.\n */\nexport const getResponse = (): typeof Response => {\n  if (typeof Response !== \"undefined\") {\n    return Response;\n  }\n\n  return require(\"cross-fetch\").Response;\n};\n\n/**\n * Given an unknown value, try to parse it as a `boolean`. Useful for parsing\n * environment variables that could be a selection of different values such as\n * `\"true\"`, `\"1\"`.\n *\n * If the value could not be confidently parsed as a `boolean` or was seen to be\n * `undefined`, this function returns `undefined`.\n */\nexport const parseAsBoolean = (value: unknown): boolean | undefined => {\n  if (typeof value === \"boolean\") {\n    return value;\n  }\n\n  if (typeof value === \"number\") {\n    return Boolean(value);\n  }\n\n  if (typeof value === \"string\") {\n    const trimmed = value.trim().toLowerCase();\n\n    if (trimmed === \"undefined\") {\n      return undefined;\n    }\n\n    if ([\"true\", \"1\"].includes(trimmed)) {\n      return true;\n    }\n\n    return false;\n  }\n\n  return undefined;\n};\n"],"names":["prodChecks: [\n  key: string,\n  customCheck: keyof typeof checkFns,\n  value?: string,\n][]","headers: Record<string, string>","streamingChecks: Partial<\n  Record<\n    keyof typeof platformChecks,\n    (framework: SupportedFrameworkName, env: Env) => boolean\n  >\n>","customFetch: typeof fetch"],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1801, "column": 0}, "map": {"version":3,"file":"devserver.js","sources":["file:///Users/amansatyawani/Desktop/website-builder/node_modules/.pnpm/inngest%403.45.1_%40opentelemetry%2Bcore%402.2.0_%40opentelemetry%2Bapi%401.9.0__express%405.1.0_next%401_e029d374516642dd9a767b32fbb0beec/node_modules/src/helpers/devserver.ts"],"sourcesContent":["import { defaultDevServerHost } from \"./consts.ts\";\nimport { devServerHost as envDevServerHost } from \"./env.ts\";\n\n// re-export from devserver.ts\n\n/**\n * A simple type map that we can transparently use `fetch` later without having\n * to fall in to the self-referencing `const fetch: typeof fetch = ...` which\n * fails.\n */\ntype FetchT = typeof fetch;\n\n/**\n * Attempts to contact the dev server, returning a boolean indicating whether or\n * not it was successful.\n *\n * @example devServerUrl(process.env[envKeys.DevServerUrl], \"/your-path\")\n */\nexport const devServerAvailable = async (\n  /**\n   * The host of the dev server. You should pass in an environment variable as\n   * this parameter.\n   */\n  host: string = defaultDevServerHost,\n\n  /**\n   * The fetch implementation to use to communicate with the dev server.\n   */\n  fetch: FetchT,\n): Promise<boolean> => {\n  try {\n    const url = devServerUrl(host, \"/dev\");\n    const result = await fetch(url.toString());\n    await result.json();\n    return true;\n  } catch (_e) {\n    return false;\n  }\n};\n\n/**\n * devServerUrl returns a full URL for the given path name.\n *\n * Because Cloudflare/V8 platforms don't allow process.env, you are expected\n * to pass in the host from the dev server env key:\n *\n * @example devServerUrl(processEnv(envKeys.DevServerUrl), \"/your-path\")\n * @example devServerUrl(\"http://localhost:8288/\", \"/your-path\")\n */\nexport const devServerUrl = (\n  host: string = devServerHost(),\n  pathname = \"\",\n): URL => {\n  return new URL(pathname, host.includes(\"://\") ? host : `http://${host}`);\n};\n\n/**\n * devServerHost exports the development server's domain by inspecting env\n * variables, or returns the default development server URL.\n *\n * This guarantees a specific URL as a string, as opposed to the env export\n * which only returns a value of the env var is set.\n */\nexport const devServerHost = (): string =>\n  envDevServerHost() || defaultDevServerHost;\n"],"names":["devServerHost","envDevServerHost"],"mappings":";;;;;;;;;;;;;;GAkBA,MAAa,qBAAqB,OAKhC,kWAAe,uBAAA,EAKf,UACqB;IACrB,IAAI;QAGF,MAAA,CADe,MAAM,MADT,aAAa,MAAM,OAAO,CACP,QAAA,EAAU,CAAC,EAC7B,IAAA,EAAM;QACnB,OAAO;aACA,IAAI;QACX,OAAO;;;;;;;;;;;GAaX,MAAa,eAAA,CACX,OAAeA,iBAAe,EAC9B,WAAW,EAAA,KACH;IACR,OAAO,IAAI,IAAI,UAAU,KAAK,QAAA,CAAS,MAAM,GAAG,OAAO,CAAA,OAAA,EAAU,MAAA,CAAO;;;;;;;;GAU1E,MAAaA,kBAAAA,gWACXC,gBAAAA,EAAkB,gWAAI,uBAAA","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1849, "column": 0}, "map": {"version":3,"file":"promises.js","sources":["file:///Users/amansatyawani/Desktop/website-builder/node_modules/.pnpm/inngest%403.45.1_%40opentelemetry%2Bcore%402.2.0_%40opentelemetry%2Bapi%401.9.0__express%405.1.0_next%401_e029d374516642dd9a767b32fbb0beec/node_modules/src/helpers/promises.ts"],"sourcesContent":["import type { MaybePromise } from \"./types.ts\";\n\n/**\n * Some environments don't allow access to the global queueMicrotask(). While we\n * had assumed this was only true for those powered by earlier versions of Node\n * (<14) that we don't officially support, Vercel's Edge Functions also obscure\n * the function in dev, even though the platform it's based on (Cloudflare\n * Workers) appropriately exposes it. Even worse, production Vercel Edge\n * Functions can see the function, but it immediately blows up the function when\n * used.\n *\n * Therefore, we can fall back to a reasonable alternative of\n * `Promise.resolve().then(fn)` instead. This _may_ be slightly slower in modern\n * environments, but at least we can still work in these environments.\n */\nconst shimQueueMicrotask = (callback: () => void): void => {\n  void Promise.resolve().then(callback);\n};\n\n/**\n * A helper function to create a `Promise` that will never settle.\n *\n * It purposefully creates no references to `resolve` or `reject` so that the\n * returned `Promise` will remain unsettled until it falls out of scope and is\n * garbage collected.\n *\n * This should be used within transient closures to fake asynchronous action, so\n * long as it's guaranteed that they will fall out of scope.\n */\nexport const createFrozenPromise = (): Promise<unknown> => {\n  return new Promise(() => undefined);\n};\n\n/**\n * Returns a Promise that resolves after the current event loop's microtasks\n * have finished, but before the next event loop tick.\n */\nexport const resolveAfterPending = (count = 100): Promise<void> => {\n  /**\n   * This uses a brute force implementation that will continue to enqueue\n   * microtasks 10 times before resolving. This is to ensure that the microtask\n   * queue is drained, even if the microtask queue is being manipulated by other\n   * code.\n   *\n   * While this still doesn't guarantee that the microtask queue is drained,\n   * it's our best bet for giving other non-controlled promises a chance to\n   * resolve before we continue without resorting to falling in to the next\n   * tick.\n   */\n  return new Promise((resolve) => {\n    let i = 0;\n\n    const iterate = () => {\n      shimQueueMicrotask(() => {\n        if (i++ > count) {\n          return resolve();\n        }\n\n        iterate();\n      });\n    };\n\n    iterate();\n  });\n};\n\ntype DeferredPromiseReturn<T> = {\n  promise: Promise<T>;\n  resolve: (value: T) => DeferredPromiseReturn<T>;\n  // biome-ignore lint/suspicious/noExplicitAny: <explanation>\n  reject: (reason: any) => DeferredPromiseReturn<T>;\n};\n\n/**\n * Creates and returns Promise that can be resolved or rejected with the\n * returned `resolve` and `reject` functions.\n *\n * Resolving or rejecting the function will return a new set of Promise control\n * functions. These can be ignored if the original Promise is all that's needed.\n */\nexport const createDeferredPromise = <T>(): DeferredPromiseReturn<T> => {\n  let resolve: DeferredPromiseReturn<T>[\"resolve\"];\n  let reject: DeferredPromiseReturn<T>[\"reject\"];\n\n  const promise = new Promise<T>((_resolve, _reject) => {\n    resolve = (value: T) => {\n      _resolve(value);\n      return createDeferredPromise<T>();\n    };\n\n    reject = (reason) => {\n      _reject(reason);\n      return createDeferredPromise<T>();\n    };\n  });\n\n  return { promise, resolve: resolve!, reject: reject! };\n};\n\n/**\n * Creates and returns a deferred Promise that can be resolved or rejected with\n * the returned `resolve` and `reject` functions.\n *\n * For each Promise resolved or rejected this way, this will also keep a stack\n * of all unhandled Promises, resolved or rejected.\n *\n * Once a Promise is read, it is removed from the stack.\n */\nexport const createDeferredPromiseWithStack = <T>(): {\n  deferred: DeferredPromiseReturn<T>;\n  results: AsyncGenerator<Awaited<T>, void, void>;\n} => {\n  const settledPromises: Promise<T>[] = [];\n  // biome-ignore lint/suspicious/noConfusingVoidType: <explanation>\n  let rotateQueue: (value: void) => void = () => {};\n\n  const results = (async function* () {\n    while (true) {\n      const next = settledPromises.shift();\n\n      if (next) {\n        yield next;\n      } else {\n        await new Promise<void>((resolve) => {\n          rotateQueue = resolve;\n        });\n      }\n    }\n  })();\n\n  const shimDeferredPromise = (deferred: DeferredPromiseReturn<T>) => {\n    const originalResolve = deferred.resolve;\n    const originalReject = deferred.reject;\n\n    deferred.resolve = (value: T) => {\n      settledPromises.push(deferred.promise);\n      rotateQueue();\n      return shimDeferredPromise(originalResolve(value));\n    };\n\n    deferred.reject = (reason) => {\n      settledPromises.push(deferred.promise);\n      rotateQueue();\n      return shimDeferredPromise(originalReject(reason));\n    };\n\n    return deferred;\n  };\n\n  const deferred = shimDeferredPromise(createDeferredPromise<T>());\n\n  return { deferred, results };\n};\n\ninterface TimeoutPromise extends Promise<void> {\n  /**\n   * Starts the timeout. If the timer is already started, this does nothing.\n   *\n   * @returns The promise that will resolve when the timeout expires.\n   */\n  start: () => TimeoutPromise;\n\n  /**\n   * Clears the timeout.\n   */\n  clear: () => void;\n\n  /**\n   * Clears the timeout and starts it again.\n   *\n   * @returns The promise that will resolve when the timeout expires.\n   */\n  reset: () => TimeoutPromise;\n}\n\n/**\n * Creates a Promise that will resolve after the given duration, along with\n * methods to start, clear, and reset the timeout.\n */\nexport const createTimeoutPromise = (duration: number): TimeoutPromise => {\n  const { promise, resolve } = createDeferredPromise<void>();\n\n  let timeout: ReturnType<typeof setTimeout> | undefined;\n  // biome-ignore lint/style/useConst: <explanation>\n  let ret: TimeoutPromise;\n\n  const start = () => {\n    if (timeout) return ret;\n\n    timeout = setTimeout(() => {\n      resolve();\n    }, duration);\n\n    return ret;\n  };\n\n  const clear = () => {\n    clearTimeout(timeout);\n    timeout = undefined;\n  };\n\n  const reset = () => {\n    clear();\n    return start();\n  };\n\n  ret = Object.assign(promise, { start, clear, reset });\n\n  return ret;\n};\n\n/**\n * Take any function and safely promisify such that both synchronous and\n * asynchronous errors are caught and returned as a rejected Promise.\n *\n * The passed `fn` can be undefined to support functions that may conditionally\n * be defined.\n */\n// biome-ignore lint/suspicious/noExplicitAny: <explanation>\nexport const runAsPromise = <T extends (() => any) | undefined>(\n  fn: T,\n  // biome-ignore lint/suspicious/noExplicitAny: <explanation>\n): Promise<T extends () => any ? Awaited<ReturnType<T>> : T> => {\n  return Promise.resolve().then(fn);\n};\n\n/**\n * Returns a Promise that resolve after the current event loop tick.\n */\nexport const resolveNextTick = (): Promise<void> => {\n  return new Promise((resolve) => setTimeout(resolve));\n};\n\nexport const retryWithBackoff = async <T>(\n  fn: () => MaybePromise<T>,\n  opts?: {\n    maxAttempts?: number;\n    baseDelay?: number;\n  },\n): Promise<T> => {\n  const maxAttempts = opts?.maxAttempts || 5;\n  const baseDelay = opts?.baseDelay ?? 100;\n\n  for (let attempt = 1; attempt <= maxAttempts; attempt++) {\n    try {\n      return await fn();\n    } catch (err) {\n      if (attempt >= maxAttempts) {\n        throw err;\n      }\n\n      const jitter = Math.random() * baseDelay;\n      const delay = baseDelay * Math.pow(2, attempt - 1) + jitter;\n      await new Promise((resolve) => setTimeout(resolve, delay));\n    }\n  }\n\n  throw new Error(\"Max retries reached; this should be unreachable.\");\n};\n"],"names":["resolve: DeferredPromiseReturn<T>[\"resolve\"]","reject: DeferredPromiseReturn<T>[\"reject\"]","settledPromises: Promise<T>[]","rotateQueue: (value: void) => void","timeout: ReturnType<typeof setTimeout> | undefined","ret: TimeoutPromise"],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2027, "column": 0}, "map": {"version":3,"file":"RetryAfterError.js","sources":["file:///Users/amansatyawani/Desktop/website-builder/node_modules/.pnpm/inngest%403.45.1_%40opentelemetry%2Bcore%402.2.0_%40opentelemetry%2Bapi%401.9.0__express%405.1.0_next%401_e029d374516642dd9a767b32fbb0beec/node_modules/src/components/RetryAfterError.ts"],"sourcesContent":["import ms from \"ms\";\n\n/**\n * An error that, when thrown, indicates to Inngest that the function should be\n * retried after a given amount of time.\n *\n * A `message` must be provided, as well as a `retryAfter` parameter, which can\n * be a `number` of milliseconds, an `ms`-compatible time string, or a `Date`.\n *\n * An optional `cause` can be provided to provide more context to the error.\n *\n * @public\n */\nexport class RetryAfterError extends Error {\n  /**\n   * The underlying cause of the error, if any.\n   *\n   * This will be serialized and sent to Inngest.\n   */\n  public override readonly cause?: unknown;\n\n  /**\n   * The time after which the function should be retried. Represents either a\n   * number of milliseconds or a RFC3339 date.\n   */\n  public readonly retryAfter: string;\n\n  constructor(\n    message: string,\n\n    /**\n     * The time after which the function should be retried. Represents either a\n     * number of milliseconds or a RFC3339 date.\n     */\n    retryAfter: number | string | Date,\n\n    options?: {\n      /**\n       * The underlying cause of the error, if any.\n       *\n       * This will be serialized and sent to Inngest.\n       */\n      cause?: unknown;\n    },\n  ) {\n    super(message);\n\n    if (retryAfter instanceof Date) {\n      this.retryAfter = retryAfter.toISOString();\n    } else {\n      const seconds = `${Math.ceil(\n        (typeof retryAfter === \"string\"\n          ? ms(retryAfter as `${number}`)\n          : retryAfter) / 1000,\n      )}`;\n\n      if (!isFinite(Number(seconds))) {\n        throw new Error(\n          \"retryAfter must be a number of milliseconds, a ms-compatible string, or a Date\",\n        );\n      }\n\n      this.retryAfter = seconds;\n    }\n\n    this.cause = options?.cause;\n  }\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;GAaA,IAAa,kBAAb,cAAqC,MAAM;;;;;IAMhB,MAAA;;;;IAMT,WAAA;IAEhB,YACE,OAAA,EAMA,UAAA,EAEA,OAAA,CAQA;QACA,KAAA,CAAM,QAAQ;QAEd,IAAI,sBAAsB,KACxB,CAAA,IAAA,CAAK,UAAA,GAAa,WAAW,WAAA,EAAa;aACrC;YACL,MAAM,UAAU,GAAG,KAAK,IAAA,CAAA,CACrB,OAAO,eAAe,4LACnB,UAAA,EAAG,WAA0B,GAC7B,UAAA,IAAc,IACnB,EAAA;YAED,IAAI,CAAC,SAAS,OAAO,QAAQ,CAAC,CAC5B,CAAA,MAAM,IAAI,MACR,iFACD;YAGH,IAAA,CAAK,UAAA,GAAa;;QAGpB,IAAA,CAAK,KAAA,GAAQ,SAAS","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2072, "column": 0}, "map": {"version":3,"file":"als.js","sources":["file:///Users/amansatyawani/Desktop/website-builder/node_modules/.pnpm/inngest%403.45.1_%40opentelemetry%2Bcore%402.2.0_%40opentelemetry%2Bapi%401.9.0__express%405.1.0_next%401_e029d374516642dd9a767b32fbb0beec/node_modules/src/components/execution/als.ts"],"sourcesContent":["import type { Context, StepOptions } from \"../../types.ts\";\nimport type { Inngest } from \"../Inngest.ts\";\nimport type { IInngestExecution } from \"./InngestExecution.ts\";\n\n/**\n * Note - this structure can be used by other libraries, so cannot have breaking changes.\n */\nexport interface AsyncContext {\n  /**\n   * The Inngest App that is currently being used to execute the function.\n   *\n   * If this is defined, we are in the context of an Inngest function execution,\n   * or a possible one.\n   */\n  app: Inngest.Like;\n\n  /**\n   * Details of the current function execution context. If this doesn't exist,\n   * then we're not currently in a function execution context.\n   */\n  execution?: {\n    /**\n     * The execution instance that is currently running the function.\n     */\n    instance: IInngestExecution;\n\n    /**\n     * The `ctx` object that has been passed in to this function execution,\n     * including values such as `step` and `event`.\n     */\n    ctx: Context.Any;\n\n    /**\n     * If present, this indicates we are currently executing a `step.run()` step's\n     * callback. Useful to understand whether we are in the context of a step\n     * execution or within the main function body.\n     */\n    executingStep?: StepOptions;\n  };\n}\n\n/**\n * A local-only symbol used as a key in global state to store the async local\n * storage instance.\n */\nconst alsSymbol = Symbol.for(\"inngest:als\");\n\n/**\n * A type that represents a partial, runtime-agnostic interface of\n * `AsyncLocalStorage`.\n */\ntype AsyncLocalStorageIsh = {\n  getStore: () => AsyncContext | undefined;\n  run: <R>(store: AsyncContext, fn: () => R) => R;\n};\n\n/**\n * Retrieve the async context for the current execution.\n */\nexport const getAsyncCtx = async (): Promise<AsyncContext | undefined> => {\n  return getAsyncLocalStorage().then((als) => als.getStore());\n};\n\n/**\n * Get a singleton instance of `AsyncLocalStorage` used to store and retrieve\n * async context for the current execution.\n */\nexport const getAsyncLocalStorage = async (): Promise<AsyncLocalStorageIsh> => {\n  (globalThis as Record<string | symbol | number, unknown>)[alsSymbol] ??=\n    new Promise<AsyncLocalStorageIsh>(async (resolve) => {\n      try {\n        const { AsyncLocalStorage } = await import(\"node:async_hooks\");\n\n        resolve(new AsyncLocalStorage<AsyncContext>());\n      } catch (_err) {\n        console.warn(\n          \"node:async_hooks is not supported in this runtime. Experimental async context is disabled.\",\n        );\n\n        resolve({\n          getStore: () => undefined,\n          run: (_, fn) => fn(),\n        });\n      }\n    });\n\n  return (globalThis as Record<string | symbol | number, unknown>)[\n    alsSymbol\n  ] as Promise<AsyncLocalStorageIsh>;\n};\n"],"names":[],"mappings":";;;;;;;;AA6CA,MAAM,YAAY,OAAO,GAAA,CAAI,cAAc;;;GAc3C,MAAa,cAAc,YAA+C;IACxE,OAAO,sBAAsB,CAAC,IAAA,CAAA,CAAM,MAAQ,IAAI,QAAA,EAAU,CAAC;;;;;GAO7D,MAAa,uBAAuB,YAA2C;IAC5E,UAAA,CAAyD,UAAA,KACxD,IAAI,QAA8B,OAAO,YAAY;QACnD,IAAI;YACF,MAAM,EAAE,iBAAA,EAAA,GAAsB,MAAM,OAAO;YAE3C,QAAQ,IAAI,mBAAiC,CAAC;iBACvC,MAAM;YACb,QAAQ,IAAA,CACN,6FACD;YAED,QAAQ;gBACN,UAAA,IAAgB,KAAA;gBAChB,KAAA,CAAM,GAAG,KAAO,IAAI;aACrB,CAAC;;MAEJ;IAEJ,OAAQ,UAAA,CACN,UAAA","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2112, "column": 0}, "map": {"version":3,"file":"temporal.js","sources":["file:///Users/amansatyawani/Desktop/website-builder/node_modules/.pnpm/inngest%403.45.1_%40opentelemetry%2Bcore%402.2.0_%40opentelemetry%2Bapi%401.9.0__express%405.1.0_next%401_e029d374516642dd9a767b32fbb0beec/node_modules/src/helpers/temporal.ts"],"sourcesContent":["import type { Temporal } from \"temporal-polyfill\";\n\n/**\n * A type that represents a `Temporal.Instant` object.\n *\n * `*Like` types are available for many temporal objects, but not all of them.\n * Also, the `*Like` types can sometimes be linked to particular\n * implementations, and are not stable between them.\n *\n * Therefore, we try to detect only the hopefully-stable branding.\n */\nexport type InstantLike = {\n  readonly [Symbol.toStringTag]: \"Temporal.Instant\";\n};\n\n/**\n * A type that represents a `Temporal.Duration` object.\n *\n * `*Like` types are available for many temporal objects, but not all of them.\n * Also, the `*Like` types can sometimes be linked to particular\n * implementations, and are not stable between them.\n *\n * Therefore, we try to detect only the hopefully-stable branding.\n */\nexport type DurationLike = {\n  readonly [Symbol.toStringTag]: \"Temporal.Duration\";\n};\n\n/**\n * A type that represents a `Temporal.ZonedDateTime` object.\n *\n * `*Like` types are available for many temporal objects, but not all of them.\n * Also, the `*Like` types can sometimes be linked to particular\n * implementations, and are not stable between them.\n *\n * Therefore, we try to detect only the hopefully-stable branding.\n */\nexport type ZonedDateTimeLike = {\n  readonly [Symbol.toStringTag]: \"Temporal.ZonedDateTime\";\n};\n\n/**\n * Asserts that the given `input` is a `Temporal.Duration` object.\n */\nexport const isTemporalDuration = (\n  /**\n   * The input to check.\n   */\n  input: unknown,\n): input is Temporal.Duration => {\n  try {\n    // biome-ignore lint/suspicious/noExplicitAny: Safe access as we're catching\n    return (input as any)[Symbol.toStringTag] === \"Temporal.Duration\";\n  } catch {\n    return false;\n  }\n};\n\n/**\n * Asserts that the given `input` is a `Temporal.TimeZone` object.\n */\nexport const isTemporalInstant = (\n  /**\n   * The input to check.\n   */\n  input: unknown,\n): input is Temporal.Instant => {\n  try {\n    // biome-ignore lint/suspicious/noExplicitAny: Safe access as we're catching\n    return (input as any)[Symbol.toStringTag] === \"Temporal.Instant\";\n  } catch {\n    return false;\n  }\n};\n\n/**\n * Asserts that the given `input` is a `Temporal.ZonedDateTime` object.\n */\nexport const isTemporalZonedDateTime = (\n  /**\n   * The input to check.\n   */\n  input: unknown,\n): input is Temporal.ZonedDateTime => {\n  try {\n    // biome-ignore lint/suspicious/noExplicitAny: Safe access as we're catching\n    return (input as any)[Symbol.toStringTag] === \"Temporal.ZonedDateTime\";\n  } catch {\n    return false;\n  }\n};\n\n/**\n * Converts a given `Date`, `string`, `Temporal.Instant`, or\n * `Temporal.ZonedDateTime` to an ISO 8601 string.\n */\nexport const getISOString = (\n  time: Date | string | InstantLike | ZonedDateTimeLike,\n): string => {\n  if (typeof time === \"string\") {\n    return new Date(time).toISOString();\n  }\n\n  if (time instanceof Date) {\n    return time.toISOString();\n  }\n\n  if (isTemporalZonedDateTime(time)) {\n    return time.toInstant().toString();\n  }\n\n  if (isTemporalInstant(time)) {\n    return time.toString();\n  }\n\n  throw new TypeError(\"Invalid date input\");\n};\n"],"names":[],"mappings":";;;;;;;AA4CA,MAAa,qBAAA,CAIX,UAC+B;IAC/B,IAAI;QAEF,OAAQ,KAAA,CAAc,OAAO,WAAA,CAAA,KAAiB;aACxC;QACN,OAAO;;;;;GAOX,MAAa,oBAAA,CAIX,UAC8B;IAC9B,IAAI;QAEF,OAAQ,KAAA,CAAc,OAAO,WAAA,CAAA,KAAiB;aACxC;QACN,OAAO;;;;;GAOX,MAAa,0BAAA,CAIX,UACoC;IACpC,IAAI;QAEF,OAAQ,KAAA,CAAc,OAAO,WAAA,CAAA,KAAiB;aACxC;QACN,OAAO;;;;;;GAQX,MAAa,eAAA,CACX,SACW;IACX,IAAI,OAAO,SAAS,SAClB,CAAA,OAAO,IAAI,KAAK,KAAK,CAAC,WAAA,EAAa;IAGrC,IAAI,gBAAgB,KAClB,CAAA,OAAO,KAAK,WAAA,EAAa;IAG3B,IAAI,wBAAwB,KAAK,CAC/B,CAAA,OAAO,KAAK,SAAA,EAAW,CAAC,QAAA,EAAU;IAGpC,IAAI,kBAAkB,KAAK,CACzB,CAAA,OAAO,KAAK,QAAA,EAAU;IAGxB,MAAM,IAAI,UAAU,qBAAqB","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2162, "column": 0}, "map": {"version":3,"file":"Fetch.js","sources":["file:///Users/amansatyawani/Desktop/website-builder/node_modules/.pnpm/inngest%403.45.1_%40opentelemetry%2Bcore%402.2.0_%40opentelemetry%2Bapi%401.9.0__express%405.1.0_next%401_e029d374516642dd9a767b32fbb0beec/node_modules/src/components/Fetch.ts"],"sourcesContent":["import Debug from \"debug\";\nimport type { Simplify } from \"../helpers/types.ts\";\nimport { getAsyncCtx } from \"./execution/als.ts\";\nimport { gatewaySymbol, type InternalStepTools } from \"./InngestStepTools.ts\";\n\nconst globalFetch = globalThis.fetch;\ntype Fetch = typeof globalFetch;\n\nexport type StepFetch = Fetch &\n  Simplify<\n    {\n      config: (options: StepFetch.Options) => StepFetch;\n    } & Readonly<StepFetch.Options>\n  >;\n\nexport namespace StepFetch {\n  export interface Options {\n    fallback?: Fetch | undefined;\n  }\n\n  export interface Extras extends Options {\n    config: (options: Options) => StepFetch;\n  }\n}\n\nconst debug = Debug(\"inngest:fetch\");\n\nconst createFetchShim = (): StepFetch => {\n  // biome-ignore lint/style/useConst: need this to allow fns to be defined\n  let stepFetch: StepFetch;\n\n  const fetch: Fetch = async (input, init) => {\n    const ctx = await getAsyncCtx();\n    if (!ctx?.execution) {\n      // Not in a function run\n      if (!stepFetch.fallback) {\n        // TODO Tell the user how to solve\n        throw new Error(\n          \"step.fetch() called outside of a function and had no fallback set\",\n        );\n      }\n\n      debug(\n        \"step.fetch() called outside of a function; falling back to global fetch\",\n      );\n\n      return stepFetch.fallback(input, init);\n    }\n\n    // In a function run\n    if (ctx.execution.executingStep) {\n      // Inside a step\n      if (!stepFetch.fallback) {\n        // TODO Tell the user how to solve\n        throw new Error(\n          `step.fetch() called inside step \"${ctx.execution.executingStep.id}\" and had no fallback set`,\n        );\n      }\n\n      debug(\n        `step.fetch() called inside step \"${ctx.execution.executingStep.id}\"; falling back to global fetch`,\n      );\n\n      return stepFetch.fallback(input, init);\n    }\n\n    // TODO Do we need to make this better with deferred (global) step tooling?\n    // hmmmmm\n\n    const targetUrl = new URL(\n      input instanceof Request ? input.url : input.toString(),\n    );\n\n    debug(\"step.fetch() shimming request to\", targetUrl.hostname);\n\n    // Purposefully do not try/cacth this; if it throws then we treat that as a\n    // regular `fetch()` throw, which also would not return a `Response`.\n    const jsonRes = await (ctx.execution.ctx.step as InternalStepTools)[\n      gatewaySymbol\n    ](`step.fetch: ${targetUrl.hostname}`, input, init);\n\n    return new Response(jsonRes.body, {\n      headers: jsonRes.headers,\n      status: jsonRes.status,\n    });\n  };\n\n  const optionsRef: StepFetch.Options = {\n    fallback: globalFetch,\n  };\n\n  const extras: StepFetch.Extras = {\n    config: (options) => {\n      Object.assign(optionsRef, options);\n      Object.assign(stepFetch, optionsRef);\n\n      return stepFetch;\n    },\n    ...optionsRef,\n  };\n\n  stepFetch = Object.assign(fetch, extras);\n\n  return stepFetch;\n};\n\n/**\n * `fetch` is a Fetch API-compatible function that can be used to make any HTTP\n * code durable if it's called within an Inngest function.\n *\n * It will gracefully fall back to the global `fetch` if called outside of this\n * context, and a custom fallback can be set using the `config` method.\n *\n * @example Basic usage\n * ```ts\n * import { fetch } from \"inngest\";\n *\n * const api = new MyProductApi({ fetch });\n * ```\n *\n * @example Setting a custom fallback\n * ```ts\n * import { fetch } from \"inngest\";\n *\n * const api = new MyProductApi({\n *            fetch: fetch.config({ fallback: myCustomFetch }),\n * });\n * ```\n *\n * @example Do not allow fallback\n * ```ts\n * import { fetch } from \"inngest\";\n *\n * const api = new MyProductApi({\n *            fetch: fetch.config({ fallback: undefined }),\n * });\n * ```\n */\nexport const fetch = createFetchShim();\n"],"names":["debug","Debug","stepFetch: StepFetch","fetch: Fetch","optionsRef: StepFetch.Options","extras: StepFetch.Extras","fetch"],"mappings":";;;;;;;;;;AAKA,MAAM,cAAc,WAAW,KAAA;AAoB/B,MAAMA,wMAAQC,UAAAA,EAAM,gBAAgB;AAEpC,MAAM,kBAAA,MAAmC;IAEvC,IAAIC;IAEJ,MAAMC,UAAe,OAAO,OAAO,SAAS;QAC1C,MAAM,MAAM,kXAAM,cAAA,EAAa;QAC/B,IAAI,CAAC,KAAK,WAAW;YAEnB,IAAI,CAAC,UAAU,QAAA,CAEb,CAAA,MAAM,IAAI,MACR,oEACD;YAGH,QACE,0EACD;YAED,OAAO,UAAU,QAAA,CAAS,OAAO,KAAK;;QAIxC,IAAI,IAAI,SAAA,CAAU,aAAA,EAAe;YAE/B,IAAI,CAAC,UAAU,QAAA,CAEb,CAAA,MAAM,IAAI,MACR,CAAA,iCAAA,EAAoC,IAAI,SAAA,CAAU,aAAA,CAAc,EAAA,CAAG,yBAAA,CAAA,CACpE;YAGH,QACE,CAAA,iCAAA,EAAoC,IAAI,SAAA,CAAU,aAAA,CAAc,EAAA,CAAG,+BAAA,CAAA,CACpE;YAED,OAAO,UAAU,QAAA,CAAS,OAAO,KAAK;;QAMxC,MAAM,YAAY,IAAI,IACpB,iBAAiB,UAAU,MAAM,GAAA,GAAM,MAAM,QAAA,EAAU,CACxD;QAED,QAAM,oCAAoC,UAAU,QAAA,CAAS;QAI7D,MAAM,UAAU,MAAO,IAAI,SAAA,CAAU,GAAA,CAAI,IAAA,yWACvC,gBAAA,CAAA,CACA,CAAA,YAAA,EAAe,UAAU,QAAA,EAAA,EAAY,OAAO,KAAK;QAEnD,OAAO,IAAI,SAAS,QAAQ,IAAA,EAAM;YAChC,SAAS,QAAQ,OAAA;YACjB,QAAQ,QAAQ,MAAA;SACjB,CAAC;;IAGJ,MAAMC,aAAgC;QACpC,UAAU;IAAA,CACX;IAED,MAAMC,SAA2B;QAC/B,QAAA,CAAS,YAAY;YACnB,OAAO,MAAA,CAAO,YAAY,QAAQ;YAClC,OAAO,MAAA,CAAO,WAAW,WAAW;YAEpC,OAAO;;QAET,GAAG,UAAA;KACJ;IAED,YAAY,OAAO,MAAA,CAAOC,SAAO,OAAO;IAExC,OAAO;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAmCT,MAAa,QAAQ,iBAAiB","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2250, "column": 0}, "map": {"version":3,"file":"InngestFunctionReference.js","sources":["file:///Users/amansatyawani/Desktop/website-builder/node_modules/.pnpm/inngest%403.45.1_%40opentelemetry%2Bcore%402.2.0_%40opentelemetry%2Bapi%401.9.0__express%405.1.0_next%401_e029d374516642dd9a767b32fbb0beec/node_modules/src/components/InngestFunctionReference.ts"],"sourcesContent":["import type { IsAny, Simplify } from \"../helpers/types.ts\";\nimport type {\n  ResolveSchema,\n  ValidSchemaInput,\n  ValidSchemaOutput,\n} from \"../helpers/validators/index.ts\";\nimport type {\n  MinimalEventPayload,\n  PayloadForAnyInngestFunction,\n} from \"../types.ts\";\nimport type { GetFunctionOutput } from \"./Inngest.ts\";\nimport type { InngestFunction } from \"./InngestFunction.ts\";\n\n/**\n * A reference to an `InngestFunction` that can be used to represent both local\n * and remote functions without pulling in the full function definition (i.e.\n * dependencies).\n *\n * These references can be invoked in the same manner as a regular\n * `InngestFunction`.\n *\n * To create a reference function, use the {@link referenceFunction} helper.\n *\n * @public\n */\nexport class InngestFunctionReference<\n  /**\n   * The payload expected by the referenced function.\n   *\n   * Must be in the shape of an event payload.\n   */\n  _TInput extends MinimalEventPayload,\n  /**\n   * The output of the referenced function.\n   */\n  _TOutput,\n> {\n  get [Symbol.toStringTag](): typeof InngestFunctionReference.Tag {\n    return InngestFunctionReference.Tag;\n  }\n\n  constructor(public readonly opts: { functionId: string; appId?: string }) {}\n}\n\n/**\n * Create a reference to an `InngestFunction` that can be used to represent both\n * local and remote functions without pulling in the full function definition\n * (i.e. dependencies).\n *\n * These references can be invoked in the same manner as a regular\n * `InngestFunction`.\n *\n * @public\n */\nexport const referenceFunction = <\n  TArgs extends InngestFunctionReference.HelperGenericArgs<TFnInput, TFnOutput>,\n  TFnInput extends ValidSchemaInput = ValidSchemaInput,\n  TFnOutput extends ValidSchemaOutput = ValidSchemaOutput,\n>({\n  functionId,\n  appId,\n}: TArgs extends InngestFunction.Any\n  ? // biome-ignore lint/suspicious/noExplicitAny: <explanation>\n    Omit<InngestFunctionReference.HelperArgs<any, any>, \"schemas\">\n  : TArgs): InngestFunctionReference.HelperReturn<TArgs> => {\n  return new InngestFunctionReference({\n    functionId,\n    appId,\n  }) as InngestFunctionReference.HelperReturn<TArgs>;\n};\n\n/**\n * A reference to an `InngestFunction` that can be used to represent both local\n * and remote functions without pulling in the full function definition (i.e.\n * dependencies).\n *\n * These references can be invoked in the same manner as a regular\n * `InngestFunction`.\n *\n * To create a reference function, use the {@link referenceFunction} helper.\n *\n * @public\n */\nexport namespace InngestFunctionReference {\n  export const Tag = \"Inngest.FunctionReference\" as const;\n\n  /**\n   * Represents any `InngestFunctionReference`.\n   *\n   * @public\n   */\n  export type Any = InngestFunctionReference<\n    MinimalEventPayload,\n    // biome-ignore lint/suspicious/noExplicitAny: <explanation>\n    any\n  >;\n\n  export interface Like {\n    readonly [Symbol.toStringTag]: typeof InngestFunctionReference.Tag;\n  }\n\n  /**\n   * Arguments used by {@link referenceFunction} to create a reference to an\n   * `InngestFunction`.\n   *\n   * @public\n   */\n  export type HelperArgs<TFnInput, TFnOutput> = {\n    /**\n     * The ID of the function to reference. This can be either a local function\n     * ID or the ID of a function that exists in another app.\n     *\n     * If the latter, `appId` must also be provided. If `appId` is not provided,\n     * the function ID will be assumed to be a local function ID (the app ID of\n     * the calling app will be used).\n     */\n    functionId: string;\n\n    /**\n     * The ID of the app that the function belongs to. This is only required if\n     * the function being referenced exists in another app.\n     */\n    appId?: string;\n\n    /**\n     * The schemas of the referenced function, providing typing to the input\n     * `data` and `return` of invoking the referenced function.\n     *\n     * If not provided and a local function type is not being passed as a\n     * generic into {@link referenceFunction}, the schemas will be inferred as\n     * `unknown`.\n     */\n    schemas?: {\n      data?: TFnInput;\n      return?: TFnOutput;\n    };\n  };\n\n  /**\n   * A helper type that allows the passing of either `HelperArgs` or\n   * `InngestFunction.Any` to the {@link referenceFunction} generic in place of\n   * inferring options.\n   *\n   * This is used along with defaults to allow a generic to be passed by the\n   * user and still infer the correct types for other arguments being passed in.\n   *\n   * @public\n   */\n  export type HelperGenericArgs<TFnInput, TFnOutput> =\n    | HelperArgs<TFnInput, TFnOutput>\n    | InngestFunction.Any;\n\n  /**\n   * Given a set of `InngestFunctionReference.ConstructorArgs`, return an\n   * `InngestFunctionReference`. Also handles the manual passing of\n   * `InngestFunction.Any` to the {@link referenceFunction} generic in place\n   * of inferring options.\n   *\n   * @public\n   */\n  export type HelperReturn<TArgs> = TArgs extends InngestFunction.Any\n    ? InngestFunctionReference<\n        PayloadForAnyInngestFunction<TArgs>,\n        GetFunctionOutput<TArgs>\n      >\n    : TArgs extends HelperArgs<infer TFnInput, infer TFnOutput>\n      ? InngestFunctionReference<\n          // biome-ignore lint/suspicious/noExplicitAny: <explanation>\n          IsAny<ResolveSchema<TFnInput, TFnInput, any>> extends true\n            ? MinimalEventPayload\n            : Simplify<\n                // biome-ignore lint/suspicious/noExplicitAny: <explanation>\n                MinimalEventPayload<ResolveSchema<TFnInput, TFnInput, any>> &\n                  Required<\n                    Pick<\n                      MinimalEventPayload<\n                        // biome-ignore lint/suspicious/noExplicitAny: <explanation>\n                        ResolveSchema<TFnInput, TFnInput, any>\n                      >,\n                      \"data\"\n                    >\n                  >\n              >,\n          ResolveSchema<TFnOutput, TFnOutput, unknown>\n        >\n      : never;\n}\n"],"names":["opts: { functionId: string; appId?: string }"],"mappings":";;;;;;;;;;;;;;;;AAyBA,IAAa,2BAAb,MAAa,yBAWX;IACA,IAAA,CAAK,OAAO,WAAA,CAAA,GAAoD;QAC9D,OAAO,yBAAyB,GAAA;;IAGlC,YAA4BA,IAAAA,CAA8C;QAA9C,IAAA,CAAA,IAAA,GAAA;;;;;;;;;;;;GAa9B,MAAa,oBAAA,CAIX,EACA,UAAA,EACA,KAAA,EAAA,KAI0D;IAC1D,OAAO,IAAI,yBAAyB;QAClC;QACA;KACD,CAAC;;;oCAgBiB","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2300, "column": 0}, "map": {"version":3,"file":"InngestStepTools.js","sources":["file:///Users/amansatyawani/Desktop/website-builder/node_modules/.pnpm/inngest%403.45.1_%40opentelemetry%2Bcore%402.2.0_%40opentelemetry%2Bapi%401.9.0__express%405.1.0_next%401_e029d374516642dd9a767b32fbb0beec/node_modules/src/components/InngestStepTools.ts"],"sourcesContent":["import { type AiAdapter, models } from \"@inngest/ai\";\nimport { z } from \"zod/v3\";\nimport { getAsyncCtx } from \"../experimental\";\nimport { logPrefix } from \"../helpers/consts.ts\";\nimport type { Jsonify } from \"../helpers/jsonify.ts\";\nimport { timeStr } from \"../helpers/strings.ts\";\nimport * as Temporal from \"../helpers/temporal.ts\";\nimport type {\n  ExclusiveKeys,\n  ParametersExceptFirst,\n  SendEventPayload,\n  SimplifyDeep,\n  WithoutInternalStr,\n} from \"../helpers/types.ts\";\nimport {\n  type EventPayload,\n  type HashedOp,\n  type InvocationResult,\n  type InvokeTargetFunctionDefinition,\n  type MinimalEventPayload,\n  type SendEventOutput,\n  StepMode,\n  StepOpCode,\n  type StepOptions,\n  type StepOptionsOrId,\n  type TriggerEventFromFunction,\n  type TriggersFromClient,\n} from \"../types.ts\";\nimport type { InngestExecution } from \"./execution/InngestExecution.ts\";\nimport { fetch as stepFetch } from \"./Fetch.ts\";\nimport type {\n  ClientOptionsFromInngest,\n  GetEvents,\n  GetFunctionOutput,\n  GetStepTools,\n  Inngest,\n} from \"./Inngest.ts\";\nimport { InngestFunction } from \"./InngestFunction.ts\";\nimport { InngestFunctionReference } from \"./InngestFunctionReference.ts\";\n\nexport interface FoundStep extends HashedOp {\n  hashedId: string;\n  fn?: (...args: unknown[]) => unknown;\n  rawArgs: unknown[];\n\n  /**\n   * A boolean representing whether the step has been fulfilled, either\n   * resolving or rejecting the `Promise` returned to userland code.\n   *\n   * Note that this is distinct from {@link hasStepState}, which instead tracks\n   * whether the step has been given some state from the Executor. State from\n   * the Executor could be data other than a resolution or rejection, such as\n   * inputs.\n   */\n  fulfilled: boolean;\n\n  /**\n   * A boolean representing whether the step has been given some state from the\n   * Executor. State from the Executor could be data other than a resolution or\n   * rejection, such as inputs.\n   *\n   * This is distinct from {@link fulfilled}, which instead tracks whether the\n   * step has been fulfilled, either resolving or rejecting the `Promise`\n   * returned to userland code.\n   */\n  hasStepState: boolean;\n\n  handled: boolean;\n\n  /**\n   * The promise that has been returned to userland code for this step.\n   */\n  promise: Promise<unknown>;\n\n  /**\n   * Returns a boolean representing whether or not the step was handled on this\n   * invocation.\n   */\n  handle: () => boolean;\n\n  // TODO This is used to track the input we want for this step. Might be\n  // present in ctx from Executor.\n  input?: unknown;\n}\n\nexport type MatchOpFn<\n  T extends (...args: unknown[]) => Promise<unknown> = (\n    ...args: unknown[]\n  ) => Promise<unknown>,\n> = (\n  stepOptions: StepOptions,\n  /**\n   * Arguments passed by the user.\n   */\n  ...args: ParametersExceptFirst<T>\n) => Omit<HashedOp, \"data\" | \"error\">;\n\nexport type StepHandler = (info: {\n  matchOp: MatchOpFn;\n  opts?: StepToolOptions;\n  args: [StepOptionsOrId, ...unknown[]];\n}) => Promise<unknown>;\n\nexport interface StepToolOptions<\n  T extends (...args: unknown[]) => Promise<unknown> = (\n    ...args: unknown[]\n  ) => Promise<unknown>,\n> {\n  /**\n   * Optionally, we can also provide a function that will be called when\n   * Inngest tells us to run this operation.\n   *\n   * If this function is defined, the first time the tool is used it will\n   * report the desired operation (including options) to the Inngest. Inngest\n   * will then call back to the function to tell it to run the step and then\n   * retrieve data.\n   *\n   * We do this in order to allow functionality such as per-step retries; this\n   * gives the SDK the opportunity to tell Inngest what it wants to do before\n   * it does it.\n   *\n   * This function is passed the arguments passed by the user. It will be run\n   * when we receive an operation matching this one that does not contain a\n   * `data` property.\n   */\n  fn?: (...args: Parameters<T>) => unknown;\n}\n\nexport const getStepOptions = (options: StepOptionsOrId): StepOptions => {\n  if (typeof options === \"string\") {\n    return { id: options };\n  }\n\n  return options;\n};\n\n/**\n * Suffix used to namespace steps that are automatically indexed.\n */\nexport const STEP_INDEXING_SUFFIX = \":\";\n\n/**\n * Create a new set of step function tools ready to be used in a step function.\n * This function should be run and a fresh set of tools provided every time a\n * function is run.\n *\n * An op stack (function state) is passed in as well as some mutable properties\n * that the tools can use to submit a new op.\n */\nexport const createStepTools = <TClient extends Inngest.Any>(\n  client: TClient,\n  execution: InngestExecution,\n  stepHandler: StepHandler,\n) => {\n  /**\n   * A local helper used to create tools that can be used to submit an op.\n   *\n   * When using this function, a generic type should be provided which is the\n   * function signature exposed to the user.\n   */\n  // biome-ignore lint/suspicious/noExplicitAny: <explanation>\n  const createTool = <T extends (...args: any[]) => Promise<unknown>>(\n    /**\n     * A function that returns an ID for this op. This is used to ensure that\n     * the op stack is correctly filled, submitted, and retrieved with the same\n     * ID.\n     *\n     * It is passed the arguments passed by the user.\n     *\n     * Most simple tools will likely only need to define this.\n     */\n    matchOp: MatchOpFn<T>,\n    opts?: StepToolOptions<T>,\n  ): T => {\n    return (async (...args: Parameters<T>): Promise<unknown> => {\n      const parsedArgs = args as unknown as [StepOptionsOrId, ...unknown[]];\n      return stepHandler({ args: parsedArgs, matchOp, opts });\n    }) as T;\n  };\n\n  /**\n   * Create a new step run tool that can be used to run a step function using\n   * `step.run()` as a shim.\n   */\n  const createStepRun = (\n    /**\n     * The sub-type of this step tool, exposed via `opts.type` when the op is\n     * reported.\n     */\n    type?: string,\n  ) => {\n    return createTool<\n      // biome-ignore lint/suspicious/noExplicitAny: <explanation>\n      <TFn extends (...args: any[]) => unknown>(\n        idOrOptions: StepOptionsOrId,\n\n        /**\n         * The function to run when this step is executed. Can be synchronous or\n         * asynchronous.\n         *\n         * The return value of this function will be the return value of this\n         * call to `run`, meaning you can return and reason about return data\n         * for next steps.\n         */\n        fn: TFn,\n\n        /**\n         * Optional input to pass to the function. If this is specified, Inngest\n         * will keep track of the input for this step and be able to display it\n         * in the UI.\n         */\n        ...input: Parameters<TFn>\n      ) => Promise<\n        /**\n         * TODO Middleware can affect this. If run input middleware has returned\n         * new step data, do not Jsonify.\n         */\n        SimplifyDeep<\n          Jsonify<\n            TFn extends (...args: Parameters<TFn>) => Promise<infer U>\n              ? Awaited<U extends void ? null : U>\n              : ReturnType<TFn> extends void\n                ? null\n                : ReturnType<TFn>\n          >\n        >\n      >\n    >(\n      ({ id, name }, _fn, ...input) => {\n        const opts: HashedOp[\"opts\"] = {\n          ...(input.length ? { input } : {}),\n          ...(type ? { type } : {}),\n        };\n\n        return {\n          id,\n          mode: StepMode.Sync,\n          op: StepOpCode.StepPlanned,\n          name: id,\n          displayName: name ?? id,\n          ...(Object.keys(opts).length ? { opts } : {}),\n          userland: { id },\n        };\n      },\n      {\n        fn: (_, fn, ...input) => fn(...input),\n      },\n    );\n  };\n\n  /**\n   * Define the set of tools the user has access to for their step functions.\n   *\n   * Each key is the function name and is expected to run `createTool` and pass\n   * a generic type for that function as it will appear in the user's code.\n   */\n  const tools = {\n    /**\n     * Send one or many events to Inngest. Should always be used in place of\n     * `inngest.send()` to ensure that the event send is successfully retried\n     * and not sent multiple times due to memoisation.\n     *\n     * @example\n     * ```ts\n     * await step.sendEvent(\"emit-user-creation\", {\n     *   name: \"app/user.created\",\n     *   data: { id: 123 },\n     * });\n     *\n     * await step.sendEvent(\"emit-user-updates\", [\n     *   {\n     *     name: \"app/user.created\",\n     *     data: { id: 123 },\n     *   },\n     *   {\n     *     name: \"app/user.feed.created\",\n     *     data: { id: 123 },\n     *   },\n     * ]);\n     * ```\n     *\n     * Returns a promise that will resolve once the event has been sent.\n     */\n    sendEvent: createTool<\n      <Payload extends SendEventPayload<GetEvents<TClient>>>(\n        idOrOptions: StepOptionsOrId,\n        payload: Payload,\n      ) => Promise<SendEventOutput<ClientOptionsFromInngest<TClient>>>\n    >(\n      ({ id, name }) => {\n        return {\n          id,\n          mode: StepMode.Sync,\n          op: StepOpCode.StepPlanned,\n          name: \"sendEvent\",\n          displayName: name ?? id,\n          opts: {\n            type: \"step.sendEvent\",\n          },\n          userland: { id },\n        };\n      },\n      {\n        fn: (_idOrOptions, payload) => {\n          return client[\"_send\"]({\n            payload,\n            headers: execution[\"options\"][\"headers\"],\n          });\n        },\n      },\n    ),\n\n    /**\n     * EXPERIMENTAL: This API is not yet stable and may change in the future\n     * without a major version bump.\n     *\n     * Wait for a particular signal to be received before continuing. When the\n     * signal is received, its data will be returned.\n     */\n    waitForSignal: createTool<\n      <TData>(\n        idOrOptions: StepOptionsOrId,\n        opts: WaitForSignalOpts,\n      ) => Promise<{ signal: string; data: Jsonify<TData> } | null>\n    >(({ id, name }, opts) => {\n      // TODO Should support Temporal.DurationLike, Temporal.InstantLike,\n      // Temporal.ZonedDateTimeLike\n      return {\n        id,\n        mode: StepMode.Async,\n        op: StepOpCode.WaitForSignal,\n        name: opts.signal,\n        displayName: name ?? id,\n        opts: {\n          signal: opts.signal,\n          timeout: timeStr(opts.timeout),\n          conflict: opts.onConflict,\n        },\n        userland: { id },\n      };\n    }),\n\n    /**\n     * Send a Signal to Inngest.\n     */\n    sendSignal: createTool<\n      (idOrOptions: StepOptionsOrId, opts: SendSignalOpts) => Promise<null>\n    >(\n      ({ id, name }, opts) => {\n        return {\n          id,\n          mode: StepMode.Sync,\n          op: StepOpCode.StepPlanned,\n          name: \"sendSignal\",\n          displayName: name ?? id,\n          opts: {\n            type: \"step.sendSignal\",\n            signal: opts.signal,\n          },\n          userland: { id },\n        };\n      },\n      {\n        fn: (_idOrOptions, opts) => {\n          return client[\"_sendSignal\"]({\n            signal: opts.signal,\n            data: opts.data,\n            headers: execution[\"options\"][\"headers\"],\n          });\n        },\n      },\n    ),\n\n    /**\n     * Wait for a particular event to be received before continuing. When the\n     * event is received, it will be returned.\n     *\n     * You can also provide options to control the particular event that is\n     * received, for example to ensure that a user ID matches between two\n     * events, or to only wait a maximum amount of time before giving up and\n     * returning `null` instead of any event data.\n     */\n    waitForEvent: createTool<\n      <IncomingEvent extends WithoutInternalStr<TriggersFromClient<TClient>>>(\n        idOrOptions: StepOptionsOrId,\n        opts: WaitForEventOpts<GetEvents<TClient, true>, IncomingEvent>,\n      ) => Promise<\n        IncomingEvent extends WithoutInternalStr<TriggersFromClient<TClient>>\n          ? GetEvents<TClient, false>[IncomingEvent] | null\n          : IncomingEvent | null\n      >\n    >(\n      (\n        { id, name },\n\n        /**\n         * Options to control the event we're waiting for.\n         */\n        opts,\n      ) => {\n        const matchOpts: { timeout: string; if?: string } = {\n          timeout: timeStr(typeof opts === \"string\" ? opts : opts.timeout),\n        };\n\n        if (typeof opts !== \"string\") {\n          if (opts?.match) {\n            matchOpts.if = `event.${opts.match} == async.${opts.match}`;\n          } else if (opts?.if) {\n            matchOpts.if = opts.if;\n          }\n        }\n\n        return {\n          id,\n          mode: StepMode.Async,\n          op: StepOpCode.WaitForEvent,\n          name: opts.event,\n          opts: matchOpts,\n          displayName: name ?? id,\n          userland: { id },\n        };\n      },\n    ),\n\n    /**\n     * Use this tool to run business logic. Each call to `run` will be retried\n     * individually, meaning you can compose complex workflows that safely\n     * retry dependent asynchronous actions.\n     *\n     * The function you pass to `run` will be called only when this \"step\" is to\n     * be executed and can be synchronous or asynchronous.\n     *\n     * In either case, the return value of the function will be the return value\n     * of the `run` tool, meaning you can return and reason about return data\n     * for next steps.\n     */\n    run: createStepRun(),\n\n    /**\n     * AI tooling for running AI models and other AI-related tasks.\n     */\n    ai: {\n      /**\n       * Use this tool to have Inngest make your AI calls. Useful for agentic workflows.\n       *\n       * Input is also tracked for this tool, meaning you can pass input to the\n       * function and it will be displayed and editable in the UI.\n       */\n      infer: createTool<\n        <TAdapter extends AiAdapter>(\n          idOrOptions: StepOptionsOrId,\n          options: AiInferOpts<TAdapter>,\n        ) => Promise<AiAdapter.Output<TAdapter>>\n      >(({ id, name }, options) => {\n        // eslint-disable-next-line\n        const { model, body, ...rest } = options;\n\n        const modelCopy = { ...model };\n\n        // Allow the model to mutate options and body for this call\n        options.model.onCall?.(modelCopy, options.body);\n\n        return {\n          id,\n          mode: StepMode.Async,\n          op: StepOpCode.AiGateway,\n          displayName: name ?? id,\n          opts: {\n            type: \"step.ai.infer\",\n            url: modelCopy.url,\n            headers: modelCopy.headers,\n            auth_key: modelCopy.authKey,\n            format: modelCopy.format,\n            // eslint-disable-next-line\n            body,\n            // eslint-disable-next-line\n            ...rest,\n          },\n          userland: { id },\n        };\n      }),\n\n      /**\n       * Use this tool to wrap AI models and other AI-related tasks. Each call\n       * to `wrap` will be retried individually, meaning you can compose complex\n       * workflows that safely retry dependent asynchronous actions.\n       *\n       * Input is also tracked for this tool, meaning you can pass input to the\n       * function and it will be displayed and editable in the UI.\n       */\n      wrap: createStepRun(\"step.ai.wrap\"),\n\n      /**\n       * Models for AI inference and other AI-related tasks.\n       */\n      models: {\n        ...models,\n      },\n    },\n\n    /**\n     * Wait a specified amount of time before continuing.\n     *\n     * The time to wait can be specified using a `number` of milliseconds or an\n     * `ms`-compatible time string like `\"1 hour\"`, `\"30 mins\"`, or `\"2.5d\"`.\n     *\n     * {@link https://npm.im/ms}\n     *\n     * To wait until a particular date, use `sleepUntil` instead.\n     */\n    sleep: createTool<\n      (\n        idOrOptions: StepOptionsOrId,\n\n        /**\n         * The amount of time to wait before continuing.\n         */\n        time: number | string | Temporal.DurationLike,\n      ) => Promise<void>\n    >(({ id, name }, time) => {\n      /**\n       * The presence of this operation in the returned stack indicates that the\n       * sleep is over and we should continue execution.\n       */\n      const msTimeStr: string = timeStr(\n        Temporal.isTemporalDuration(time)\n          ? time.total({ unit: \"milliseconds\" })\n          : (time as number | string),\n      );\n\n      return {\n        id,\n        mode: StepMode.Async,\n        op: StepOpCode.Sleep,\n        name: msTimeStr,\n        displayName: name ?? id,\n        userland: { id },\n      };\n    }),\n\n    /**\n     * Wait until a particular date before continuing by passing a `Date`.\n     *\n     * To wait for a particular amount of time from now, always use `sleep`\n     * instead.\n     */\n    sleepUntil: createTool<\n      (\n        idOrOptions: StepOptionsOrId,\n\n        /**\n         * The date to wait until before continuing.\n         */\n        time: Date | string | Temporal.InstantLike | Temporal.ZonedDateTimeLike,\n      ) => Promise<void>\n    >(({ id, name }, time) => {\n      try {\n        const iso = Temporal.getISOString(time);\n\n        /**\n         * The presence of this operation in the returned stack indicates that the\n         * sleep is over and we should continue execution.\n         */\n        return {\n          id,\n          mode: StepMode.Async,\n          op: StepOpCode.Sleep,\n          name: iso,\n          displayName: name ?? id,\n          userland: { id },\n        };\n      } catch (err) {\n        /**\n         * If we're here, it's because the date is invalid. We'll throw a custom\n         * error here to standardise this response.\n         */\n        // TODO PrettyError\n        console.warn(\n          \"Invalid `Date`, date string, `Temporal.Instant`, or `Temporal.ZonedDateTime` passed to sleepUntil;\",\n          err,\n        );\n\n        // TODO PrettyError\n        throw new Error(\n          `Invalid \\`Date\\`, date string, \\`Temporal.Instant\\`, or \\`Temporal.ZonedDateTime\\` passed to sleepUntil: ${\n            time\n          }`,\n        );\n      }\n    }),\n\n    /**\n     * Invoke a passed Inngest `function` with the given `data`. Returns the\n     * result of the returned value of the function or `null` if the function\n     * does not return a value.\n     *\n     * A string ID can also be passed to reference functions outside of the\n     * current app.\n     */\n    invoke: createTool<\n      <TFunction extends InvokeTargetFunctionDefinition>(\n        idOrOptions: StepOptionsOrId,\n        opts: InvocationOpts<TFunction>,\n      ) => InvocationResult<GetFunctionOutput<TFunction>>\n    >(({ id, name }, invokeOpts) => {\n      // Create a discriminated union to operate on based on the input types\n      // available for this tool.\n      const optsSchema = invokePayloadSchema.extend({\n        timeout: z.union([z.number(), z.string(), z.date()]).optional(),\n      });\n\n      const parsedFnOpts = optsSchema\n        .extend({\n          _type: z.literal(\"fullId\").optional().default(\"fullId\"),\n          function: z.string().min(1),\n        })\n        .or(\n          optsSchema.extend({\n            _type: z.literal(\"fnInstance\").optional().default(\"fnInstance\"),\n            function: z.instanceof(InngestFunction),\n          }),\n        )\n        .or(\n          optsSchema.extend({\n            _type: z.literal(\"refInstance\").optional().default(\"refInstance\"),\n            function: z.instanceof(InngestFunctionReference),\n          }),\n        )\n        .safeParse(invokeOpts);\n\n      if (!parsedFnOpts.success) {\n        throw new Error(\n          `Invalid invocation options passed to invoke; must include either a function or functionId.`,\n        );\n      }\n\n      const { _type, function: fn, data, user, v, timeout } = parsedFnOpts.data;\n      const payload = { data, user, v } satisfies MinimalEventPayload;\n      const opts: {\n        payload: MinimalEventPayload;\n        function_id: string;\n        timeout?: string;\n      } = {\n        payload,\n        function_id: \"\",\n        timeout: typeof timeout === \"undefined\" ? undefined : timeStr(timeout),\n      };\n\n      switch (_type) {\n        case \"fnInstance\":\n          opts.function_id = fn.id(fn[\"client\"].id);\n          break;\n\n        case \"fullId\":\n          console.warn(\n            `${logPrefix} Invoking function with \\`function: string\\` is deprecated and will be removed in v4.0.0; use an imported function or \\`referenceFunction()\\` instead. See https://innge.st/ts-referencing-functions`,\n          );\n          opts.function_id = fn;\n          break;\n\n        case \"refInstance\":\n          opts.function_id = [fn.opts.appId || client.id, fn.opts.functionId]\n            .filter(Boolean)\n            .join(\"-\");\n          break;\n      }\n\n      return {\n        id,\n        mode: StepMode.Async,\n        op: StepOpCode.InvokeFunction,\n        displayName: name ?? id,\n        opts,\n        userland: { id },\n      };\n    }),\n\n    /**\n     * `step.fetch` is a Fetch-API-compatible function that can be used to make\n     * any HTTP code durable if it's called within an Inngest function.\n     *\n     * It will gracefully fall back to the global `fetch` if called outside of\n     * this context, and a custom fallback can be set using the `config` method.\n     */\n    fetch: stepFetch,\n  };\n\n  // Add an uptyped gateway\n  (tools as unknown as InternalStepTools)[gatewaySymbol] = createTool(\n    ({ id, name }, input, init) => {\n      const url = input instanceof Request ? input.url : input.toString();\n\n      const headers: Record<string, string> = {};\n      if (input instanceof Request) {\n        input.headers.forEach((value, key) => {\n          headers[key] = value;\n        });\n      } else if (init?.headers) {\n        const h = new Headers(init.headers);\n        h.forEach((value, key) => {\n          headers[key] = value;\n        });\n      }\n\n      return {\n        id,\n        mode: StepMode.Async,\n        op: StepOpCode.Gateway,\n        displayName: name ?? id,\n        opts: {\n          url,\n          method: init?.method ?? \"GET\",\n          headers,\n          body: init?.body,\n        },\n        userland: { id },\n      };\n    },\n  );\n\n  return tools;\n};\n\n/**\n * A generic set of step tools, without typing information about the client used\n * to create them.\n */\nexport type GenericStepTools = GetStepTools<Inngest.Any>;\n\nexport const gatewaySymbol = Symbol.for(\"inngest.step.gateway\");\n\nexport type InternalStepTools = GetStepTools<Inngest.Any> & {\n  [gatewaySymbol]: (\n    idOrOptions: StepOptionsOrId,\n    ...args: Parameters<typeof fetch>\n  ) => Promise<{\n    status: number;\n    headers: Record<string, string>;\n    body: string;\n  }>;\n};\n\n/**\n * A generic set of step tools that can be used without typing information about\n * the client used to create them.\n *\n * These tools use AsyncLocalStorage to track the context in which they are\n * used, and will throw an error if used outside of an Inngest context.\n *\n * The intention of these high-level tools is to allow usage of Inngest step\n * tools within API endpoints, though they can still be used within regular\n * Inngest functions as well.\n */\nexport const step: GenericStepTools = {\n  // TODO Support `step.fetch` (this is already kinda half way deferred)\n  fetch: null as unknown as GenericStepTools[\"fetch\"],\n  ai: {\n    infer: (...args) =>\n      getDeferredStepTooling().then((tools) => tools.ai.infer(...args)),\n    wrap: (...args) =>\n      getDeferredStepTooling().then((tools) => tools.ai.wrap(...args)),\n    models: {\n      ...models,\n    },\n  },\n  invoke: (...args) =>\n    getDeferredStepTooling().then((tools) => tools.invoke(...args)),\n  run: (...args) =>\n    getDeferredStepTooling().then((tools) => tools.run(...args)),\n  sendEvent: (...args) =>\n    getDeferredStepTooling().then((tools) => tools.sendEvent(...args)),\n  sendSignal: (...args) =>\n    getDeferredStepTooling().then((tools) => tools.sendSignal(...args)),\n  sleep: (...args) =>\n    getDeferredStepTooling().then((tools) => tools.sleep(...args)),\n  sleepUntil: (...args) =>\n    getDeferredStepTooling().then((tools) => tools.sleepUntil(...args)),\n  waitForEvent: (...args) =>\n    getDeferredStepTooling().then((tools) => tools.waitForEvent(...args)),\n  waitForSignal: (...args) =>\n    getDeferredStepTooling().then((tools) => tools.waitForSignal(...args)),\n};\n\n/**\n * An internal function used to retrieve or create step tooling for the current\n * execution context.\n *\n * Note that this requires an existing context to create the step tooling;\n * something must declare the Inngest execution context before this can be used.\n */\nconst getDeferredStepTooling = async (): Promise<GenericStepTools> => {\n  const ctx = await getAsyncCtx();\n  if (!ctx) {\n    throw new Error(\n      \"`step` tools can only be used within Inngest function executions; no context was found\",\n    );\n  }\n\n  if (!ctx.app) {\n    throw new Error(\n      \"`step` tools can only be used within Inngest function executions; no Inngest client was found in the execution context\",\n    );\n  }\n\n  if (!ctx.execution) {\n    throw new Error(\n      \"`step` tools can only be used within Inngest function executions; no execution context was found\",\n    );\n  }\n\n  // If we're here, we're in the context of a function execution already and\n  // we can return the existing step tooling.\n  return ctx.execution.ctx.step;\n};\n\n/**\n * The event payload portion of the options for `step.invoke()`. This does not\n * include non-payload options like `timeout` or the function to invoke.\n */\nexport const invokePayloadSchema = z.object({\n  data: z.record(z.any()).optional(),\n  user: z.record(z.any()).optional(),\n  v: z.string().optional(),\n});\n\ntype InvocationTargetOpts<TFunction extends InvokeTargetFunctionDefinition> = {\n  function: TFunction;\n};\n\ntype InvocationOpts<TFunction extends InvokeTargetFunctionDefinition> =\n  InvocationTargetOpts<TFunction> &\n    Omit<TriggerEventFromFunction<TFunction>, \"id\"> & {\n      /**\n       * The step function will wait for the invocation to finish for a maximum\n       * of this time, at which point the retured promise will be rejected\n       * instead of resolved with the output of the invoked function.\n       *\n       * Note that the invoked function will continue to run even if this step\n       * times out.\n       *\n       * The time to wait can be specified using a `number` of milliseconds, an\n       * `ms`-compatible time string like `\"1 hour\"`, `\"30 mins\"`, or `\"2.5d\"`,\n       * or a `Date` object.\n       *\n       * {@link https://npm.im/ms}\n       */\n      timeout?: number | string | Date;\n    };\n\n/**\n * A set of parameters given to a `sendSignal` call.\n */\ntype SendSignalOpts = {\n  /**\n   * The signal to send.\n   */\n  signal: string;\n\n  /**\n   * The data to send with the signal.\n   */\n  data?: unknown;\n};\n\n/**\n * A set of parameters given to a `waitForSignal` call.\n */\ntype WaitForSignalOpts = {\n  /**\n   * The signal to wait for.\n   */\n  signal: string;\n\n  /**\n   * The step function will wait for the signal for a maximum of this time, at\n   * which point the signal will be returned as `null` instead of any signal\n   * data.\n   *\n   * The time to wait can be specified using a `number` of milliseconds, an\n   * `ms`-compatible time string like `\"1 hour\"`, `\"30 mins\"`, or `\"2.5d\"`, or\n   * a `Date` object.\n   *\n   * {@link https://npm.im/ms}\n   */\n  timeout: number | string | Date;\n\n  /**\n   * When this `step.waitForSignal()` call is made, choose whether an existing\n   * wait for the same signal should be replaced, or whether this run should\n   * fail.\n   *\n   * `\"replace\"` will replace any existing wait with this one, and the existing\n   * wait will remain pending until it reaches its timeout.\n   *\n   * `\"fail\"` will cause this run to fail if there is already a wait for the\n   * same signal.\n   */\n  onConflict: \"replace\" | \"fail\";\n};\n\n/**\n * A set of optional parameters given to a `waitForEvent` call to control how\n * the event is handled.\n */\ntype WaitForEventOpts<\n  Events extends Record<string, EventPayload>,\n  IncomingEvent extends keyof Events,\n> = {\n  event: IncomingEvent;\n\n  /**\n   * The step function will wait for the event for a maximum of this time, at\n   * which point the event will be returned as `null` instead of any event data.\n   *\n   * The time to wait can be specified using a `number` of milliseconds, an\n   * `ms`-compatible time string like `\"1 hour\"`, `\"30 mins\"`, or `\"2.5d\"`, or\n   * a `Date` object.\n   *\n   * {@link https://npm.im/ms}\n   */\n  timeout: number | string | Date;\n} & ExclusiveKeys<\n  {\n    /**\n     * If provided, the step function will wait for the incoming event to match\n     * particular criteria. If the event does not match, it will be ignored and\n     * the step function will wait for another event.\n     *\n     * It must be a string of a dot-notation field name within both events to\n     * compare, e.g. `\"data.id\"` or `\"user.email\"`.\n     *\n     * ```\n     * // Wait for an event where the `user.email` field matches\n     * match: \"user.email\"\n     * ```\n     *\n     * All of these are helpers for the `if` option, which allows you to specify\n     * a custom condition to check. This can be useful if you need to compare\n     * multiple fields or use a more complex condition.\n     *\n     * See the Inngest expressions docs for more information.\n     *\n     * {@link https://www.inngest.com/docs/functions/expressions}\n     *\n     * @deprecated Use `if` instead.\n     */\n    match?: string;\n\n    /**\n     * If provided, the step function will wait for the incoming event to match\n     * the given condition. If the event does not match, it will be ignored and\n     * the step function will wait for another event.\n     *\n     * The condition is a string of Google's Common Expression Language. For most\n     * simple cases, you might prefer to use `match` instead.\n     *\n     * See the Inngest expressions docs for more information.\n     *\n     * {@link https://www.inngest.com/docs/functions/expressions}\n     */\n    if?: string;\n  },\n  \"match\",\n  \"if\"\n>;\n\n/**\n * Options for `step.ai.infer()`.\n */\ntype AiInferOpts<TModel extends AiAdapter> = {\n  /**\n   * The model to use for the inference. Create a model by importing from\n   * `\"inngest\"` or by using `step.ai.models.*`.\n   *\n   * @example Import `openai()`\n   * ```ts\n   * import { openai } from \"inngest\";\n   *\n   * const model = openai({ model: \"gpt-4\" });\n   * ```\n   *\n   * @example Use a model from `step.ai.models`\n   * ```ts\n   * async ({ step }) => {\n   *            const model = step.ai.models.openai({ model: \"gpt-4\" });\n   * }\n   * ```\n   */\n  model: TModel;\n\n  /**\n   * The input to pass to the model.\n   */\n  body: AiAdapter.Input<TModel>;\n};\n"],"names":["opts: HashedOp[\"opts\"]","matchOpts: { timeout: string; if?: string }","msTimeStr: string","Temporal.isTemporalDuration","Temporal.getISOString","opts: {\n        payload: MinimalEventPayload;\n        function_id: string;\n        timeout?: string;\n      }","stepFetch","headers: Record<string, string>","step: GenericStepTools"],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2695, "column": 0}, "map": {"version":3,"file":"v0.js","sources":["file:///Users/amansatyawani/Desktop/website-builder/node_modules/.pnpm/inngest%403.45.1_%40opentelemetry%2Bcore%402.2.0_%40opentelemetry%2Bapi%401.9.0__express%405.1.0_next%401_e029d374516642dd9a767b32fbb0beec/node_modules/src/components/execution/v0.ts"],"sourcesContent":["import canonicalize from \"canonicalize\";\nimport hashjs from \"hash.js\";\nimport { z } from \"zod/v3\";\nimport {\n  deserializeError,\n  ErrCode,\n  functionStoppedRunningErr,\n  prettyError,\n  serializeError,\n} from \"../../helpers/errors.ts\";\nimport { undefinedToNull } from \"../../helpers/functions.ts\";\nimport {\n  resolveAfterPending,\n  resolveNextTick,\n  runAsPromise,\n} from \"../../helpers/promises.ts\";\nimport type { MaybePromise, PartialK } from \"../../helpers/types.ts\";\nimport {\n  type BaseContext,\n  type Context,\n  type EventPayload,\n  type FailureEventArgs,\n  type Handler,\n  type HashedOp,\n  type IncomingOp,\n  jsonErrorSchema,\n  type OpStack,\n  type OutgoingOp,\n  StepOpCode,\n} from \"../../types.ts\";\nimport type { Inngest } from \"../Inngest.ts\";\nimport { getHookStack, type RunHookStack } from \"../InngestMiddleware.ts\";\nimport {\n  createStepTools,\n  getStepOptions,\n  type StepHandler,\n} from \"../InngestStepTools.ts\";\nimport { NonRetriableError } from \"../NonRetriableError.ts\";\nimport { RetryAfterError } from \"../RetryAfterError.ts\";\nimport {\n  type ExecutionResult,\n  ExecutionVersion,\n  type IInngestExecution,\n  InngestExecution,\n  type InngestExecutionFactory,\n  type InngestExecutionOptions,\n  type MemoizedOp,\n} from \"./InngestExecution.ts\";\n\nconst { sha1 } = hashjs;\n\nexport const createV0InngestExecution: InngestExecutionFactory = (options) => {\n  return new V0InngestExecution(options);\n};\n\nexport class V0InngestExecution\n  extends InngestExecution\n  implements IInngestExecution\n{\n  public version = ExecutionVersion.V0;\n\n  private state: V0ExecutionState;\n  private execution: Promise<ExecutionResult> | undefined;\n  private userFnToRun: Handler.Any;\n  private fnArg: Context.Any;\n\n  constructor(options: InngestExecutionOptions) {\n    super(options);\n\n    this.userFnToRun = this.getUserFnToRun();\n    this.state = this.createExecutionState();\n    this.fnArg = this.createFnArg();\n  }\n\n  public start() {\n    this.debug(\"starting V0 execution\");\n\n    // biome-ignore lint/suspicious/noAssignInExpressions: <explanation>\n    return (this.execution ??= this._start().then((result) => {\n      this.debug(\"result:\", result);\n      return result;\n    }));\n  }\n\n  private async _start(): Promise<ExecutionResult> {\n    this.state.hooks = await this.initializeMiddleware();\n\n    try {\n      await this.transformInput();\n      await this.state.hooks.beforeMemoization?.();\n\n      if (this.state.opStack.length === 0 && !this.options.requestedRunStep) {\n        await this.state.hooks.afterMemoization?.();\n        await this.state.hooks.beforeExecution?.();\n      }\n\n      const userFnPromise = runAsPromise(() => this.userFnToRun(this.fnArg));\n\n      let pos = -1;\n\n      do {\n        if (pos >= 0) {\n          if (\n            !this.options.requestedRunStep &&\n            pos === this.state.opStack.length - 1\n          ) {\n            await this.state.hooks.afterMemoization?.();\n            await this.state.hooks.beforeExecution?.();\n          }\n\n          this.state.tickOps = {};\n          const incomingOp = this.state.opStack[pos] as IncomingOp;\n          this.state.currentOp = this.state.allFoundOps[incomingOp.id];\n\n          if (!this.state.currentOp) {\n            /**\n             * We're trying to resume the function, but we can't find where to go.\n             *\n             * This means that either the function has changed or there are async\n             * actions in-between steps that we haven't noticed in previous\n             * executions.\n             *\n             * Whichever the case, this is bad and we can't continue in this\n             * undefined state.\n             */\n            throw new NonRetriableError(\n              prettyError({\n                whatHappened: \" Your function was stopped from running\",\n                why: \"We couldn't resume your function's state because it may have changed since the run started or there are async actions in-between steps that we haven't noticed in previous executions.\",\n                consequences:\n                  \"Continuing to run the function may result in unexpected behaviour, so we've stopped your function to ensure nothing unexpected happened!\",\n                toFixNow:\n                  \"Ensure that your function is either entirely step-based or entirely non-step-based, by either wrapping all asynchronous logic in `step.run()` calls or by removing all `step.*()` calls.\",\n                otherwise:\n                  \"For more information on why step functions work in this manner, see https://www.inngest.com/docs/functions/multi-step#gotchas\",\n                stack: true,\n                code: ErrCode.NON_DETERMINISTIC_FUNCTION,\n              }),\n            );\n          }\n\n          this.state.currentOp.fulfilled = true;\n\n          if (typeof incomingOp.data !== \"undefined\") {\n            this.state.currentOp.resolve(incomingOp.data);\n          } else {\n            this.state.currentOp.reject(incomingOp.error);\n          }\n        }\n\n        await resolveAfterPending();\n        this.state.reset();\n        pos++;\n      } while (pos < this.state.opStack.length);\n\n      await this.state.hooks.afterMemoization?.();\n\n      const discoveredOps = Object.values(this.state.tickOps).map<OutgoingOp>(\n        tickOpToOutgoing,\n      );\n\n      const runStep =\n        this.options.requestedRunStep ||\n        this.getEarlyExecRunStep(discoveredOps);\n\n      if (runStep) {\n        const userFnOp = this.state.allFoundOps[runStep];\n        const stepToRun = userFnOp?.fn;\n\n        if (!stepToRun) {\n          throw new Error(\n            `Bad stack; executor requesting to run unknown step \"${runStep}\"`,\n          );\n        }\n\n        const outgoingUserFnOp = {\n          ...tickOpToOutgoing(userFnOp),\n          op: StepOpCode.Step,\n        };\n\n        await this.state.hooks.beforeExecution?.();\n        this.state.executingStep = true;\n\n        const result = await runAsPromise(stepToRun)\n          .finally(() => {\n            this.state.executingStep = false;\n          })\n          .catch(async (error: Error) => {\n            return await this.transformOutput({ error }, outgoingUserFnOp);\n          })\n          .then(async (data) => {\n            await this.state.hooks?.afterExecution?.();\n            return await this.transformOutput({ data }, outgoingUserFnOp);\n          });\n\n        const { type: _type, ...rest } = result;\n\n        return {\n          type: \"step-ran\",\n          ctx: this.fnArg,\n          ops: this.ops,\n          step: { ...outgoingUserFnOp, ...rest },\n        };\n      }\n\n      if (!discoveredOps.length) {\n        const fnRet = await Promise.race([\n          userFnPromise.then((data) => ({ type: \"complete\", data }) as const),\n          resolveNextTick().then(() => ({ type: \"incomplete\" }) as const),\n        ]);\n\n        if (fnRet.type === \"complete\") {\n          await this.state.hooks.afterExecution?.();\n\n          const allOpsFulfilled = Object.values(this.state.allFoundOps).every(\n            (op) => {\n              return op.fulfilled;\n            },\n          );\n\n          if (allOpsFulfilled) {\n            return await this.transformOutput({ data: fnRet.data });\n          }\n        } else if (!this.state.hasUsedTools) {\n          this.state.nonStepFnDetected = true;\n          const data = await userFnPromise;\n          await this.state.hooks.afterExecution?.();\n          return await this.transformOutput({ data });\n        } else {\n          const hasOpsPending = Object.values(this.state.allFoundOps).some(\n            (op) => {\n              return op.fulfilled === false;\n            },\n          );\n\n          if (!hasOpsPending) {\n            throw new NonRetriableError(\n              functionStoppedRunningErr(\n                ErrCode.ASYNC_DETECTED_AFTER_MEMOIZATION,\n              ),\n            );\n          }\n        }\n      }\n\n      await this.state.hooks.afterExecution?.();\n\n      return {\n        type: \"steps-found\",\n        ctx: this.fnArg,\n        ops: this.ops,\n        steps: discoveredOps as [OutgoingOp, ...OutgoingOp[]],\n      };\n    } catch (error) {\n      return await this.transformOutput({ error });\n    } finally {\n      await this.state.hooks.beforeResponse?.();\n    }\n  }\n\n  private async initializeMiddleware(): Promise<RunHookStack> {\n    const ctx = this.options.data as Pick<\n      Readonly<BaseContext<Inngest.Any>>,\n      \"event\" | \"events\" | \"runId\"\n    >;\n\n    const hooks = await getHookStack(\n      this.options.fn[\"middleware\"],\n      \"onFunctionRun\",\n      {\n        ctx,\n        fn: this.options.fn,\n        steps: Object.values(this.options.stepState),\n        reqArgs: this.options.reqArgs,\n      },\n      {\n        transformInput: (prev, output) => {\n          return {\n            ctx: { ...prev.ctx, ...output?.ctx },\n            fn: this.options.fn,\n            steps: prev.steps.map((step, i) => ({\n              ...step,\n              ...output?.steps?.[i],\n            })),\n            reqArgs: prev.reqArgs,\n          };\n        },\n        transformOutput: (prev, output) => {\n          return {\n            result: { ...prev.result, ...output?.result },\n            step: prev.step,\n          };\n        },\n      },\n    );\n\n    return hooks;\n  }\n\n  private createExecutionState(): V0ExecutionState {\n    const state: V0ExecutionState = {\n      allFoundOps: {},\n      tickOps: {},\n      tickOpHashes: {},\n      currentOp: undefined,\n      hasUsedTools: false,\n      reset: () => {\n        state.tickOpHashes = {};\n        state.allFoundOps = { ...state.allFoundOps, ...state.tickOps };\n      },\n      nonStepFnDetected: false,\n      executingStep: false,\n      opStack: this.options.stepCompletionOrder.reduce<IncomingOp[]>(\n        (acc, stepId) => {\n          const stepState = this.options.stepState[stepId];\n          if (!stepState) {\n            return acc;\n          }\n\n          return [...acc, stepState];\n        },\n        [],\n      ),\n    };\n\n    return state;\n  }\n\n  get ops(): Record<string, MemoizedOp> {\n    return Object.fromEntries(\n      Object.entries(this.state.allFoundOps).map<[string, MemoizedOp]>(\n        ([id, op]) => [\n          id,\n          {\n            id: op.id,\n            rawArgs: op.rawArgs,\n            data: op.data,\n            error: op.error,\n            fulfilled: op.fulfilled,\n            seen: true,\n          },\n        ],\n      ),\n    );\n  }\n\n  private getUserFnToRun(): Handler.Any {\n    if (!this.options.isFailureHandler) {\n      return this.options.fn[\"fn\"];\n    }\n\n    if (!this.options.fn[\"onFailureFn\"]) {\n      /**\n       * Somehow, we've ended up detecting that this is a failure handler but\n       * doesn't have an `onFailure` function. This should never happen.\n       */\n      throw new Error(\"Cannot find function `onFailure` handler\");\n    }\n\n    // TODO: Review; inferred types results in an `any` here!\n    return this.options.fn[\"onFailureFn\"];\n  }\n\n  private createFnArg(): Context.Any {\n    // Start referencing everything\n    this.state.tickOps = this.state.allFoundOps;\n\n    /**\n     * Create a unique hash of an operation using only a subset of the operation's\n     * properties; will never use `data` and will guarantee the order of the\n     * object so we don't rely on individual tools for that.\n     *\n     * If the operation already contains an ID, the current ID will be used\n     * instead, so that users can provide their own IDs.\n     */\n    const hashOp = (\n      /**\n       * The op to generate a hash from. We only use a subset of the op's\n       * properties when creating the hash.\n       */\n      op: PartialK<HashedOp, \"id\">,\n    ): HashedOp => {\n      /**\n       * It's difficult for v0 to understand whether or not an op has\n       * historically contained a custom ID, as all step usage now require them.\n       *\n       * For this reason, we make the assumption that steps in v0 do not have a\n       * custom ID and generate one for them as we would in all recommendations\n       * and examples.\n       */\n      const obj = {\n        parent: this.state.currentOp?.id ?? null,\n        op: op.op,\n        name: op.name as string,\n\n        // Historically, no v0 runs could have options for `step.run()` call,\n        // but this object can be specified in future versions.\n        //\n        // For this purpose, we change this to always use `null` if the op is\n        // that of a `step.run()`.\n        opts: op.op === StepOpCode.StepPlanned ? null : (op.opts ?? null),\n      };\n\n      const collisionHash = _internals.hashData(obj);\n\n      // biome-ignore lint/suspicious/noAssignInExpressions: <explanation>\n      const pos = (this.state.tickOpHashes[collisionHash] =\n        (this.state.tickOpHashes[collisionHash] ?? -1) + 1);\n\n      return {\n        ...op,\n        id: _internals.hashData({ pos, ...obj }),\n      };\n    };\n\n    const stepHandler: StepHandler = ({ args, matchOp, opts }) => {\n      if (this.state.nonStepFnDetected) {\n        throw new NonRetriableError(\n          functionStoppedRunningErr(ErrCode.STEP_USED_AFTER_ASYNC),\n        );\n      }\n\n      if (this.state.executingStep) {\n        throw new NonRetriableError(\n          prettyError({\n            whatHappened: \"Your function was stopped from running\",\n            why: \"We detected that you have nested `step.*` tooling.\",\n            consequences: \"Nesting `step.*` tooling is not supported.\",\n            stack: true,\n            toFixNow:\n              \"Make sure you're not using `step.*` tooling inside of other `step.*` tooling. If you need to compose steps together, you can create a new async function and call it from within your step function, or use promise chaining.\",\n            otherwise:\n              \"For more information on step functions with Inngest, see https://www.inngest.com/docs/functions/multi-step\",\n            code: ErrCode.NESTING_STEPS,\n          }),\n        );\n      }\n\n      this.state.hasUsedTools = true;\n\n      const stepOptions = getStepOptions(args[0]);\n      const opId = hashOp(matchOp(stepOptions, ...args.slice(1)));\n\n      return new Promise<unknown>((resolve, reject) => {\n        this.state.tickOps[opId.id] = {\n          ...opId,\n          ...(opts?.fn ? { fn: () => opts.fn?.(...args) } : {}),\n          rawArgs: args,\n          resolve,\n          reject,\n          fulfilled: false,\n        };\n      });\n    };\n\n    const step = createStepTools(this.options.client, this, stepHandler);\n\n    let fnArg = {\n      ...(this.options.data as { event: EventPayload }),\n      step,\n    } as Context.Any;\n\n    if (this.options.isFailureHandler) {\n      const eventData = z\n        .object({ error: jsonErrorSchema })\n        .parse(fnArg.event?.data);\n\n      (fnArg as Partial<Pick<FailureEventArgs, \"error\">>) = {\n        ...fnArg,\n        error: deserializeError(eventData.error),\n      };\n    }\n\n    return this.options.transformCtx?.(fnArg) ?? fnArg;\n  }\n\n  /**\n   * Using middleware, transform input before running.\n   */\n  private async transformInput() {\n    const inputMutations = await this.state.hooks?.transformInput?.({\n      ctx: { ...this.fnArg },\n      steps: Object.values(this.options.stepState),\n      fn: this.options.fn,\n      reqArgs: this.options.reqArgs,\n    });\n\n    if (inputMutations?.ctx) {\n      this.fnArg = inputMutations.ctx;\n    }\n\n    if (inputMutations?.steps) {\n      this.state.opStack = [...inputMutations.steps];\n    }\n  }\n\n  private getEarlyExecRunStep(ops: OutgoingOp[]): string | undefined {\n    if (ops.length !== 1) return;\n\n    const op = ops[0];\n\n    if (\n      op &&\n      op.op === StepOpCode.StepPlanned\n      // TODO We must individually check properties here that we do not want to\n      // execute on, such as retry counts. Nothing exists here that falls in to\n      // this case, but should be accounted for when we add them.\n      // && typeof op.opts === \"undefined\"\n    ) {\n      return op.id;\n    }\n\n    return;\n  }\n\n  /**\n   * Using middleware, transform output before returning.\n   */\n  private async transformOutput(\n    dataOrError: Parameters<\n      NonNullable<RunHookStack[\"transformOutput\"]>\n    >[0][\"result\"],\n    step?: Readonly<Omit<OutgoingOp, \"id\">>,\n  ): Promise<ExecutionResult> {\n    const output = { ...dataOrError };\n\n    if (typeof output.error !== \"undefined\") {\n      output.data = serializeError(output.error);\n    }\n\n    const transformedOutput = await this.state.hooks?.transformOutput?.({\n      result: { ...output },\n      step,\n    });\n\n    const { data, error } = { ...output, ...transformedOutput?.result };\n\n    if (!step) {\n      await this.state.hooks?.finished?.({\n        result: { ...(typeof error !== \"undefined\" ? { error } : { data }) },\n      });\n    }\n\n    if (typeof error !== \"undefined\") {\n      /**\n       * Ensure we give middleware the chance to decide on retriable behaviour\n       * by looking at the error returned from output transformation.\n       */\n      let retriable: boolean | string = !(error instanceof NonRetriableError);\n      if (retriable && error instanceof RetryAfterError) {\n        retriable = error.retryAfter;\n      }\n\n      const serializedError = serializeError(error);\n\n      return {\n        type: \"function-rejected\",\n        ctx: this.fnArg,\n        ops: this.ops,\n        error: serializedError,\n        retriable,\n      };\n    }\n\n    return {\n      type: \"function-resolved\",\n      ctx: this.fnArg,\n      ops: this.ops,\n      data: undefinedToNull(data),\n    };\n  }\n}\n\ninterface TickOp extends HashedOp {\n  rawArgs: unknown[];\n  fn?: (...args: unknown[]) => unknown;\n  fulfilled: boolean;\n  resolve: (value: MaybePromise<unknown>) => void;\n  reject: (reason?: unknown) => void;\n}\n\nexport interface V0ExecutionState {\n  /**\n   * The tree of all found ops in the entire invocation.\n   */\n  allFoundOps: Record<string, TickOp>;\n\n  /**\n   * All synchronous operations found in this particular tick. The array is\n   * reset every tick.\n   */\n  tickOps: Record<string, TickOp>;\n\n  /**\n   * A hash of operations found within this tick, with keys being the hashed\n   * ops themselves (without a position) and the values being the number of\n   * times that op has been found.\n   *\n   * This is used to provide some mutation resilience to the op stack,\n   * allowing us to survive same-tick mutations of code by ensuring per-tick\n   * hashes are based on uniqueness rather than order.\n   */\n  tickOpHashes: Record<string, number>;\n\n  /**\n   * Tracks the current operation being processed. This can be used to\n   * understand the contextual parent of any recorded operations.\n   */\n  currentOp: TickOp | undefined;\n\n  /**\n   * If we've found a user function to run, we'll store it here so a component\n   * higher up can invoke and await it.\n   */\n  userFnToRun?: (...args: unknown[]) => unknown;\n\n  /**\n   * A boolean to represent whether the user's function is using any step\n   * tools.\n   *\n   * If the function survives an entire tick of the event loop and hasn't\n   * touched any tools, we assume that it is a single-step async function and\n   * should be awaited as usual.\n   */\n  hasUsedTools: boolean;\n\n  /**\n   * A function that should be used to reset the state of the tools after a\n   * tick has completed.\n   */\n  reset: () => void;\n\n  /**\n   * If `true`, any use of step tools will, by default, throw an error. We do\n   * this when we detect that a function may be mixing step and non-step code.\n   *\n   * Created step tooling can decide how to manually handle this on a\n   * case-by-case basis.\n   *\n   * In the future, we can provide a way for a user to override this if they\n   * wish to and understand the danger of side-effects.\n   *\n   * Defaults to `false`.\n   */\n  nonStepFnDetected: boolean;\n\n  /**\n   * When true, we are currently executing a user's code for a single step\n   * within a step function.\n   */\n  executingStep: boolean;\n\n  /**\n   * Initialized middleware hooks for this execution.\n   *\n   * Middleware hooks are cached to ensure they can only be run once, which\n   * means that these hooks can be called in many different places to ensure we\n   * handle all possible execution paths.\n   */\n  hooks?: RunHookStack;\n\n  /**\n   * The op stack to pass to the function as state, likely stored in\n   * `ctx._state` in the Inngest payload.\n   *\n   * This must be provided in order to always be cognizant of step function\n   * state and to allow for multi-step functions.\n   */\n  opStack: OpStack;\n}\n\nconst tickOpToOutgoing = (op: TickOp): OutgoingOp => {\n  return {\n    op: op.op,\n    id: op.id,\n    name: op.name,\n    opts: op.opts,\n  };\n};\n\n/**\n * An operation ready to hash to be used to memoise step function progress.\n *\n * @internal\n */\nexport type UnhashedOp = {\n  name: string;\n  op: StepOpCode;\n  opts: Record<string, unknown> | null;\n  parent: string | null;\n  pos?: number;\n};\n\nconst hashData = (op: UnhashedOp): string => {\n  return sha1().update(canonicalize(op)).digest(\"hex\");\n};\n\n/**\n * Exported for testing.\n */\nexport const _internals = { hashData };\n"],"names":["createV0InngestExecution: InngestExecutionFactory","state: V0ExecutionState","stepHandler: StepHandler","retriable: boolean | string"],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3130, "column": 0}, "map": {"version":3,"file":"access.js","sources":["file:///Users/amansatyawani/Desktop/website-builder/node_modules/.pnpm/inngest%403.45.1_%40opentelemetry%2Bcore%402.2.0_%40opentelemetry%2Bapi%401.9.0__express%405.1.0_next%401_e029d374516642dd9a767b32fbb0beec/node_modules/src/components/execution/otel/access.ts"],"sourcesContent":["/**\n * A file used to access client processors safely without also importing any\n * otel-specific libraries. Useful for ensuring that the otel libraries can be\n * tree-shaken if they're not used directly by the user.\n */\n\nimport type { Inngest } from \"../../Inngest.ts\";\nimport type { InngestSpanProcessor } from \"./processor.ts\";\n\n/**\n * A map of Inngest clients to their OTel span processors. This is used to\n * ensure that we only create one span processor per client, and that we can\n * access the span processor from the client without exposing the OTel\n * libraries to the user.\n */\nexport const clientProcessorMap = new WeakMap<\n  Inngest.Any,\n  InngestSpanProcessor\n>();\n"],"names":[],"mappings":";;;;;;;;;AAeA,MAAa,qBAAA,aAAA,GAAqB,IAAI,SAGnC","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3148, "column": 0}, "map": {"version":3,"file":"StepError.js","sources":["file:///Users/amansatyawani/Desktop/website-builder/node_modules/.pnpm/inngest%403.45.1_%40opentelemetry%2Bcore%402.2.0_%40opentelemetry%2Bapi%401.9.0__express%405.1.0_next%401_e029d374516642dd9a767b32fbb0beec/node_modules/src/components/StepError.ts"],"sourcesContent":["import { deserializeError } from \"../helpers/errors.ts\";\nimport { jsonErrorSchema } from \"../types.ts\";\n\n/**\n * An error that represents a step exhausting all retries and failing. This is\n * thrown by an Inngest step if it fails.\n *\n * It's synonymous with an `Error`, with the addition of the `stepId` that\n * failed.\n *\n * @public\n */\nexport class StepError extends Error {\n  public override cause?: unknown;\n\n  constructor(\n    /**\n     * The ID of the step that failed.\n     */\n    public readonly stepId: string,\n    err: unknown,\n  ) {\n    const parsedErr = jsonErrorSchema.parse(err);\n\n    super(parsedErr.message);\n    this.name = parsedErr.name;\n    this.stepId = stepId;\n\n    // Don't show the internal stack trace if we don't have one.\n    this.stack = parsedErr.stack ?? undefined;\n\n    // Try setting the cause if we have one\n    this.cause = parsedErr.cause\n      ? deserializeError(parsedErr.cause, true)\n      : undefined;\n  }\n}\n"],"names":["stepId: string"],"mappings":";;;;;;;;;;;;;;;;GAYA,IAAa,YAAb,cAA+B,MAAM;IACnB,MAAA;IAEhB,YAIkBA,MAAAA,EAChB,GAAA,CACA;QACA,MAAM,YAAY,iWAAA,CAAgB,KAAA,CAAM,IAAI;QAE5C,KAAA,CAAM,UAAU,OAAA,CAAQ;QALR,IAAA,CAAA,MAAA,GAAA;QAMhB,IAAA,CAAK,IAAA,GAAO,UAAU,IAAA;QACtB,IAAA,CAAK,MAAA,GAAS;QAGd,IAAA,CAAK,KAAA,GAAQ,UAAU,KAAA,IAAS,KAAA;QAGhC,IAAA,CAAK,KAAA,GAAQ,UAAU,KAAA,kWACnB,mBAAA,EAAiB,UAAU,KAAA,EAAO,KAAK,GACvC,KAAA","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3184, "column": 0}, "map": {"version":3,"file":"v2.js","sources":["file:///Users/amansatyawani/Desktop/website-builder/node_modules/.pnpm/inngest%403.45.1_%40opentelemetry%2Bcore%402.2.0_%40opentelemetry%2Bapi%401.9.0__express%405.1.0_next%401_e029d374516642dd9a767b32fbb0beec/node_modules/src/components/execution/v2.ts"],"sourcesContent":["import { trace } from \"@opentelemetry/api\";\nimport hashjs from \"hash.js\";\nimport { z } from \"zod/v3\";\nimport {\n  ExecutionVersion,\n  headerKeys,\n  internalEvents,\n} from \"../../helpers/consts.ts\";\nimport {\n  deserializeError,\n  ErrCode,\n  minifyPrettyError,\n  prettyError,\n  serializeError,\n} from \"../../helpers/errors.js\";\nimport { undefinedToNull } from \"../../helpers/functions.js\";\nimport {\n  createDeferredPromise,\n  createDeferredPromiseWithStack,\n  createTimeoutPromise,\n  resolveNextTick,\n  runAsPromise,\n} from \"../../helpers/promises.ts\";\nimport type { MaybePromise, Simplify } from \"../../helpers/types.ts\";\nimport {\n  type BaseContext,\n  type Context,\n  type EventPayload,\n  type FailureEventArgs,\n  type Handler,\n  jsonErrorSchema,\n  type OutgoingOp,\n  StepOpCode,\n} from \"../../types.ts\";\nimport { version } from \"../../version.ts\";\nimport type { Inngest } from \"../Inngest.ts\";\nimport { getHookStack, type RunHookStack } from \"../InngestMiddleware.ts\";\nimport {\n  createStepTools,\n  type FoundStep,\n  getStepOptions,\n  invokePayloadSchema,\n  STEP_INDEXING_SUFFIX,\n  type StepHandler,\n} from \"../InngestStepTools.ts\";\nimport { NonRetriableError } from \"../NonRetriableError.ts\";\nimport { RetryAfterError } from \"../RetryAfterError.ts\";\nimport { StepError } from \"../StepError.ts\";\nimport { getAsyncCtx, getAsyncLocalStorage } from \"./als.ts\";\nimport {\n  type ExecutionResult,\n  type IInngestExecution,\n  InngestExecution,\n  type InngestExecutionFactory,\n  type InngestExecutionOptions,\n  type MemoizedOp,\n} from \"./InngestExecution.ts\";\nimport { clientProcessorMap } from \"./otel/access.ts\";\n\nconst { sha1 } = hashjs;\n\nexport const createV2InngestExecution: InngestExecutionFactory = (options) => {\n  return new V2InngestExecution(options);\n};\n\nclass V2InngestExecution extends InngestExecution implements IInngestExecution {\n  public version = ExecutionVersion.V2;\n\n  private state: V2ExecutionState;\n  private fnArg: Context.Any;\n  private checkpointHandlers: CheckpointHandlers;\n  private timeoutDuration = 1000 * 10;\n  private execution: Promise<ExecutionResult> | undefined;\n  private userFnToRun: Handler.Any;\n\n  /**\n   * If we're supposed to run a particular step via `requestedRunStep`, this\n   * will be a `Promise` that resolves after no steps have been found for\n   * `timeoutDuration` milliseconds.\n   *\n   * If we're not supposed to run a particular step, this will be `undefined`.\n   */\n  private timeout?: ReturnType<typeof createTimeoutPromise>;\n\n  constructor(options: InngestExecutionOptions) {\n    super(options);\n\n    this.userFnToRun = this.getUserFnToRun();\n    this.state = this.createExecutionState();\n    this.fnArg = this.createFnArg();\n    this.checkpointHandlers = this.createCheckpointHandlers();\n    this.initializeTimer(this.state);\n\n    this.debug(\n      \"created new V2 execution for run;\",\n      this.options.requestedRunStep\n        ? `wanting to run step \"${this.options.requestedRunStep}\"`\n        : \"discovering steps\",\n    );\n\n    this.debug(\"existing state keys:\", Object.keys(this.state.stepState));\n  }\n\n  /**\n   * Idempotently start the execution of the user's function.\n   */\n  public start() {\n    if (!this.execution) {\n      this.debug(\"starting V2 execution\");\n\n      const tracer = trace.getTracer(\"inngest\", version);\n\n      this.execution = getAsyncLocalStorage().then((als) => {\n        return als.run(\n          {\n            app: this.options.client,\n            execution: {\n              ctx: this.fnArg,\n              instance: this,\n            },\n          },\n          async () => {\n            return tracer.startActiveSpan(\"inngest.execution\", (span) => {\n              clientProcessorMap.get(this.options.client)?.declareStartingSpan({\n                span,\n                runId: this.options.runId,\n                traceparent: this.options.headers[headerKeys.TraceParent],\n                tracestate: this.options.headers[headerKeys.TraceState],\n              });\n\n              return this._start()\n                .then((result) => {\n                  this.debug(\"result:\", result);\n                  return result;\n                })\n                .finally(() => {\n                  span.end();\n                });\n            });\n          },\n        );\n      });\n    }\n\n    return this.execution;\n  }\n\n  /**\n   * Starts execution of the user's function and the core loop.\n   */\n  private async _start(): Promise<ExecutionResult> {\n    try {\n      const allCheckpointHandler = this.getCheckpointHandler(\"\");\n      this.state.hooks = await this.initializeMiddleware();\n      await this.startExecution();\n\n      for await (const checkpoint of this.state.loop) {\n        await allCheckpointHandler(checkpoint);\n\n        const handler = this.getCheckpointHandler(checkpoint.type);\n        const result = await handler(checkpoint);\n\n        if (result) {\n          return result;\n        }\n      }\n    } catch (error) {\n      return await this.transformOutput({ error });\n    } finally {\n      void this.state.loop.return();\n      await this.state.hooks?.beforeResponse?.();\n    }\n\n    /**\n     * If we're here, the generator somehow finished without returning a value.\n     * This should never happen.\n     */\n    throw new Error(\"Core loop finished without returning a value\");\n  }\n\n  /**\n   * Creates a handler for every checkpoint type, defining what to do when we\n   * reach that checkpoint in the core loop.\n   */\n  private createCheckpointHandlers(): CheckpointHandlers {\n    return {\n      /**\n       * Run for all checkpoints. Best used for logging or common actions.\n       * Use other handlers to return values and interrupt the core loop.\n       */\n      \"\": (checkpoint) => {\n        this.debug(\"checkpoint:\", checkpoint);\n      },\n\n      /**\n       * The user's function has completed and returned a value.\n       */\n      \"function-resolved\": async (checkpoint) => {\n        return await this.transformOutput({ data: checkpoint.data });\n      },\n\n      /**\n       * The user's function has thrown an error.\n       */\n      \"function-rejected\": async (checkpoint) => {\n        return await this.transformOutput({ error: checkpoint.error });\n      },\n\n      /**\n       * We've found one or more steps. Here we may want to run a step or report\n       * them back to Inngest.\n       */\n      \"steps-found\": async ({ steps }) => {\n        const stepResult = await this.tryExecuteStep(steps);\n        if (stepResult) {\n          const transformResult = await this.transformOutput(stepResult);\n\n          /**\n           * Transforming output will always return either function rejection or\n           * resolution. In most cases, this can be immediately returned, but in\n           * this particular case we want to handle it differently.\n           */\n          if (transformResult.type === \"function-resolved\") {\n            return {\n              type: \"step-ran\",\n              ctx: transformResult.ctx,\n              ops: transformResult.ops,\n              step: _internals.hashOp({\n                ...stepResult,\n                data: transformResult.data,\n              }),\n            };\n          } else if (transformResult.type === \"function-rejected\") {\n            const stepForResponse = _internals.hashOp({\n              ...stepResult,\n              error: transformResult.error,\n            });\n\n            if (stepResult.op === StepOpCode.StepFailed) {\n              const ser = serializeError(transformResult.error);\n              stepForResponse.data = {\n                __serialized: true,\n                name: ser.name,\n                message: ser.message,\n                stack: \"\",\n              };\n            }\n\n            return {\n              type: \"step-ran\",\n              ctx: transformResult.ctx,\n              ops: transformResult.ops,\n              retriable: transformResult.retriable,\n              step: stepForResponse,\n            };\n          }\n\n          return transformResult;\n        }\n\n        const newSteps = await this.filterNewSteps(\n          Array.from(this.state.steps.values()),\n        );\n        if (newSteps) {\n          return {\n            type: \"steps-found\",\n            ctx: this.fnArg,\n            ops: this.ops,\n            steps: newSteps,\n          };\n        }\n\n        return;\n      },\n\n      /**\n       * While trying to find a step that Inngest has told us to run, we've\n       * timed out or have otherwise decided that it doesn't exist.\n       */\n      \"step-not-found\": ({ step }) => {\n        return { type: \"step-not-found\", ctx: this.fnArg, ops: this.ops, step };\n      },\n    };\n  }\n\n  private getCheckpointHandler(type: keyof CheckpointHandlers) {\n    return this.checkpointHandlers[type] as (\n      checkpoint: Checkpoint,\n    ) => MaybePromise<ExecutionResult | undefined>;\n  }\n\n  private async tryExecuteStep(\n    steps: FoundStep[],\n  ): Promise<OutgoingOp | undefined> {\n    const hashedStepIdToRun =\n      this.options.requestedRunStep || this.getEarlyExecRunStep(steps);\n    if (!hashedStepIdToRun) {\n      return;\n    }\n\n    const step = steps.find(\n      (step) => step.hashedId === hashedStepIdToRun && step.fn,\n    );\n\n    if (step) {\n      return await this.executeStep(step);\n    }\n\n    /**\n     * Ensure we reset the timeout if we have a requested run step but couldn't\n     * find it, but also that we don't reset if we found and executed it.\n     */\n    return void this.timeout?.reset();\n  }\n\n  /**\n   * Given a list of outgoing ops, decide if we can execute an op early and\n   * return the ID of the step to execute if we can.\n   */\n  private getEarlyExecRunStep(steps: FoundStep[]): string | undefined {\n    /**\n     * We may have been disabled due to parallelism, in which case we can't\n     * immediately execute unless explicitly requested.\n     */\n    if (this.options.disableImmediateExecution) return;\n\n    const unfulfilledSteps = steps.filter((step) => !step.fulfilled);\n    if (unfulfilledSteps.length !== 1) return;\n\n    const op = unfulfilledSteps[0];\n\n    if (\n      op &&\n      op.op === StepOpCode.StepPlanned\n      // TODO We must individually check properties here that we do not want to\n      // execute on, such as retry counts. Nothing exists here that falls in to\n      // this case, but should be accounted for when we add them.\n      // && typeof op.opts === \"undefined\"\n    ) {\n      return op.hashedId;\n    }\n\n    return;\n  }\n\n  private async filterNewSteps(\n    foundSteps: FoundStep[],\n  ): Promise<[OutgoingOp, ...OutgoingOp[]] | undefined> {\n    if (this.options.requestedRunStep) {\n      return;\n    }\n\n    /**\n     * Gather any steps that aren't memoized and report them.\n     */\n    const newSteps = foundSteps.filter((step) => !step.fulfilled);\n\n    if (!newSteps.length) {\n      return;\n    }\n\n    /**\n     * Warn if we've found new steps but haven't yet seen all previous\n     * steps. This may indicate that step presence isn't determinate.\n     */\n    let knownSteps = 0;\n    for (const step of foundSteps) {\n      if (step.fulfilled) {\n        knownSteps++;\n      }\n    }\n    const foundAllCompletedSteps = this.state.stepsToFulfill === knownSteps;\n\n    if (!foundAllCompletedSteps) {\n      // TODO Tag\n      console.warn(\n        prettyError({\n          type: \"warn\",\n          whatHappened: \"Function may be indeterminate\",\n          why: \"We found new steps before seeing all previous steps, which may indicate that the function is non-deterministic.\",\n          consequences:\n            \"This may cause unexpected behaviour as Inngest executes your function.\",\n          reassurance:\n            \"This is expected if a function is updated in the middle of a run, but may indicate a bug if not.\",\n        }),\n      );\n    }\n\n    /**\n     * We're finishing up; let's trigger the last of the hooks.\n     */\n    await this.state.hooks?.afterMemoization?.();\n    await this.state.hooks?.beforeExecution?.();\n    await this.state.hooks?.afterExecution?.();\n\n    const stepList = newSteps.map<OutgoingOp>((step) => ({\n      displayName: step.displayName,\n      op: step.op,\n      id: step.hashedId,\n      name: step.name,\n      opts: step.opts,\n      userland: step.userland,\n    })) as [OutgoingOp, ...OutgoingOp[]];\n\n    /**\n     * We also run `onSendEvent` middleware hooks against `step.invoke()` steps\n     * to ensure that their `data` is transformed correctly.\n     */\n    return await this.transformNewSteps(stepList);\n  }\n\n  /**\n   * Using middleware, transform any newly-found steps before returning them to\n   * an Inngest Server.\n   */\n  private async transformNewSteps<T extends [OutgoingOp, ...OutgoingOp[]]>(\n    steps: T,\n  ): Promise<T> {\n    return Promise.all(\n      steps.map(async (step) => {\n        if (step.op !== StepOpCode.InvokeFunction) {\n          return step;\n        }\n\n        const onSendEventHooks = await getHookStack(\n          this.options.fn[\"middleware\"],\n          \"onSendEvent\",\n          undefined,\n          {\n            transformInput: (prev, output) => {\n              return { ...prev, ...output };\n            },\n            transformOutput: (prev, output) => {\n              return {\n                result: { ...prev.result, ...output?.result },\n              };\n            },\n          },\n        );\n\n        /**\n         * For each event being sent, create a new `onSendEvent` hook stack to\n         * process it. We do this as middleware hooks are intended to run once\n         * during each lifecycle (onFunctionRun or onSendEvent) and here, a hook\n         * is run for every single event.\n         *\n         * This is done because a developer can use this hook to filter out\n         * events entirely; if we batch all of the events together, we can't\n         * tell which ones were filtered out if we're processing >1 invocation\n         * here.\n         */\n        const transformedPayload = await onSendEventHooks.transformInput?.({\n          payloads: [\n            {\n              ...(step.opts?.payload ?? {}),\n              name: internalEvents.FunctionInvoked,\n            },\n          ],\n        });\n\n        const newPayload = invokePayloadSchema.parse(\n          transformedPayload?.payloads?.[0] ?? {},\n        );\n\n        return {\n          ...step,\n          opts: {\n            ...step.opts,\n            payload: {\n              ...(step.opts?.payload ?? {}),\n              ...newPayload,\n            },\n          },\n        };\n      }),\n    ) as Promise<T>;\n  }\n\n  private async executeStep({\n    id,\n    name,\n    opts,\n    fn,\n    displayName,\n    userland,\n  }: FoundStep): Promise<OutgoingOp> {\n    this.timeout?.clear();\n    await this.state.hooks?.afterMemoization?.();\n    await this.state.hooks?.beforeExecution?.();\n\n    const outgoingOp: OutgoingOp = {\n      id,\n      op: StepOpCode.StepRun,\n      name,\n      opts,\n      displayName,\n      userland,\n    };\n    this.state.executingStep = outgoingOp;\n\n    const store = await getAsyncCtx();\n\n    if (store?.execution) {\n      store.execution.executingStep = {\n        id,\n        name: displayName,\n      };\n    }\n\n    this.debug(`executing step \"${id}\"`);\n\n    return runAsPromise(fn)\n      .finally(async () => {\n        if (store?.execution) {\n          delete store.execution.executingStep;\n        }\n\n        await this.state.hooks?.afterExecution?.();\n      })\n      .then<OutgoingOp>((data) => {\n        return {\n          ...outgoingOp,\n          data,\n        };\n      })\n      .catch<OutgoingOp>((error) => {\n        let errorIsRetriable = true;\n\n        if (error instanceof NonRetriableError) {\n          errorIsRetriable = false;\n        } else if (\n          this.fnArg.maxAttempts &&\n          this.fnArg?.maxAttempts - 1 === this.fnArg.attempt\n        ) {\n          errorIsRetriable = false;\n        }\n\n        if (errorIsRetriable) {\n          return {\n            ...outgoingOp,\n            op: StepOpCode.StepError,\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n            error,\n          };\n        } else {\n          return {\n            ...outgoingOp,\n            op: StepOpCode.StepFailed,\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n            error,\n          };\n        }\n      });\n  }\n\n  /**\n   * Starts execution of the user's function, including triggering checkpoints\n   * and middleware hooks where appropriate.\n   */\n  private async startExecution(): Promise<void> {\n    /**\n     * Mutate input as neccessary based on middleware.\n     */\n    await this.transformInput();\n\n    /**\n     * Start the timer to time out the run if needed.\n     */\n    void this.timeout?.start();\n\n    await this.state.hooks?.beforeMemoization?.();\n\n    /**\n     * If we had no state to begin with, immediately end the memoization phase.\n     */\n    if (this.state.allStateUsed()) {\n      await this.state.hooks?.afterMemoization?.();\n      await this.state.hooks?.beforeExecution?.();\n    }\n\n    /**\n     * Trigger the user's function.\n     */\n    runAsPromise(() => this.userFnToRun(this.fnArg))\n      .finally(async () => {\n        await this.state.hooks?.afterMemoization?.();\n        await this.state.hooks?.beforeExecution?.();\n        await this.state.hooks?.afterExecution?.();\n      })\n      .then((data) => {\n        this.state.setCheckpoint({ type: \"function-resolved\", data });\n      })\n      .catch((error) => {\n        this.state.setCheckpoint({ type: \"function-rejected\", error });\n      });\n  }\n\n  /**\n   * Using middleware, transform input before running.\n   */\n  private async transformInput() {\n    const inputMutations = await this.state.hooks?.transformInput?.({\n      ctx: { ...this.fnArg },\n      steps: Object.values(this.state.stepState),\n      fn: this.options.fn,\n      reqArgs: this.options.reqArgs,\n    });\n\n    if (inputMutations?.ctx) {\n      this.fnArg = inputMutations.ctx;\n    }\n\n    if (inputMutations?.steps) {\n      this.state.stepState = Object.fromEntries(\n        inputMutations.steps.map((step) => [step.id, step]),\n      );\n    }\n  }\n\n  /**\n   * Using middleware, transform output before returning.\n   */\n  private async transformOutput(\n    dataOrError: Parameters<\n      NonNullable<RunHookStack[\"transformOutput\"]>\n    >[0][\"result\"],\n  ): Promise<ExecutionResult> {\n    const output = { ...dataOrError } as Partial<OutgoingOp>;\n\n    const isStepExecution = Boolean(this.state.executingStep);\n\n    const transformedOutput = await this.state.hooks?.transformOutput?.({\n      result: { ...output },\n      step: this.state.executingStep,\n    });\n\n    const { data, error } = { ...output, ...transformedOutput?.result };\n\n    if (!isStepExecution) {\n      await this.state.hooks?.finished?.({\n        result: { ...(typeof error !== \"undefined\" ? { error } : { data }) },\n      });\n    }\n\n    if (typeof error !== \"undefined\") {\n      /**\n       * Ensure we give middleware the chance to decide on retriable behaviour\n       * by looking at the error returned from output transformation.\n       */\n      let retriable: boolean | string = !(\n        error instanceof NonRetriableError ||\n        (error instanceof StepError &&\n          error === this.state.recentlyRejectedStepError)\n      );\n      if (retriable && error instanceof RetryAfterError) {\n        retriable = error.retryAfter;\n      }\n      const serializedError = minifyPrettyError(serializeError(error));\n\n      return {\n        type: \"function-rejected\",\n        ctx: this.fnArg,\n        ops: this.ops,\n        error: serializedError,\n        retriable,\n      };\n    }\n\n    return {\n      type: \"function-resolved\",\n      ctx: this.fnArg,\n      ops: this.ops,\n      data: undefinedToNull(data),\n    };\n  }\n\n  private createExecutionState(): V2ExecutionState {\n    const d = createDeferredPromiseWithStack<Checkpoint>();\n    let checkpointResolve = d.deferred.resolve;\n    const checkpointResults = d.results;\n\n    const loop: V2ExecutionState[\"loop\"] = (async function* (\n      cleanUp?: () => void,\n    ) {\n      try {\n        while (true) {\n          const res = (await checkpointResults.next()).value;\n          if (res) {\n            yield res;\n          }\n        }\n      } finally {\n        cleanUp?.();\n      }\n    })(() => {\n      this.timeout?.clear();\n      void checkpointResults.return();\n    });\n\n    const stepsToFulfill = Object.keys(this.options.stepState).length;\n\n    const state: V2ExecutionState = {\n      stepState: this.options.stepState,\n      stepsToFulfill,\n      steps: new Map(),\n      loop,\n      hasSteps: Boolean(stepsToFulfill),\n      stepCompletionOrder: [...this.options.stepCompletionOrder],\n      remainingStepsToBeSeen: new Set(this.options.stepCompletionOrder),\n      setCheckpoint: (checkpoint: Checkpoint) => {\n        ({ resolve: checkpointResolve } = checkpointResolve(checkpoint));\n      },\n      allStateUsed: () => {\n        return this.state.remainingStepsToBeSeen.size === 0;\n      },\n    };\n\n    return state;\n  }\n\n  get ops(): Record<string, MemoizedOp> {\n    return Object.fromEntries(this.state.steps);\n  }\n\n  private createFnArg(): Context.Any {\n    const step = this.createStepTools();\n\n    let fnArg = {\n      ...(this.options.data as { event: EventPayload }),\n      step,\n    } as Context.Any;\n\n    /**\n     * Handle use of the `onFailure` option by deserializing the error.\n     */\n    if (this.options.isFailureHandler) {\n      const eventData = z\n        .object({ error: jsonErrorSchema })\n        .parse(fnArg.event?.data);\n\n      (fnArg as Partial<Pick<FailureEventArgs, \"error\">>) = {\n        ...fnArg,\n        error: deserializeError(eventData.error),\n      };\n    }\n\n    return this.options.transformCtx?.(fnArg) ?? fnArg;\n  }\n\n  private createStepTools(): ReturnType<typeof createStepTools> {\n    /**\n     * A list of steps that have been found and are being rolled up before being\n     * reported to the core loop.\n     */\n    const foundStepsToReport: Map<string, FoundStep> = new Map();\n\n    /**\n     * A map of the subset of found steps to report that have not yet been\n     * handled. Used for fast access to steps that need to be handled in order.\n     */\n    const unhandledFoundStepsToReport: Map<string, FoundStep> = new Map();\n\n    /**\n     * A map of the latest sequential step indexes found for each step ID. Used\n     * to ensure that we don't index steps in parallel.\n     *\n     * Note that these must be sequential; if we've seen or assigned `a:1`,\n     * `a:2` and `a:4`, the latest sequential step index is `2`.\n     *\n     */\n    const expectedNextStepIndexes: Map<string, number> = new Map();\n\n    /**\n     * A promise that's used to ensure that step reporting cannot be run more than\n     * once in a given asynchronous time span.\n     */\n    let foundStepsReportPromise: Promise<void> | undefined;\n\n    /**\n     * A promise that's used to represent middleware hooks running before\n     * execution.\n     */\n    let beforeExecHooksPromise: Promise<void> | undefined;\n\n    /**\n     * A helper used to report steps to the core loop. Used after adding an item\n     * to `foundStepsToReport`.\n     */\n    const reportNextTick = () => {\n      // Being explicit instead of using `??=` to appease TypeScript.\n      if (foundStepsReportPromise) {\n        return;\n      }\n\n      foundStepsReportPromise = resolveNextTick()\n        /**\n         * Ensure that we wait for this promise to resolve before continuing.\n         *\n         * The groups in which steps are reported can affect how we detect some\n         * more complex determinism issues like parallel indexing. This promise\n         * can represent middleware hooks being run early, in the middle of\n         * ingesting steps to report.\n         *\n         * Because of this, it's important we wait for this middleware to resolve\n         * before continuing to report steps to ensure that all steps have a\n         * chance to be reported throughout this asynchronous action.\n         */\n        .then(() => beforeExecHooksPromise)\n        .then(() => {\n          foundStepsReportPromise = undefined;\n\n          for (const [hashedId, step] of unhandledFoundStepsToReport) {\n            if (step.handle()) {\n              unhandledFoundStepsToReport.delete(hashedId);\n              if (step.fulfilled) {\n                foundStepsToReport.delete(step.id);\n              }\n            }\n          }\n\n          if (foundStepsToReport.size) {\n            const steps = [...foundStepsToReport.values()] as [\n              FoundStep,\n              ...FoundStep[],\n            ];\n\n            foundStepsToReport.clear();\n\n            return void this.state.setCheckpoint({\n              type: \"steps-found\",\n              steps: steps,\n            });\n          }\n        });\n    };\n\n    /**\n     * A helper used to push a step to the list of steps to report.\n     */\n    const pushStepToReport = (step: FoundStep) => {\n      foundStepsToReport.set(step.id, step);\n      unhandledFoundStepsToReport.set(step.hashedId, step);\n      reportNextTick();\n    };\n\n    const stepHandler: StepHandler = async ({\n      args,\n      matchOp,\n      opts,\n    }): Promise<unknown> => {\n      await beforeExecHooksPromise;\n\n      const stepOptions = getStepOptions(args[0]);\n      const opId = matchOp(stepOptions, ...args.slice(1));\n\n      if (this.state.executingStep) {\n        /**\n         * If a step is found after asynchronous actions during another step's\n         * execution, everything is fine. The problem here is if we've found\n         * that a step nested inside another a step, which is something we don't\n         * support at the time of writing.\n         *\n         * In this case, we could use something like Async Hooks to understand\n         * how the step is being triggered, though this isn't available in all\n         * environments.\n         *\n         * Therefore, we'll only show a warning here to indicate that this is\n         * potentially an issue.\n         */\n        console.warn(\n          prettyError({\n            whatHappened: `We detected that you have nested \\`step.*\\` tooling in \\`${\n              opId.displayName ?? opId.id\n            }\\``,\n            consequences: \"Nesting `step.*` tooling is not supported.\",\n            type: \"warn\",\n            reassurance:\n              \"It's possible to see this warning if steps are separated by regular asynchronous calls, which is fine.\",\n            stack: true,\n            toFixNow:\n              \"Make sure you're not using `step.*` tooling inside of other `step.*` tooling. If you need to compose steps together, you can create a new async function and call it from within your step function, or use promise chaining.\",\n            code: ErrCode.NESTING_STEPS,\n          }),\n        );\n      }\n\n      if (this.state.steps.has(opId.id)) {\n        const originalId = opId.id;\n\n        const expectedNextIndex = expectedNextStepIndexes.get(originalId) ?? 1;\n        for (let i = expectedNextIndex; ; i++) {\n          const newId = originalId + STEP_INDEXING_SUFFIX + i;\n\n          if (!this.state.steps.has(newId)) {\n            expectedNextStepIndexes.set(originalId, i + 1);\n            opId.id = newId;\n            opId.userland.index = i;\n            break;\n          }\n        }\n      }\n\n      const { promise, resolve, reject } = createDeferredPromise();\n      const hashedId = _internals.hashId(opId.id);\n      const stepState = this.state.stepState[hashedId];\n      let isFulfilled = false;\n      if (stepState) {\n        stepState.seen = true;\n        this.state.remainingStepsToBeSeen.delete(hashedId);\n\n        if (typeof stepState.input === \"undefined\") {\n          isFulfilled = true;\n        }\n      }\n\n      let extraOpts: Record<string, unknown> | undefined;\n      let fnArgs = [...args];\n\n      if (\n        typeof stepState?.input !== \"undefined\" &&\n        Array.isArray(stepState.input)\n      ) {\n        switch (opId.op) {\n          // `step.run()` has its function input affected\n          case StepOpCode.StepPlanned: {\n            fnArgs = [...args.slice(0, 2), ...stepState.input];\n\n            extraOpts = { input: [...stepState.input] };\n            break;\n          }\n\n          // `step.ai.infer()` has its body affected\n          case StepOpCode.AiGateway: {\n            extraOpts = {\n              body: {\n                ...(typeof opId.opts?.body === \"object\"\n                  ? { ...opId.opts.body }\n                  : {}),\n                ...stepState.input[0],\n              },\n            };\n            break;\n          }\n        }\n      }\n\n      const step: FoundStep = {\n        ...opId,\n        opts: { ...opId.opts, ...extraOpts },\n        rawArgs: fnArgs, // TODO What is the right value here? Should this be raw args without affected input?\n        hashedId,\n        input: stepState?.input,\n\n        fn: opts?.fn ? () => opts.fn?.(...fnArgs) : undefined,\n        promise,\n        fulfilled: isFulfilled,\n        hasStepState: Boolean(stepState),\n        displayName: opId.displayName ?? opId.id,\n        handled: false,\n        handle: () => {\n          if (step.handled) {\n            return false;\n          }\n\n          step.handled = true;\n\n          if (isFulfilled && stepState) {\n            stepState.fulfilled = true;\n\n            // For some execution scenarios such as testing, `data`, `error`,\n            // and `input` may be `Promises`. This could also be the case for\n            // future middleware applications. For this reason, we'll make sure\n            // the values are fully resolved before continuing.\n            void Promise.all([\n              stepState.data,\n              stepState.error,\n              stepState.input,\n            ]).then(() => {\n              if (typeof stepState.data !== \"undefined\") {\n                resolve(stepState.data);\n              } else {\n                this.state.recentlyRejectedStepError = new StepError(\n                  opId.id,\n                  stepState.error,\n                );\n                reject(this.state.recentlyRejectedStepError);\n              }\n            });\n          }\n\n          return true;\n        },\n      };\n\n      this.state.steps.set(opId.id, step);\n      this.state.hasSteps = true;\n      pushStepToReport(step);\n\n      /**\n       * If this is the last piece of state we had, we've now finished\n       * memoizing.\n       */\n      if (!beforeExecHooksPromise && this.state.allStateUsed()) {\n        // biome-ignore lint/suspicious/noAssignInExpressions: <explanation>\n        await (beforeExecHooksPromise = (async () => {\n          await this.state.hooks?.afterMemoization?.();\n          await this.state.hooks?.beforeExecution?.();\n        })());\n      }\n\n      return promise;\n    };\n\n    return createStepTools(this.options.client, this, stepHandler);\n  }\n\n  private getUserFnToRun(): Handler.Any {\n    if (!this.options.isFailureHandler) {\n      return this.options.fn[\"fn\"];\n    }\n\n    if (!this.options.fn[\"onFailureFn\"]) {\n      /**\n       * Somehow, we've ended up detecting that this is a failure handler but\n       * doesn't have an `onFailure` function. This should never happen.\n       */\n      throw new Error(\"Cannot find function `onFailure` handler\");\n    }\n\n    return this.options.fn[\"onFailureFn\"];\n  }\n\n  private initializeTimer(state: V2ExecutionState): void {\n    if (!this.options.requestedRunStep) {\n      return;\n    }\n\n    this.timeout = createTimeoutPromise(this.timeoutDuration);\n\n    void this.timeout.then(async () => {\n      await this.state.hooks?.afterMemoization?.();\n      await this.state.hooks?.beforeExecution?.();\n      await this.state.hooks?.afterExecution?.();\n\n      state.setCheckpoint({\n        type: \"step-not-found\",\n        step: {\n          id: this.options.requestedRunStep as string,\n          op: StepOpCode.StepNotFound,\n        },\n      });\n    });\n  }\n\n  private async initializeMiddleware(): Promise<RunHookStack> {\n    const ctx = this.options.data as Pick<\n      Readonly<BaseContext<Inngest.Any>>,\n      \"event\" | \"events\" | \"runId\"\n    >;\n\n    const hooks = await getHookStack(\n      this.options.fn[\"middleware\"],\n      \"onFunctionRun\",\n      {\n        ctx,\n        fn: this.options.fn,\n        steps: Object.values(this.options.stepState),\n        reqArgs: this.options.reqArgs,\n      },\n      {\n        transformInput: (prev, output) => {\n          return {\n            ctx: { ...prev.ctx, ...output?.ctx },\n            fn: this.options.fn,\n            steps: prev.steps.map((step, i) => ({\n              ...step,\n              ...output?.steps?.[i],\n            })),\n            reqArgs: prev.reqArgs,\n          };\n        },\n        transformOutput: (prev, output) => {\n          return {\n            result: { ...prev.result, ...output?.result },\n            step: prev.step,\n          };\n        },\n      },\n    );\n\n    return hooks;\n  }\n}\n\n/**\n * Types of checkpoints that can be reached during execution.\n */\nexport interface Checkpoints {\n  \"steps-found\": { steps: [FoundStep, ...FoundStep[]] };\n  \"function-rejected\": { error: unknown };\n  \"function-resolved\": { data: unknown };\n  \"step-not-found\": { step: OutgoingOp };\n}\n\ntype Checkpoint = {\n  [K in keyof Checkpoints]: Simplify<{ type: K } & Checkpoints[K]>;\n}[keyof Checkpoints];\n\ntype CheckpointHandlers = {\n  [C in Checkpoint as C[\"type\"]]: (\n    checkpoint: C,\n  ) => MaybePromise<ExecutionResult | undefined>;\n} & {\n  \"\": (checkpoint: Checkpoint) => MaybePromise<void>;\n};\n\nexport interface V2ExecutionState {\n  /**\n   * A value that indicates that we're executing this step. Can be used to\n   * ensure steps are not accidentally nested until we support this across all\n   * platforms.\n   */\n  executingStep?: Readonly<Omit<OutgoingOp, \"id\">>;\n\n  /**\n   * A map of step IDs to their data, used to fill previously-completed steps\n   * with state from the executor.\n   */\n  stepState: Record<string, MemoizedOp>;\n\n  /**\n   * The number of steps we expect to fulfil based on the state passed from the\n   * Executor.\n   */\n  stepsToFulfill: number;\n\n  /**\n   * A map of step IDs to their functions to run. The executor can request a\n   * specific step to run, so we need to store the function to run here.\n   */\n  steps: Map<string, FoundStep>;\n\n  /**\n   * A flag which represents whether or not steps are understood to be used in\n   * this function. This is used to determine whether or not we should run\n   * some steps (such as `step.sendEvent`) inline as they are found.\n   */\n  hasSteps: boolean;\n\n  /**\n   * The core loop - a generator used to take an action upon finding the next\n   * checkpoint. Manages the flow of execution and cleaning up after itself.\n   */\n  loop: AsyncGenerator<Checkpoint, void, void>;\n\n  /**\n   * A function that resolves the `Promise` returned by `waitForNextDecision`.\n   */\n  setCheckpoint: (data: Checkpoint) => void;\n\n  /**\n   * Initialized middleware hooks for this execution.\n   *\n   * Middleware hooks are cached to ensure they can only be run once, which\n   * means that these hooks can be called in many different places to ensure we\n   * handle all possible execution paths.\n   */\n  hooks?: RunHookStack;\n\n  /**\n   * Returns whether or not all state passed from the executor has been used to\n   * fulfill found steps.\n   */\n  allStateUsed: () => boolean;\n\n  /**\n   * An ordered list of step IDs that represents the order in which their\n   * execution was completed.\n   */\n  stepCompletionOrder: string[];\n\n  /**\n   * An set of step IDs that have yet to be seen in this execution. Used to\n   * decide when to trigger middleware based on the current state.\n   */\n  remainingStepsToBeSeen: Set<string>;\n\n  /**\n   * If defined, this is the error that purposefully thrown when memoizing step\n   * state in order to support per-step errors.\n   *\n   * We use this so that if the function itself rejects with the same error, we\n   * know that it was entirely uncaught (or at the very least rethrown), so we\n   * should send a `NonRetriableError` to stop needless execution of a function\n   * that will continue to fail.\n   *\n   * TODO This is imperfect, as this state is currently kept around for longer\n   * than it needs to be. It should disappear as soon as we've seen that the\n   * error did not immediately throw. It may need to be refactored to work a\n   * little more smoothly with the core loop.\n   */\n  recentlyRejectedStepError?: StepError;\n}\n\nconst hashId = (id: string): string => {\n  return sha1().update(id).digest(\"hex\");\n};\n\nconst hashOp = (op: OutgoingOp): OutgoingOp => {\n  return {\n    ...op,\n    id: hashId(op.id),\n  };\n};\n\n/**\n * Exported for testing.\n */\nexport const _internals = { hashOp, hashId };\n"],"names":["createV2InngestExecution: InngestExecutionFactory","step","outgoingOp: OutgoingOp","retriable: boolean | string","loop: V2ExecutionState[\"loop\"]","foundStepsToReport: Map<string, FoundStep>","unhandledFoundStepsToReport: Map<string, FoundStep>","expectedNextStepIndexes: Map<string, number>","foundStepsReportPromise: Promise<void> | undefined","beforeExecHooksPromise: Promise<void> | undefined","stepHandler: StepHandler","extraOpts: Record<string, unknown> | undefined","step: FoundStep"],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3964, "column": 0}, "map": {"version":3,"file":"v1.js","sources":["file:///Users/amansatyawani/Desktop/website-builder/node_modules/.pnpm/inngest%403.45.1_%40opentelemetry%2Bcore%402.2.0_%40opentelemetry%2Bapi%401.9.0__express%405.1.0_next%401_e029d374516642dd9a767b32fbb0beec/node_modules/src/components/execution/v1.ts"],"sourcesContent":["import { trace } from \"@opentelemetry/api\";\nimport hashjs from \"hash.js\";\nimport { z } from \"zod/v3\";\nimport {\n  ExecutionVersion,\n  headerKeys,\n  internalEvents,\n} from \"../../helpers/consts.ts\";\nimport {\n  deserializeError,\n  ErrCode,\n  minifyPrettyError,\n  prettyError,\n  serializeError,\n} from \"../../helpers/errors.js\";\nimport { undefinedToNull } from \"../../helpers/functions.js\";\nimport {\n  createDeferredPromise,\n  createDeferredPromiseWithStack,\n  createTimeoutPromise,\n  resolveAfterPending,\n  resolveNextTick,\n  runAsPromise,\n} from \"../../helpers/promises.ts\";\nimport type { MaybePromise, Simplify } from \"../../helpers/types.ts\";\nimport {\n  type APIStepPayload,\n  type BaseContext,\n  type Context,\n  type EventPayload,\n  type FailureEventArgs,\n  type Handler,\n  jsonErrorSchema,\n  type OutgoingOp,\n  StepMode,\n  StepOpCode,\n} from \"../../types.ts\";\nimport { version } from \"../../version.ts\";\nimport type { Inngest } from \"../Inngest.ts\";\nimport type { ActionResponse } from \"../InngestCommHandler\";\nimport { getHookStack, type RunHookStack } from \"../InngestMiddleware.ts\";\nimport {\n  createStepTools,\n  type FoundStep,\n  getStepOptions,\n  invokePayloadSchema,\n  STEP_INDEXING_SUFFIX,\n  type StepHandler,\n} from \"../InngestStepTools.ts\";\nimport { NonRetriableError } from \"../NonRetriableError.ts\";\nimport { RetryAfterError } from \"../RetryAfterError.ts\";\nimport { StepError } from \"../StepError.ts\";\nimport { getAsyncCtx, getAsyncLocalStorage } from \"./als.ts\";\nimport {\n  type ExecutionResult,\n  type IInngestExecution,\n  InngestExecution,\n  type InngestExecutionFactory,\n  type InngestExecutionOptions,\n  type MemoizedOp,\n} from \"./InngestExecution.ts\";\nimport { clientProcessorMap } from \"./otel/access.ts\";\n\nconst { sha1 } = hashjs;\n\nexport const createV1InngestExecution: InngestExecutionFactory = (options) => {\n  return new V1InngestExecution(options);\n};\n\nclass V1InngestExecution extends InngestExecution implements IInngestExecution {\n  public version = ExecutionVersion.V1;\n\n  private state: V1ExecutionState;\n  private fnArg: Context.Any;\n  private checkpointHandlers: CheckpointHandlers;\n  private timeoutDuration = 1000 * 10;\n  private execution: Promise<ExecutionResult> | undefined;\n  private userFnToRun: Handler.Any;\n\n  /**\n   * If we're supposed to run a particular step via `requestedRunStep`, this\n   * will be a `Promise` that resolves after no steps have been found for\n   * `timeoutDuration` milliseconds.\n   *\n   * If we're not supposed to run a particular step, this will be `undefined`.\n   */\n  private timeout?: ReturnType<typeof createTimeoutPromise>;\n\n  constructor(options: InngestExecutionOptions) {\n    super(options);\n\n    /**\n     * Check we have everything we need for checkpointing\n     */\n    if (this.options.stepMode === StepMode.Sync) {\n      if (!this.options.createResponse) {\n        throw new Error(\"createResponse is required for sync step mode\");\n      }\n    }\n\n    this.userFnToRun = this.getUserFnToRun();\n    this.state = this.createExecutionState();\n    this.fnArg = this.createFnArg();\n    this.checkpointHandlers =\n      this.options.stepMode === StepMode.Sync\n        ? this.createCheckpointingCheckpointHandlers()\n        : this.createCheckpointHandlers();\n    this.initializeTimer(this.state);\n\n    this.debug(\n      \"created new V1 execution for run;\",\n      this.options.requestedRunStep\n        ? `wanting to run step \"${this.options.requestedRunStep}\"`\n        : \"discovering steps\",\n    );\n\n    this.debug(\"existing state keys:\", Object.keys(this.state.stepState));\n  }\n\n  /**\n   * Idempotently start the execution of the user's function.\n   */\n  public start() {\n    if (!this.execution) {\n      this.debug(\"starting V1 execution\");\n\n      const tracer = trace.getTracer(\"inngest\", version);\n\n      this.execution = getAsyncLocalStorage().then((als) => {\n        return als.run(\n          {\n            app: this.options.client,\n            execution: {\n              ctx: this.fnArg,\n              instance: this,\n            },\n          },\n          async () => {\n            return tracer.startActiveSpan(\"inngest.execution\", (span) => {\n              clientProcessorMap.get(this.options.client)?.declareStartingSpan({\n                span,\n                runId: this.options.runId,\n                traceparent: this.options.headers[headerKeys.TraceParent],\n                tracestate: this.options.headers[headerKeys.TraceState],\n              });\n\n              return this._start()\n                .then((result) => {\n                  this.debug(\"result:\", result);\n                  return result;\n                })\n                .finally(() => {\n                  span.end();\n                });\n            });\n          },\n        );\n      });\n    }\n\n    return this.execution;\n  }\n\n  /**\n   * Starts execution of the user's function and the core loop.\n   */\n  private async _start(): Promise<ExecutionResult> {\n    try {\n      const allCheckpointHandler = this.getCheckpointHandler(\"\");\n      this.state.hooks = await this.initializeMiddleware();\n      await this.startExecution();\n\n      let i = 0;\n\n      for await (const checkpoint of this.state.loop) {\n        await allCheckpointHandler(checkpoint, i);\n\n        const handler = this.getCheckpointHandler(checkpoint.type);\n        const result = await handler(checkpoint, i++);\n\n        if (result) {\n          return result;\n        }\n      }\n    } catch (error) {\n      return await this.transformOutput({ error });\n    } finally {\n      void this.state.loop.return();\n      await this.state.hooks?.beforeResponse?.();\n    }\n\n    /**\n     * If we're here, the generator somehow finished without returning a value.\n     * This should never happen.\n     */\n    throw new Error(\"Core loop finished without returning a value\");\n  }\n\n  private async checkpoint(steps: OutgoingOp[]): Promise<void> {\n    if (!this.state.checkpointedRun) {\n      // We have to start the run\n      const res = await this.options.client[\"inngestApi\"].checkpointNewRun({\n        runId: this.fnArg.runId,\n        event: this.fnArg.event as APIStepPayload,\n        steps,\n      });\n\n      this.state.checkpointedRun = {\n        appId: res.data.app_id,\n        fnId: res.data.fn_id,\n        token: res.data.token,\n      };\n    } else {\n      await this.options.client[\"inngestApi\"].checkpointSteps({\n        appId: this.state.checkpointedRun.appId,\n        fnId: this.state.checkpointedRun.fnId,\n        runId: this.fnArg.runId,\n        steps,\n      });\n    }\n  }\n\n  private async checkpointAndSwitchToAsync(\n    steps: OutgoingOp[],\n  ): Promise<ExecutionResult> {\n    await this.checkpoint(steps);\n\n    if (!this.state.checkpointedRun?.token) {\n      throw new Error(\"Failed to checkpoint and switch to async mode\");\n    }\n\n    return {\n      type: \"change-mode\",\n      ctx: this.fnArg,\n      ops: this.ops,\n      to: StepMode.Async,\n      token: this.state.checkpointedRun?.token!,\n    };\n  }\n\n  /**\n   * Returns whether we're in the final attempt of execution, or `null` if we\n   * can't determine this in the SDK.\n   */\n  private inFinalAttempt(): boolean | null {\n    if (typeof this.fnArg.maxAttempts !== \"number\") {\n      return null;\n    }\n\n    return this.fnArg.attempt + 1 >= this.fnArg.maxAttempts;\n  }\n\n  private createCheckpointingCheckpointHandlers(): CheckpointHandlers {\n    return {\n      /**\n       * Run for all checkpoints. Best used for logging or common actions.\n       * Use other handlers to return values and interrupt the core loop.\n       */\n      \"\": async (checkpoint, i) => {\n        this.debug(\"sync checkpoint:\", checkpoint);\n      },\n\n      \"function-resolved\": async (checkpoint, i) => {\n        await this.checkpoint([\n          {\n            op: StepOpCode.RunComplete,\n            id: _internals.hashId(\"complete\"), // TODO bad ID\n            data: await this.options.createResponse!(checkpoint.data),\n          },\n        ]);\n\n        // Done - just return the value\n        return {\n          type: \"function-resolved\",\n          ctx: this.fnArg,\n          ops: this.ops,\n          data: checkpoint.data,\n        };\n      },\n\n      \"function-rejected\": (checkpoint) => {\n        // If the function throws during sync execution, we want to switch to\n        // async mode so that we can retry. The exception is that we're already\n        // at max attempts, in which case we do actually want to reject.\n        if (this.inFinalAttempt()) {\n          return {\n            type: \"function-rejected\",\n            ctx: this.fnArg,\n            error: checkpoint.error,\n            ops: this.ops,\n            retriable: false,\n          };\n        }\n\n        // Otherwise, checkpoint the error and switch to async mode\n        return this.checkpointAndSwitchToAsync([\n          {\n            id: _internals.hashId(\"complete\"), // TODO bad ID, bad use of _internals here\n            displayName: \"complete\", // TODO bad display name\n            op: StepOpCode.StepError,\n            error: checkpoint.error,\n          },\n        ]);\n      },\n\n      \"step-not-found\": ({ step }) => {\n        return {\n          type: \"function-rejected\",\n          ctx: this.fnArg,\n          error: new Error(\n            \"Step not found when checkpointing; this should never happen\",\n          ),\n          ops: this.ops,\n          retriable: false,\n        };\n      },\n\n      \"steps-found\": async ({ steps }) => {\n        // If we're entering parallelism or async mode, checkpoint and switch\n        // to async.\n        if (steps.length !== 1 || steps[0].mode !== StepMode.Sync) {\n          return this.checkpointAndSwitchToAsync(\n            steps.map((step) => ({ ...step, id: step.hashedId })),\n          );\n        }\n\n        // Otherwise we're good to start executing things right now.\n        const step = this.state.steps.get(steps[0].id);\n        if (!step) {\n          throw new Error(\n            \"Step not found in memoization state; this should never happen and is a bug in the Inngest SDK\",\n          );\n        }\n\n        // TODO extract timing\n        const start = Date.now();\n        const result = await this.executeStep(step);\n        const interval = {\n          a: start * 1_000_000,\n          b: (Date.now() - start) * 1_000_000,\n        };\n\n        if (result.error) {\n          // The step errored, so now we go async. Let's checkpoint and change\n          // the mode.\n          await this.checkpoint([\n            {\n              ...step,\n              op:\n                step.op === StepOpCode.StepPlanned\n                  ? StepOpCode.StepError\n                  : step.op,\n              error: result.error,\n            },\n          ]);\n          if (!this.state.checkpointedRun?.token) {\n            throw new Error(\n              \"Failed to checkpoint and switch to async mode as no token was returned from the API\",\n            );\n          }\n\n          return {\n            type: \"change-mode\",\n            ctx: this.fnArg,\n            ops: this.ops,\n            to: StepMode.Async,\n            token: this.state.checkpointedRun.token,\n          };\n        }\n\n        if (\"data\" in result) {\n          // If we're here, the step succeeded - let's checkpoint the result and\n          // resume execution.\n          step.data = result.data;\n\n          this.state.stepState[steps[0].hashedId] = step;\n          step.fulfilled = true; // TODO We can wrap all of this up in a direct function on the `FoundStep`\n\n          await this.checkpoint([\n            {\n              id: step.hashedId,\n              data: step.data,\n              // TODO This should also be wrapped up on the `FoundStep`\n              op:\n                step.op === StepOpCode.StepPlanned\n                  ? StepOpCode.StepRun\n                  : step.op,\n              displayName: step.displayName,\n              opts: step.opts,\n              userland: step.userland,\n              name: step.name,\n              timing: interval,\n            },\n          ]);\n\n          // resume execution\n          step.handle();\n\n          return;\n        }\n\n        throw new Error(\n          \"A step was run and had no data or error; this is a bug in the Inngest SDK\",\n        );\n      },\n    };\n  }\n\n  /**\n   * Creates a handler for every checkpoint type, defining what to do when we\n   * reach that checkpoint in the core loop.\n   */\n  private createCheckpointHandlers(): CheckpointHandlers {\n    return {\n      /**\n       * Run for all checkpoints. Best used for logging or common actions.\n       * Use other handlers to return values and interrupt the core loop.\n       */\n      \"\": (checkpoint) => {\n        this.debug(\"async checkpoint:\", checkpoint);\n      },\n\n      /**\n       * The user's function has completed and returned a value.\n       */\n      \"function-resolved\": async ({ data }) => {\n        if (this.options.createResponse) {\n          data = await this.options.createResponse(data);\n        }\n\n        return await this.transformOutput({ data });\n      },\n\n      /**\n       * The user's function has thrown an error.\n       */\n      \"function-rejected\": async (checkpoint) => {\n        return await this.transformOutput({ error: checkpoint.error });\n      },\n\n      /**\n       * We've found one or more steps. Here we may want to run a step or report\n       * them back to Inngest.\n       */\n      \"steps-found\": async ({ steps }) => {\n        const stepResult = await this.tryExecuteStep(steps);\n        if (stepResult) {\n          const transformResult = await this.transformOutput(stepResult);\n\n          /**\n           * Transforming output will always return either function rejection or\n           * resolution. In most cases, this can be immediately returned, but in\n           * this particular case we want to handle it differently.\n           */\n          if (transformResult.type === \"function-resolved\") {\n            return {\n              type: \"step-ran\",\n              ctx: transformResult.ctx,\n              ops: transformResult.ops,\n              step: _internals.hashOp({\n                ...stepResult,\n                data: transformResult.data,\n              }),\n            };\n          } else if (transformResult.type === \"function-rejected\") {\n            const stepForResponse = _internals.hashOp({\n              ...stepResult,\n              error: transformResult.error,\n            });\n\n            if (stepResult.op === StepOpCode.StepFailed) {\n              const ser = serializeError(transformResult.error);\n              stepForResponse.data = {\n                __serialized: true,\n                name: ser.name,\n                message: ser.message,\n                stack: \"\",\n              };\n            }\n\n            return {\n              type: \"step-ran\",\n              ctx: transformResult.ctx,\n              ops: transformResult.ops,\n              retriable: transformResult.retriable,\n              step: stepForResponse,\n            };\n          }\n\n          return transformResult;\n        }\n\n        const newSteps = await this.filterNewSteps(\n          Array.from(this.state.steps.values()),\n        );\n        if (newSteps) {\n          return {\n            type: \"steps-found\",\n            ctx: this.fnArg,\n            ops: this.ops,\n            steps: newSteps,\n          };\n        }\n\n        return;\n      },\n\n      /**\n       * While trying to find a step that Inngest has told us to run, we've\n       * timed out or have otherwise decided that it doesn't exist.\n       */\n      \"step-not-found\": ({ step }) => {\n        return { type: \"step-not-found\", ctx: this.fnArg, ops: this.ops, step };\n      },\n    };\n  }\n\n  private getCheckpointHandler(type: keyof CheckpointHandlers) {\n    return this.checkpointHandlers[type] as (\n      checkpoint: Checkpoint,\n      iteration: number,\n    ) => MaybePromise<ExecutionResult | undefined>;\n  }\n\n  private async tryExecuteStep(\n    steps: FoundStep[],\n  ): Promise<OutgoingOp | undefined> {\n    const hashedStepIdToRun =\n      this.options.requestedRunStep || this.getEarlyExecRunStep(steps);\n    if (!hashedStepIdToRun) {\n      return;\n    }\n\n    const step = steps.find(\n      (step) => step.hashedId === hashedStepIdToRun && step.fn,\n    );\n\n    if (step) {\n      return await this.executeStep(step);\n    }\n\n    /**\n     * Ensure we reset the timeout if we have a requested run step but couldn't\n     * find it, but also that we don't reset if we found and executed it.\n     */\n    return void this.timeout?.reset();\n  }\n\n  /**\n   * Given a list of outgoing ops, decide if we can execute an op early and\n   * return the ID of the step to execute if we can.\n   */\n  private getEarlyExecRunStep(steps: FoundStep[]): string | undefined {\n    /**\n     * We may have been disabled due to parallelism, in which case we can't\n     * immediately execute unless explicitly requested.\n     */\n    if (this.options.disableImmediateExecution) return;\n\n    const unfulfilledSteps = steps.filter((step) => !step.fulfilled);\n    if (unfulfilledSteps.length !== 1) return;\n\n    const op = unfulfilledSteps[0];\n\n    if (\n      op &&\n      op.op === StepOpCode.StepPlanned\n      // TODO We must individually check properties here that we do not want to\n      // execute on, such as retry counts. Nothing exists here that falls in to\n      // this case, but should be accounted for when we add them.\n      // && typeof op.opts === \"undefined\"\n    ) {\n      return op.hashedId;\n    }\n\n    return;\n  }\n\n  private async filterNewSteps(\n    foundSteps: FoundStep[],\n  ): Promise<[OutgoingOp, ...OutgoingOp[]] | undefined> {\n    if (this.options.requestedRunStep) {\n      return;\n    }\n\n    /**\n     * Gather any steps that aren't memoized and report them.\n     */\n    const newSteps = foundSteps.filter((step) => !step.fulfilled);\n\n    if (!newSteps.length) {\n      return;\n    }\n\n    /**\n     * Warn if we've found new steps but haven't yet seen all previous\n     * steps. This may indicate that step presence isn't determinate.\n     */\n    let knownSteps = 0;\n    for (const step of foundSteps) {\n      if (step.fulfilled) {\n        knownSteps++;\n      }\n    }\n    const foundAllCompletedSteps = this.state.stepsToFulfill === knownSteps;\n\n    if (!foundAllCompletedSteps) {\n      // TODO Tag\n      console.warn(\n        prettyError({\n          type: \"warn\",\n          whatHappened: \"Function may be indeterminate\",\n          why: \"We found new steps before seeing all previous steps, which may indicate that the function is non-deterministic.\",\n          consequences:\n            \"This may cause unexpected behaviour as Inngest executes your function.\",\n          reassurance:\n            \"This is expected if a function is updated in the middle of a run, but may indicate a bug if not.\",\n        }),\n      );\n    }\n\n    /**\n     * We're finishing up; let's trigger the last of the hooks.\n     */\n    await this.state.hooks?.afterMemoization?.();\n    await this.state.hooks?.beforeExecution?.();\n    await this.state.hooks?.afterExecution?.();\n\n    const stepList = newSteps.map<OutgoingOp>((step) => ({\n      displayName: step.displayName,\n      op: step.op,\n      id: step.hashedId,\n      name: step.name,\n      opts: step.opts,\n      userland: step.userland,\n    })) as [OutgoingOp, ...OutgoingOp[]];\n\n    /**\n     * We also run `onSendEvent` middleware hooks against `step.invoke()` steps\n     * to ensure that their `data` is transformed correctly.\n     */\n    return await this.transformNewSteps(stepList);\n  }\n\n  /**\n   * Using middleware, transform any newly-found steps before returning them to\n   * an Inngest Server.\n   */\n  private async transformNewSteps<T extends [OutgoingOp, ...OutgoingOp[]]>(\n    steps: T,\n  ): Promise<T> {\n    return Promise.all(\n      steps.map(async (step) => {\n        if (step.op !== StepOpCode.InvokeFunction) {\n          return step;\n        }\n\n        const onSendEventHooks = await getHookStack(\n          this.options.fn[\"middleware\"],\n          \"onSendEvent\",\n          undefined,\n          {\n            transformInput: (prev, output) => {\n              return { ...prev, ...output };\n            },\n            transformOutput: (prev, output) => {\n              return {\n                result: { ...prev.result, ...output?.result },\n              };\n            },\n          },\n        );\n\n        /**\n         * For each event being sent, create a new `onSendEvent` hook stack to\n         * process it. We do this as middleware hooks are intended to run once\n         * during each lifecycle (onFunctionRun or onSendEvent) and here, a hook\n         * is run for every single event.\n         *\n         * This is done because a developer can use this hook to filter out\n         * events entirely; if we batch all of the events together, we can't\n         * tell which ones were filtered out if we're processing >1 invocation\n         * here.\n         */\n        const transformedPayload = await onSendEventHooks.transformInput?.({\n          payloads: [\n            {\n              ...(step.opts?.payload ?? {}),\n              name: internalEvents.FunctionInvoked,\n            },\n          ],\n        });\n\n        const newPayload = invokePayloadSchema.parse(\n          transformedPayload?.payloads?.[0] ?? {},\n        );\n\n        return {\n          ...step,\n          opts: {\n            ...step.opts,\n            payload: {\n              ...(step.opts?.payload ?? {}),\n              ...newPayload,\n            },\n          },\n        };\n      }),\n    ) as Promise<T>;\n  }\n\n  private async executeStep({\n    id,\n    name,\n    opts,\n    fn,\n    displayName,\n    userland,\n  }: FoundStep): Promise<OutgoingOp> {\n    this.timeout?.clear();\n    await this.state.hooks?.afterMemoization?.();\n    await this.state.hooks?.beforeExecution?.();\n\n    const outgoingOp: OutgoingOp = {\n      id,\n      op: StepOpCode.StepRun,\n      name,\n      opts,\n      displayName,\n      userland,\n    };\n    this.state.executingStep = outgoingOp;\n\n    const store = await getAsyncCtx();\n\n    if (store?.execution) {\n      store.execution.executingStep = {\n        id,\n        name: displayName,\n      };\n    }\n\n    this.debug(`executing step \"${id}\"`);\n\n    return runAsPromise(fn)\n      .finally(async () => {\n        delete this.state.executingStep;\n        if (store?.execution) {\n          delete store.execution.executingStep;\n        }\n\n        await this.state.hooks?.afterExecution?.();\n      })\n      .then<OutgoingOp>((data) => {\n        return {\n          ...outgoingOp,\n          data,\n        };\n      })\n      .catch<OutgoingOp>((error) => {\n        let errorIsRetriable = true;\n\n        if (error instanceof NonRetriableError) {\n          errorIsRetriable = false;\n        } else if (\n          this.fnArg.maxAttempts &&\n          this.fnArg?.maxAttempts - 1 === this.fnArg.attempt\n        ) {\n          errorIsRetriable = false;\n        }\n\n        if (errorIsRetriable) {\n          return {\n            ...outgoingOp,\n            op: StepOpCode.StepError,\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n            error,\n          };\n        } else {\n          return {\n            ...outgoingOp,\n            op: StepOpCode.StepFailed,\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n            error,\n          };\n        }\n      });\n  }\n\n  /**\n   * Starts execution of the user's function, including triggering checkpoints\n   * and middleware hooks where appropriate.\n   */\n  private async startExecution(): Promise<void> {\n    /**\n     * Mutate input as neccessary based on middleware.\n     */\n    await this.transformInput();\n\n    /**\n     * Start the timer to time out the run if needed.\n     */\n    void this.timeout?.start();\n\n    await this.state.hooks?.beforeMemoization?.();\n\n    /**\n     * If we had no state to begin with, immediately end the memoization phase.\n     */\n    if (this.state.allStateUsed()) {\n      await this.state.hooks?.afterMemoization?.();\n      await this.state.hooks?.beforeExecution?.();\n    }\n\n    /**\n     * Trigger the user's function.\n     */\n    runAsPromise(() => this.userFnToRun(this.fnArg))\n      .finally(async () => {\n        await this.state.hooks?.afterMemoization?.();\n        await this.state.hooks?.beforeExecution?.();\n        await this.state.hooks?.afterExecution?.();\n      })\n      .then((data) => {\n        this.state.setCheckpoint({ type: \"function-resolved\", data });\n      })\n      .catch((error) => {\n        this.state.setCheckpoint({ type: \"function-rejected\", error });\n      });\n  }\n\n  /**\n   * Using middleware, transform input before running.\n   */\n  private async transformInput() {\n    const inputMutations = await this.state.hooks?.transformInput?.({\n      ctx: { ...this.fnArg },\n      steps: Object.values(this.state.stepState),\n      fn: this.options.fn,\n      reqArgs: this.options.reqArgs,\n    });\n\n    if (inputMutations?.ctx) {\n      this.fnArg = inputMutations.ctx;\n    }\n\n    if (inputMutations?.steps) {\n      this.state.stepState = Object.fromEntries(\n        inputMutations.steps.map((step) => [step.id, step]),\n      );\n    }\n  }\n\n  /**\n   * Using middleware, transform output before returning.\n   */\n  private async transformOutput(\n    dataOrError: Parameters<\n      NonNullable<RunHookStack[\"transformOutput\"]>\n    >[0][\"result\"],\n  ): Promise<ExecutionResult> {\n    const output = { ...dataOrError } as Partial<OutgoingOp>;\n\n    const isStepExecution = Boolean(this.state.executingStep);\n\n    const transformedOutput = await this.state.hooks?.transformOutput?.({\n      result: { ...output },\n      step: this.state.executingStep,\n    });\n\n    const { data, error } = { ...output, ...transformedOutput?.result };\n\n    if (!isStepExecution) {\n      await this.state.hooks?.finished?.({\n        result: { ...(typeof error !== \"undefined\" ? { error } : { data }) },\n      });\n    }\n\n    if (typeof error !== \"undefined\") {\n      /**\n       * Ensure we give middleware the chance to decide on retriable behaviour\n       * by looking at the error returned from output transformation.\n       */\n      let retriable: boolean | string = !(\n        error instanceof NonRetriableError ||\n        (error instanceof StepError &&\n          error === this.state.recentlyRejectedStepError)\n      );\n      if (retriable && error instanceof RetryAfterError) {\n        retriable = error.retryAfter;\n      }\n\n      const serializedError = minifyPrettyError(serializeError(error));\n\n      return {\n        type: \"function-rejected\",\n        ctx: this.fnArg,\n        ops: this.ops,\n        error: serializedError,\n        retriable,\n      };\n    }\n\n    return {\n      type: \"function-resolved\",\n      ctx: this.fnArg,\n      ops: this.ops,\n      data: undefinedToNull(data),\n    };\n  }\n\n  private createExecutionState(): V1ExecutionState {\n    const d = createDeferredPromiseWithStack<Checkpoint>();\n    let checkpointResolve = d.deferred.resolve;\n    const checkpointResults = d.results;\n\n    const loop: V1ExecutionState[\"loop\"] = (async function* (\n      cleanUp?: () => void,\n    ) {\n      try {\n        while (true) {\n          const res = (await checkpointResults.next()).value;\n          if (res) {\n            yield res;\n          }\n        }\n      } finally {\n        cleanUp?.();\n      }\n    })(() => {\n      this.timeout?.clear();\n      void checkpointResults.return();\n    });\n\n    const stepsToFulfill = Object.keys(this.options.stepState).length;\n\n    const state: V1ExecutionState = {\n      stepState: this.options.stepState,\n      stepsToFulfill,\n      steps: new Map(),\n      loop,\n      hasSteps: Boolean(stepsToFulfill),\n      stepCompletionOrder: [...this.options.stepCompletionOrder],\n      remainingStepsToBeSeen: new Set(this.options.stepCompletionOrder),\n      setCheckpoint: (checkpoint: Checkpoint) => {\n        ({ resolve: checkpointResolve } = checkpointResolve(checkpoint));\n      },\n      allStateUsed: () => {\n        return this.state.remainingStepsToBeSeen.size === 0;\n      },\n    };\n\n    return state;\n  }\n\n  get ops(): Record<string, MemoizedOp> {\n    return Object.fromEntries(this.state.steps);\n  }\n\n  private createFnArg(): Context.Any {\n    const step = this.createStepTools();\n\n    let fnArg = {\n      ...(this.options.data as { event: EventPayload }),\n      step,\n    } as Context.Any;\n\n    /**\n     * Handle use of the `onFailure` option by deserializing the error.\n     */\n    if (this.options.isFailureHandler) {\n      const eventData = z\n        .object({ error: jsonErrorSchema })\n        .parse(fnArg.event?.data);\n\n      (fnArg as Partial<Pick<FailureEventArgs, \"error\">>) = {\n        ...fnArg,\n        error: deserializeError(eventData.error),\n      };\n    }\n\n    return this.options.transformCtx?.(fnArg) ?? fnArg;\n  }\n\n  private createStepTools(): ReturnType<typeof createStepTools> {\n    /**\n     * A list of steps that have been found and are being rolled up before being\n     * reported to the core loop.\n     */\n    const foundStepsToReport: Map<string, FoundStep> = new Map();\n\n    /**\n     * A map of the subset of found steps to report that have not yet been\n     * handled. Used for fast access to steps that need to be handled in order.\n     */\n    const unhandledFoundStepsToReport: Map<string, FoundStep> = new Map();\n\n    /**\n     * A map of the latest sequential step indexes found for each step ID. Used\n     * to ensure that we don't index steps in parallel.\n     *\n     * Note that these must be sequential; if we've seen or assigned `a:1`,\n     * `a:2` and `a:4`, the latest sequential step index is `2`.\n     *\n     */\n    const expectedNextStepIndexes: Map<string, number> = new Map();\n\n    /**\n     * An ordered list of step IDs that have yet to be handled in this\n     * execution. Used to ensure that we handle steps in the order they were\n     * found and based on the `stepCompletionOrder` in this execution's state.\n     */\n    const remainingStepCompletionOrder: string[] =\n      this.state.stepCompletionOrder.slice();\n\n    /**\n     * A promise that's used to ensure that step reporting cannot be run more than\n     * once in a given asynchronous time span.\n     */\n    let foundStepsReportPromise: Promise<void> | undefined;\n\n    /**\n     * A promise that's used to represent middleware hooks running before\n     * execution.\n     */\n    let beforeExecHooksPromise: Promise<void> | undefined;\n\n    /**\n     * A flag used to ensure that we only warn about parallel indexing once per\n     * execution to avoid spamming the console.\n     */\n    let warnOfParallelIndexing = false;\n\n    /**\n     * Counts the number of times we've extended this tick.\n     */\n    let tickExtensionCount = 0;\n\n    /**\n     * Given a colliding step ID, maybe warn the user about parallel indexing.\n     */\n    const maybeWarnOfParallelIndexing = (collisionId: string) => {\n      if (warnOfParallelIndexing) {\n        return;\n      }\n\n      const stepExists = this.state.steps.has(collisionId);\n      if (stepExists) {\n        const stepFoundThisTick = foundStepsToReport.has(collisionId);\n        if (!stepFoundThisTick) {\n          warnOfParallelIndexing = true;\n\n          console.warn(\n            prettyError({\n              type: \"warn\",\n              whatHappened:\n                \"We detected that you have multiple steps with the same ID.\",\n              code: ErrCode.AUTOMATIC_PARALLEL_INDEXING,\n              why: `This can happen if you're using the same ID for multiple steps across different chains of parallel work. We found the issue with step \"${collisionId}\".`,\n              reassurance:\n                \"Your function is still running, though it may exhibit unexpected behaviour.\",\n              consequences:\n                \"Using the same IDs across parallel chains of work can cause unexpected behaviour.\",\n              toFixNow:\n                \"We recommend using a unique ID for each step, especially those happening in parallel.\",\n            }),\n          );\n        }\n      }\n    };\n\n    /**\n     * A helper used to report steps to the core loop. Used after adding an item\n     * to `foundStepsToReport`.\n     */\n    const reportNextTick = () => {\n      // Being explicit instead of using `??=` to appease TypeScript.\n      if (foundStepsReportPromise) {\n        return;\n      }\n\n      let extensionPromise: Promise<void>;\n      if (++tickExtensionCount >= 10) {\n        tickExtensionCount = 0;\n        extensionPromise = resolveNextTick();\n      } else {\n        extensionPromise = resolveAfterPending();\n      }\n\n      foundStepsReportPromise = extensionPromise\n        /**\n         * Ensure that we wait for this promise to resolve before continuing.\n         *\n         * The groups in which steps are reported can affect how we detect some\n         * more complex determinism issues like parallel indexing. This promise\n         * can represent middleware hooks being run early, in the middle of\n         * ingesting steps to report.\n         *\n         * Because of this, it's important we wait for this middleware to resolve\n         * before continuing to report steps to ensure that all steps have a\n         * chance to be reported throughout this asynchronous action.\n         */\n        .then(() => beforeExecHooksPromise)\n        .then(() => {\n          foundStepsReportPromise = undefined;\n\n          for (let i = 0; i < remainingStepCompletionOrder.length; i++) {\n            const nextStepId = remainingStepCompletionOrder[i];\n            if (!nextStepId) {\n              // Strange - skip this empty index\n              continue;\n            }\n\n            const handled = unhandledFoundStepsToReport\n              .get(nextStepId)\n              ?.handle();\n            if (handled) {\n              remainingStepCompletionOrder.splice(i, 1);\n              unhandledFoundStepsToReport.delete(nextStepId);\n              return void reportNextTick();\n            }\n          }\n\n          // If we've handled no steps in this \"tick,\" roll up everything we've\n          // found and report it.\n          const steps = [...foundStepsToReport.values()] as [\n            FoundStep,\n            ...FoundStep[],\n          ];\n          foundStepsToReport.clear();\n          unhandledFoundStepsToReport.clear();\n\n          return void this.state.setCheckpoint({\n            type: \"steps-found\",\n            steps: steps,\n          });\n        });\n    };\n\n    /**\n     * A helper used to push a step to the list of steps to report.\n     */\n    const pushStepToReport = (step: FoundStep) => {\n      foundStepsToReport.set(step.id, step);\n      unhandledFoundStepsToReport.set(step.hashedId, step);\n      reportNextTick();\n    };\n\n    const stepHandler: StepHandler = async ({\n      args,\n      matchOp,\n      opts,\n    }): Promise<unknown> => {\n      await beforeExecHooksPromise;\n\n      const stepOptions = getStepOptions(args[0]);\n      const opId = matchOp(stepOptions, ...args.slice(1));\n\n      if (this.state.executingStep) {\n        /**\n         * If a step is found after asynchronous actions during another step's\n         * execution, everything is fine. The problem here is if we've found\n         * that a step nested inside another a step, which is something we don't\n         * support at the time of writing.\n         *\n         * In this case, we could use something like Async Hooks to understand\n         * how the step is being triggered, though this isn't available in all\n         * environments.\n         *\n         * Therefore, we'll only show a warning here to indicate that this is\n         * potentially an issue.\n         */\n        console.warn(\n          prettyError({\n            whatHappened: `We detected that you have nested \\`step.*\\` tooling in \\`${\n              opId.displayName ?? opId.id\n            }\\``,\n            consequences: \"Nesting `step.*` tooling is not supported.\",\n            type: \"warn\",\n            reassurance:\n              \"It's possible to see this warning if steps are separated by regular asynchronous calls, which is fine.\",\n            stack: true,\n            toFixNow:\n              \"Make sure you're not using `step.*` tooling inside of other `step.*` tooling. If you need to compose steps together, you can create a new async function and call it from within your step function, or use promise chaining.\",\n            code: ErrCode.NESTING_STEPS,\n          }),\n        );\n      }\n\n      if (this.state.steps.has(opId.id)) {\n        const originalId = opId.id;\n        maybeWarnOfParallelIndexing(originalId);\n\n        const expectedNextIndex = expectedNextStepIndexes.get(originalId) ?? 1;\n        for (let i = expectedNextIndex; ; i++) {\n          const newId = originalId + STEP_INDEXING_SUFFIX + i;\n\n          if (!this.state.steps.has(newId)) {\n            expectedNextStepIndexes.set(originalId, i + 1);\n            opId.id = newId;\n            opId.userland.index = i;\n            break;\n          }\n        }\n      }\n\n      const { promise, resolve, reject } = createDeferredPromise();\n      const hashedId = _internals.hashId(opId.id);\n      const stepState = this.state.stepState[hashedId];\n      let isFulfilled = false;\n      if (stepState) {\n        stepState.seen = true;\n        this.state.remainingStepsToBeSeen.delete(hashedId);\n\n        if (typeof stepState.input === \"undefined\") {\n          isFulfilled = true;\n        }\n      }\n\n      let extraOpts: Record<string, unknown> | undefined;\n      let fnArgs = [...args];\n\n      if (\n        typeof stepState?.input !== \"undefined\" &&\n        Array.isArray(stepState.input)\n      ) {\n        switch (opId.op) {\n          // `step.run()` has its function input affected\n          case StepOpCode.StepPlanned: {\n            fnArgs = [...args.slice(0, 2), ...stepState.input];\n\n            extraOpts = { input: [...stepState.input] };\n            break;\n          }\n\n          // `step.ai.infer()` has its body affected\n          case StepOpCode.AiGateway: {\n            extraOpts = {\n              body: {\n                ...(typeof opId.opts?.body === \"object\"\n                  ? { ...opId.opts.body }\n                  : {}),\n                ...stepState.input[0],\n              },\n            };\n            break;\n          }\n        }\n      }\n\n      const step: FoundStep = {\n        ...opId,\n        opts: { ...opId.opts, ...extraOpts },\n        rawArgs: fnArgs, // TODO What is the right value here? Should this be raw args without affected input?\n        hashedId,\n        input: stepState?.input,\n\n        fn: opts?.fn ? () => opts.fn?.(...fnArgs) : undefined,\n        promise,\n        fulfilled: isFulfilled,\n        hasStepState: Boolean(stepState),\n        displayName: opId.displayName ?? opId.id,\n        handled: false,\n        handle: () => {\n          if (step.handled) {\n            return false;\n          }\n\n          step.handled = true;\n\n          // Refetch step state because it may have been changed since we found\n          // the step. This could be due to checkpointing, where we run this\n          // live and then return to the function.\n          const result = this.state.stepState[hashedId];\n\n          if (step.fulfilled && result) {\n            result.fulfilled = true;\n\n            // For some execution scenarios such as testing, `data`, `error`,\n            // and `input` may be `Promises`. This could also be the case for\n            // future middleware applications. For this reason, we'll make sure\n            // the values are fully resolved before continuing.\n            void Promise.all([result.data, result.error, result.input]).then(\n              () => {\n                if (typeof result.data !== \"undefined\") {\n                  resolve(result.data);\n                } else {\n                  this.state.recentlyRejectedStepError = new StepError(\n                    opId.id,\n                    result.error,\n                  );\n                  reject(this.state.recentlyRejectedStepError);\n                }\n              },\n            );\n          }\n\n          return true;\n        },\n      };\n\n      this.state.steps.set(opId.id, step);\n      this.state.hasSteps = true;\n      pushStepToReport(step);\n\n      /**\n       * If this is the last piece of state we had, we've now finished\n       * memoizing.\n       */\n      if (!beforeExecHooksPromise && this.state.allStateUsed()) {\n        // biome-ignore lint/suspicious/noAssignInExpressions: <explanation>\n        await (beforeExecHooksPromise = (async () => {\n          await this.state.hooks?.afterMemoization?.();\n          await this.state.hooks?.beforeExecution?.();\n        })());\n      }\n\n      return promise;\n    };\n\n    return createStepTools(this.options.client, this, stepHandler);\n  }\n\n  private getUserFnToRun(): Handler.Any {\n    if (!this.options.isFailureHandler) {\n      return this.options.fn[\"fn\"];\n    }\n\n    if (!this.options.fn[\"onFailureFn\"]) {\n      /**\n       * Somehow, we've ended up detecting that this is a failure handler but\n       * doesn't have an `onFailure` function. This should never happen.\n       */\n      throw new Error(\"Cannot find function `onFailure` handler\");\n    }\n\n    return this.options.fn[\"onFailureFn\"];\n  }\n\n  private initializeTimer(state: V1ExecutionState): void {\n    if (!this.options.requestedRunStep) {\n      return;\n    }\n\n    this.timeout = createTimeoutPromise(this.timeoutDuration);\n\n    void this.timeout.then(async () => {\n      await this.state.hooks?.afterMemoization?.();\n      await this.state.hooks?.beforeExecution?.();\n      await this.state.hooks?.afterExecution?.();\n\n      state.setCheckpoint({\n        type: \"step-not-found\",\n        step: {\n          id: this.options.requestedRunStep as string,\n          op: StepOpCode.StepNotFound,\n        },\n      });\n    });\n  }\n\n  private async initializeMiddleware(): Promise<RunHookStack> {\n    const ctx = this.options.data as Pick<\n      Readonly<BaseContext<Inngest.Any>>,\n      \"event\" | \"events\" | \"runId\"\n    >;\n\n    const hooks = await getHookStack(\n      this.options.fn[\"middleware\"],\n      \"onFunctionRun\",\n      {\n        ctx,\n        fn: this.options.fn,\n        steps: Object.values(this.options.stepState),\n        reqArgs: this.options.reqArgs,\n      },\n      {\n        transformInput: (prev, output) => {\n          return {\n            ctx: { ...prev.ctx, ...output?.ctx },\n            fn: this.options.fn,\n            steps: prev.steps.map((step, i) => ({\n              ...step,\n              ...output?.steps?.[i],\n            })),\n            reqArgs: prev.reqArgs,\n          };\n        },\n        transformOutput: (prev, output) => {\n          return {\n            result: { ...prev.result, ...output?.result },\n            step: prev.step,\n          };\n        },\n      },\n    );\n\n    return hooks;\n  }\n}\n\n/**\n * Types of checkpoints that can be reached during execution.\n */\nexport interface Checkpoints {\n  \"steps-found\": { steps: [FoundStep, ...FoundStep[]] };\n  \"function-rejected\": { error: unknown };\n  \"function-resolved\": { data: unknown };\n  \"step-not-found\": { step: OutgoingOp };\n}\n\ntype Checkpoint = {\n  [K in keyof Checkpoints]: Simplify<{ type: K } & Checkpoints[K]>;\n}[keyof Checkpoints];\n\ntype CheckpointHandlers = {\n  [C in Checkpoint as C[\"type\"]]: (\n    checkpoint: C,\n\n    /**\n     * This is the number of checkpoints that have been seen before this one was\n     * triggered.\n     *\n     * The catch-all `\"\"` checkpoint does not increment this count.\n     */\n    i: number,\n  ) => MaybePromise<ExecutionResult | undefined>;\n} & {\n  \"\": (\n    checkpoint: Checkpoint,\n\n    /**\n     * This is the number of checkpoints that have been seen before this one was\n     * triggered.\n     *\n     * The catch-all `\"\"` checkpoint does not increment this count.\n     */\n    i: number,\n  ) => MaybePromise<void>;\n};\n\nexport interface V1ExecutionState {\n  /**\n   * A value that indicates that we're executing this step. Can be used to\n   * ensure steps are not accidentally nested until we support this across all\n   * platforms.\n   */\n  executingStep?: Readonly<Omit<OutgoingOp, \"id\">>;\n\n  /**\n   * A map of step IDs to their data, used to fill previously-completed steps\n   * with state from the executor.\n   */\n  stepState: Record<string, MemoizedOp>;\n\n  /**\n   * The number of steps we expect to fulfil based on the state passed from the\n   * Executor.\n   */\n  stepsToFulfill: number;\n\n  /**\n   * A map of step IDs to their functions to run. The executor can request a\n   * specific step to run, so we need to store the function to run here.\n   */\n  steps: Map<string, FoundStep>;\n\n  /**\n   * A flag which represents whether or not steps are understood to be used in\n   * this function. This is used to determine whether or not we should run\n   * some steps (such as `step.sendEvent`) inline as they are found.\n   */\n  hasSteps: boolean;\n\n  /**\n   * The core loop - a generator used to take an action upon finding the next\n   * checkpoint. Manages the flow of execution and cleaning up after itself.\n   */\n  loop: AsyncGenerator<Checkpoint, void, void>;\n\n  /**\n   * A function that resolves the `Promise` returned by `waitForNextDecision`.\n   */\n  setCheckpoint: (data: Checkpoint) => void;\n\n  /**\n   * Initialized middleware hooks for this execution.\n   *\n   * Middleware hooks are cached to ensure they can only be run once, which\n   * means that these hooks can be called in many different places to ensure we\n   * handle all possible execution paths.\n   */\n  hooks?: RunHookStack;\n\n  /**\n   * Returns whether or not all state passed from the executor has been used to\n   * fulfill found steps.\n   */\n  allStateUsed: () => boolean;\n\n  /**\n   * An ordered list of step IDs that represents the order in which their\n   * execution was completed.\n   */\n  stepCompletionOrder: string[];\n\n  /**\n   * An set of step IDs that have yet to be seen in this execution. Used to\n   * decide when to trigger middleware based on the current state.\n   */\n  remainingStepsToBeSeen: Set<string>;\n\n  /**\n   * If defined, this is the error that purposefully thrown when memoizing step\n   * state in order to support per-step errors.\n   *\n   * We use this so that if the function itself rejects with the same error, we\n   * know that it was entirely uncaught (or at the very least rethrown), so we\n   * should send a `NonRetriableError` to stop needless execution of a function\n   * that will continue to fail.\n   *\n   * TODO This is imperfect, as this state is currently kept around for longer\n   * than it needs to be. It should disappear as soon as we've seen that the\n   * error did not immediately throw. It may need to be refactored to work a\n   * little more smoothly with the core loop.\n   */\n  recentlyRejectedStepError?: StepError;\n\n  /**\n   * If defined, this indicates that we're running a checkpointed function run,\n   * and contains the data needed to report progress back to Inngest.\n   */\n  checkpointedRun?: {\n    fnId: string;\n    appId: string;\n    token?: string;\n  };\n}\n\nconst hashId = (id: string): string => {\n  return sha1().update(id).digest(\"hex\");\n};\n\nconst hashOp = (op: OutgoingOp): OutgoingOp => {\n  return {\n    ...op,\n    id: hashId(op.id),\n  };\n};\n\n/**\n * Exported for testing.\n */\nexport const _internals = { hashOp, hashId };\n"],"names":["createV1InngestExecution: InngestExecutionFactory","step","outgoingOp: OutgoingOp","retriable: boolean | string","loop: V1ExecutionState[\"loop\"]","foundStepsToReport: Map<string, FoundStep>","unhandledFoundStepsToReport: Map<string, FoundStep>","expectedNextStepIndexes: Map<string, number>","remainingStepCompletionOrder: string[]","foundStepsReportPromise: Promise<void> | undefined","beforeExecHooksPromise: Promise<void> | undefined","extensionPromise: Promise<void>","stepHandler: StepHandler","extraOpts: Record<string, unknown> | undefined","step: FoundStep"],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4931, "column": 0}, "map": {"version":3,"file":"InngestFunction.js","sources":["file:///Users/amansatyawani/Desktop/website-builder/node_modules/.pnpm/inngest%403.45.1_%40opentelemetry%2Bcore%402.2.0_%40opentelemetry%2Bapi%401.9.0__express%405.1.0_next%401_e029d374516642dd9a767b32fbb0beec/node_modules/src/components/InngestFunction.ts"],"sourcesContent":["import {\n  ExecutionVersion,\n  internalEvents,\n  queryKeys,\n} from \"../helpers/consts.ts\";\nimport { timeStr } from \"../helpers/strings.ts\";\nimport type { RecursiveTuple, StrictUnion } from \"../helpers/types.ts\";\nimport type {\n  Cancellation,\n  ConcurrencyOption,\n  FunctionConfig,\n  Handler,\n  TimeStr,\n  TimeStrBatch,\n  TriggersFromClient,\n} from \"../types.ts\";\nimport type {\n  IInngestExecution,\n  InngestExecutionOptions,\n} from \"./execution/InngestExecution.ts\";\nimport { createV0InngestExecution } from \"./execution/v0.ts\";\nimport { createV1InngestExecution } from \"./execution/v1.ts\";\nimport { createV2InngestExecution } from \"./execution/v2.ts\";\nimport type { GetEvents, Inngest } from \"./Inngest.ts\";\nimport type {\n  InngestMiddleware,\n  MiddlewareRegisterReturn,\n} from \"./InngestMiddleware.ts\";\n\n/**\n * A stateless Inngest function, wrapping up function configuration and any\n * in-memory steps to run when triggered.\n *\n * This function can be \"registered\" to create a handler that Inngest can\n * trigger remotely.\n *\n * @public\n */\nexport class InngestFunction<\n  TFnOpts extends InngestFunction.Options<\n    TClient,\n    TMiddleware,\n    TTriggers,\n    TFailureHandler\n  >,\n  THandler extends Handler.Any,\n  TFailureHandler extends Handler.Any,\n  TClient extends Inngest.Any = Inngest.Any,\n  TMiddleware extends InngestMiddleware.Stack = InngestMiddleware.Stack,\n  TTriggers extends InngestFunction.Trigger<\n    TriggersFromClient<TClient>\n  >[] = InngestFunction.Trigger<TriggersFromClient<TClient>>[],\n> implements InngestFunction.Like\n{\n  static stepId = \"step\";\n  static failureSuffix = \"-failure\";\n\n  get [Symbol.toStringTag](): typeof InngestFunction.Tag {\n    return InngestFunction.Tag;\n  }\n\n  public readonly opts: TFnOpts;\n  // biome-ignore lint/correctness/noUnusedPrivateClassMembers: used internally\n  private readonly fn: THandler;\n  private readonly onFailureFn?: TFailureHandler;\n  protected readonly client: TClient;\n  private readonly middleware: Promise<MiddlewareRegisterReturn[]>;\n\n  /**\n   * A stateless Inngest function, wrapping up function configuration and any\n   * in-memory steps to run when triggered.\n   *\n   * This function can be \"registered\" to create a handler that Inngest can\n   * trigger remotely.\n   */\n  constructor(\n    client: TClient,\n\n    /**\n     * Options\n     */\n    opts: TFnOpts,\n    fn: THandler,\n  ) {\n    this.client = client;\n    this.opts = opts;\n    this.fn = fn;\n    this.onFailureFn = this.opts.onFailure;\n\n    this.middleware = this.client[\"initializeMiddleware\"](\n      this.opts.middleware,\n      { registerInput: { fn: this }, prefixStack: this.client[\"middleware\"] },\n    );\n  }\n\n  /**\n   * The generated or given ID for this function.\n   */\n  public id(prefix?: string): string {\n    return [prefix, this.opts.id].filter(Boolean).join(\"-\");\n  }\n\n  /**\n   * The generated or given ID for this function, prefixed with the app ID. This\n   * is used for routing invokes and identifying the function across apps.\n   */\n  protected get absoluteId(): string {\n    return this.id(this.client.id);\n  }\n\n  /**\n   * The name of this function as it will appear in the Inngest Cloud UI.\n   */\n  public get name(): string {\n    return this.opts.name || this.id();\n  }\n\n  /**\n   * The description of this function.\n   */\n  public get description(): string | undefined {\n    return this.opts.description;\n  }\n\n  /**\n   * Retrieve the Inngest config for this function.\n   */\n\n  // biome-ignore lint/correctness/noUnusedPrivateClassMembers: used within the SDK\n  private getConfig({\n    baseUrl,\n    appPrefix,\n    isConnect,\n  }: {\n    /**\n     * Must be provided a URL that will be used to access the function and step.\n     * This function can't be expected to know how it will be accessed, so\n     * relies on an outside method providing context.\n     */\n    baseUrl: URL;\n\n    /**\n     * The prefix for the app that this function is part of.\n     */\n    appPrefix: string;\n\n    /**\n     * Whether this function is being used in a Connect handler.\n     */\n    isConnect?: boolean;\n  }): FunctionConfig[] {\n    const fnId = this.id(appPrefix);\n    const stepUrl = new URL(baseUrl.href);\n    stepUrl.searchParams.set(queryKeys.FnId, fnId);\n    stepUrl.searchParams.set(queryKeys.StepId, InngestFunction.stepId);\n\n    const {\n      retries: attempts,\n      cancelOn,\n      idempotency,\n      batchEvents,\n      rateLimit,\n      throttle,\n      concurrency,\n      debounce,\n      timeouts,\n      priority,\n      singleton,\n    } = this.opts;\n\n    /**\n     * Convert retries into the format required when defining function\n     * configuration.\n     */\n    const retries = typeof attempts === \"undefined\" ? undefined : { attempts };\n\n    const fn: FunctionConfig = {\n      id: fnId,\n      name: this.name,\n      triggers: (this.opts.triggers ?? []).map((trigger) => {\n        if (\"event\" in trigger) {\n          return {\n            event: trigger.event as string,\n            expression: trigger.if,\n          };\n        }\n\n        return {\n          cron: trigger.cron,\n        };\n      }),\n      steps: {\n        [InngestFunction.stepId]: {\n          id: InngestFunction.stepId,\n          name: InngestFunction.stepId,\n          runtime: {\n            type: isConnect ? \"ws\" : \"http\",\n            url: stepUrl.href,\n          },\n          retries,\n        },\n      },\n      idempotency,\n      batchEvents,\n      rateLimit,\n      throttle,\n      concurrency,\n      debounce,\n      priority,\n      timeouts,\n      singleton,\n    };\n\n    if (cancelOn) {\n      fn.cancel = cancelOn.map(({ event, timeout, if: ifStr, match }) => {\n        const ret: NonNullable<FunctionConfig[\"cancel\"]>[number] = {\n          event,\n        };\n\n        if (timeout) {\n          ret.timeout = timeStr(timeout);\n        }\n\n        if (match) {\n          ret.if = `event.${match} == async.${match}`;\n        } else if (ifStr) {\n          ret.if = ifStr;\n        }\n\n        return ret;\n      }, []);\n    }\n\n    const config: FunctionConfig[] = [fn];\n\n    if (this.onFailureFn) {\n      const id = `${fn.id}${InngestFunction.failureSuffix}`;\n      const name = `${fn.name ?? fn.id} (failure)`;\n\n      const failureStepUrl = new URL(stepUrl.href);\n      failureStepUrl.searchParams.set(queryKeys.FnId, id);\n\n      config.push({\n        id,\n        name,\n        triggers: [\n          {\n            event: internalEvents.FunctionFailed,\n            expression: `event.data.function_id == '${fnId}'`,\n          },\n        ],\n        steps: {\n          [InngestFunction.stepId]: {\n            id: InngestFunction.stepId,\n            name: InngestFunction.stepId,\n            runtime: {\n              type: \"http\",\n              url: failureStepUrl.href,\n            },\n            retries: { attempts: 1 },\n          },\n        },\n      });\n    }\n\n    return config;\n  }\n\n  protected createExecution(opts: CreateExecutionOptions): IInngestExecution {\n    const options: InngestExecutionOptions = {\n      fn: this,\n      ...opts.partialOptions,\n    };\n\n    const versionHandlers = {\n      [ExecutionVersion.V2]: () => createV2InngestExecution(options),\n      [ExecutionVersion.V1]: () => createV1InngestExecution(options),\n      [ExecutionVersion.V0]: () => createV0InngestExecution(options),\n    } satisfies Record<ExecutionVersion, () => IInngestExecution>;\n\n    return versionHandlers[opts.version]();\n  }\n\n  // biome-ignore lint/correctness/noUnusedPrivateClassMembers: used within the SDK\n  private shouldOptimizeParallelism(): boolean {\n    // TODO We should check the commhandler's client instead of this one?\n    return (\n      this.opts.optimizeParallelism ??\n      this.client[\"options\"].optimizeParallelism ??\n      false\n    );\n  }\n}\n\n/**\n * A stateless Inngest function, wrapping up function configuration and any\n * in-memory steps to run when triggered.\n *\n * This function can be \"registered\" to create a handler that Inngest can\n * trigger remotely.\n *\n * @public\n */\nexport namespace InngestFunction {\n  export const Tag = \"Inngest.Function\" as const;\n\n  /**\n   * Represents any `InngestFunction` instance, regardless of generics and\n   * inference.\n   */\n  export type Any = InngestFunction<\n    // biome-ignore lint/suspicious/noExplicitAny: <explanation>\n    any,\n    Handler.Any,\n    Handler.Any,\n    // biome-ignore lint/suspicious/noExplicitAny: <explanation>\n    any,\n    // biome-ignore lint/suspicious/noExplicitAny: <explanation>\n    any,\n    // biome-ignore lint/suspicious/noExplicitAny: <explanation>\n    any\n  >;\n\n  export interface Like {\n    readonly [Symbol.toStringTag]: typeof InngestFunction.Tag;\n  }\n\n  /**\n   * A user-friendly method of specifying a trigger for an Inngest function.\n   *\n   * @public\n   */\n  export type Trigger<T extends string> = StrictUnion<\n    | {\n        event: T;\n        if?: string;\n      }\n    | {\n        cron: string;\n      }\n  >;\n\n  export type GetOptions<T extends InngestFunction.Any> =\n    // biome-ignore lint/suspicious/noExplicitAny: <explanation>\n    T extends InngestFunction<infer O, any, any, any, any, any> ? O : never;\n\n  /**\n   * A set of options for configuring an Inngest function.\n   *\n   * @public\n   */\n  export interface Options<\n    TClient extends Inngest.Any = Inngest.Any,\n    TMiddleware extends InngestMiddleware.Stack = InngestMiddleware.Stack,\n    TTriggers extends InngestFunction.Trigger<\n      TriggersFromClient<TClient>\n    >[] = InngestFunction.Trigger<TriggersFromClient<TClient>>[],\n    TFailureHandler extends Handler.Any = Handler.Any,\n  > {\n    triggers?: TTriggers;\n\n    /**\n     * An unique ID used to identify the function. This is used internally for\n     * versioning and referring to your function, so should not change between\n     * deployments.\n     *\n     * If you'd like to set a prettier name for your function, use the `name`\n     * option.\n     */\n    id: string;\n\n    /**\n     * A name for the function as it will appear in the Inngest Cloud UI.\n     */\n    name?: string;\n\n    /**\n     * A description of the function.\n     */\n    description?: string;\n\n    /**\n     * Concurrency specifies a limit on the total number of concurrent steps that\n     * can occur across all runs of the function.  A value of 0 (or undefined) means\n     * use the maximum available concurrency.\n     *\n     * Specifying just a number means specifying only the concurrency limit. A\n     * maximum of two concurrency options can be specified.\n     */\n    concurrency?:\n      | number\n      | ConcurrencyOption\n      | RecursiveTuple<ConcurrencyOption, 2>;\n\n    /**\n     * batchEvents specifies the batch configuration on when this function\n     * should be invoked when one of the requirements are fulfilled.\n     */\n    batchEvents?: {\n      /**\n       * The maximum number of events to be consumed in one batch.\n       * Check the pricing page to verify the limit for each plan.\n       */\n      maxSize: number;\n\n      /**\n       * How long to wait before invoking the function with a list of events.\n       * If timeout is reached, the function will be invoked with a batch\n       * even if it's not filled up to `maxSize`.\n       *\n       * Expects a time string such as 1s, 60s or 15m15s.\n       */\n      timeout: TimeStrBatch;\n\n      /**\n       * An optional key to use for batching.\n       *\n       * See [batch documentation](https://innge.st/batching) for more\n       * information on how to use `key` expressions.\n       */\n      key?: string;\n\n      /**\n       * An optional boolean expression to determine an event's eligibility for batching\n       *\n       * See [batch documentation](https://innge.st/batching) for more\n       * information on how to use `if` expressions.\n       */\n      if?: string;\n    };\n\n    /**\n     * Allow the specification of an idempotency key using event data. If\n     * specified, this overrides the `rateLimit` object.\n     */\n    idempotency?: string;\n\n    /**\n     * Rate limit function runs, only running them a given number of times (limit) per\n     * period.  Note that rate limit is a lossy, hard limit.  Once the limit is hit,\n     * new runs will be skipped.  To enqueue work when a rate limit is hit, use the\n     * {@link throttle} parameter.\n     */\n    rateLimit?: {\n      /**\n       * An optional key to use for rate limiting, similar to idempotency.\n       */\n      key?: string;\n\n      /**\n       * The number of times to allow the function to run per the given `period`.\n       */\n      limit: number;\n\n      /**\n       * The period of time to allow the function to run `limit` times.\n       */\n      period: TimeStr;\n    };\n\n    /**\n     * Throttles function runs, only running them a given number of times (limit) per\n     * period.  Once the limit is hit, new runs will be enqueued and will start when there's\n     * capacity.  This may lead to a large backlog.  For hard rate limiting, use the\n     * {@link rateLimit} parameter.\n     */\n    throttle?: {\n      /**\n       *  An optional expression which returns a throttling key for controlling throttling.\n       *  Every unique key is its own throttle limit.  Event data may be used within this\n       *  expression, eg \"event.data.user_id\".\n       */\n      key?: string;\n\n      /**\n       * The total number of runs allowed to start within the given `period`.  The limit is\n       * applied evenly over the period.\n       */\n      limit: number;\n\n      /**\n       * The period of time for the rate limit.  Run starts are evenly spaced through\n       * the given period.  The minimum granularity is 1 second.\n       */\n      period: TimeStr;\n\n      /**\n       * The number of runs allowed to start in the given window in a single burst.\n       * A burst > 1 bypasses smoothing for the burst and allows many runs to start\n       * at once, if desired.  Defaults to 1, which disables bursting.\n       */\n      burst?: number;\n    };\n\n    /**\n     * Debounce delays functions for the `period` specified. If an event is sent,\n     * the function will not run until at least `period` has elapsed.\n     *\n     * If any new events are received that match the same debounce `key`, the\n     * function is rescheduled for another `period` delay, and the triggering\n     * event is replaced with the latest event received.\n     *\n     * See the [Debounce documentation](https://innge.st/debounce) for more\n     * information.\n     */\n    debounce?: {\n      /**\n       * An optional key to use for debouncing.\n       *\n       * See [Debounce documentation](https://innge.st/debounce) for more\n       * information on how to use `key` expressions.\n       */\n      key?: string;\n\n      /**\n       * The period of time to delay after receiving the last trigger to run the\n       * function.\n       *\n       * See [Debounce documentation](https://innge.st/debounce) for more\n       * information.\n       */\n      period: TimeStr;\n\n      /**\n       * The maximum time that a debounce can be extended before running.\n       * If events are continually received within the given period, a function\n       * will always run after the given timeout period.\n       *\n       * See [Debounce documentation](https://innge.st/debounce) for more\n       * information.\n       */\n      timeout?: TimeStr;\n    };\n\n    /**\n     * Configure how the priority of a function run is decided when multiple\n     * functions are triggered at the same time.\n     *\n     * See the [Priority documentation](https://innge.st/priority) for more\n     * information.\n     */\n    priority?: {\n      /**\n       * An expression to use to determine the priority of a function run. The\n       * expression can return a number between `-600` and `600`, where `600`\n       * declares that this run should be executed before any others enqueued in\n       * the last 600 seconds (10 minutes), and `-600` declares that this run\n       * should be executed after any others enqueued in the last 600 seconds.\n       *\n       * See the [Priority documentation](https://innge.st/priority) for more\n       * information.\n       */\n      run?: string;\n    };\n\n    /**\n     * Configure timeouts for the function.  If any of the timeouts are hit, the\n     * function run will be cancelled.\n     */\n    timeouts?: {\n      /**\n       * Start represents the timeout for starting a function.  If the time\n       * between scheduling and starting a function exceeds this value, the\n       * function will be cancelled.\n       *\n       * This is, essentially, the amount of time that a function sits in the\n       * queue before starting.\n       *\n       * A function may exceed this duration because of concurrency limits,\n       * throttling, etc.\n       */\n      start?: TimeStr;\n\n      /**\n       * Finish represents the time between a function starting and the function\n       * finishing. If a function takes longer than this time to finish, the\n       * function is marked as cancelled.\n       *\n       * The start time is taken from the time that the first successful\n       * function request begins, and does not include the time spent in the\n       * queue before the function starts.\n       *\n       * Note that if the final request to a function begins before this\n       * timeout, and completes after this timeout, the function will succeed.\n       */\n      finish?: TimeStr;\n    };\n\n    /**\n     * Ensures that only one run of the function is active at a time for a given key.\n     * If a new run is triggered while another is still in progress with the same key,\n     * the new run will either be skipped or replace the active one, depending on the mode.\n     *\n     * This is useful for deduplication or enforcing exclusive execution.\n     */\n    singleton?: {\n      /**\n       * An optional key expression used to scope singleton execution.\n       * Each unique key has its own singleton lock. Event data can be referenced,\n       * e.g. \"event.data.user_id\".\n       */\n      key?: string;\n\n      /**\n       * Determines how to handle new runs when one is already active for the same key.\n       * - `\"skip\"` skips the new run.\n       * - `\"cancel\"` cancels the existing run and starts the new one.\n       */\n      mode: \"skip\" | \"cancel\";\n    };\n\n    cancelOn?: Cancellation<GetEvents<TClient, true>>[];\n\n    /**\n     * Specifies the maximum number of retries for all steps across this function.\n     *\n     * Can be a number from `0` to `20`. Defaults to `3`.\n     */\n    retries?:\n      | 0\n      | 1\n      | 2\n      | 3\n      | 4\n      | 5\n      | 6\n      | 7\n      | 8\n      | 9\n      | 10\n      | 11\n      | 12\n      | 13\n      | 14\n      | 15\n      | 16\n      | 17\n      | 18\n      | 19\n      | 20;\n\n    /**\n     * Provide a function to be called if your function fails, meaning\n     * that it ran out of retries and was unable to complete successfully.\n     *\n     * This is useful for sending warning notifications or cleaning up\n     * after a failure and supports all the same functionality as a\n     * regular handler.\n     */\n    onFailure?: TFailureHandler;\n\n    /**\n     * Define a set of middleware that can be registered to hook into\n     * various lifecycles of the SDK and affect input and output of\n     * Inngest functionality.\n     *\n     * See {@link https://innge.st/middleware}\n     *\n     * @example\n     *\n     * ```ts\n     * export const inngest = new Inngest({\n     *   middleware: [\n     *     new InngestMiddleware({\n     *       name: \"My Middleware\",\n     *       init: () => {\n     *         // ...\n     *       }\n     *     })\n     *   ]\n     * });\n     * ```\n     */\n    middleware?: TMiddleware;\n\n    /**\n     * If `true`, parallel steps within this function are optimized to reduce\n     * traffic during `Promise` resolution, which can hugely reduce the time\n     * taken and number of requests for each run.\n     *\n     * Note that this will be the default behaviour in v4 and in its current\n     * form will cause `Promise.*()` to wait for all promises to settle before\n     * resolving.\n     *\n     * Providing this value here will overwrite the same value given on the\n     * client.\n     *\n     * @default false\n     */\n    optimizeParallelism?: boolean;\n  }\n}\n\nexport type CreateExecutionOptions = {\n  version: ExecutionVersion;\n  partialOptions: Omit<InngestExecutionOptions, \"fn\">;\n};\n"],"names":["fn: FunctionConfig","ret: NonNullable<FunctionConfig[\"cancel\"]>[number]","config: FunctionConfig[]","options: InngestExecutionOptions"],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 5122, "column": 0}, "map": {"version":3,"file":"net.js","sources":["file:///Users/amansatyawani/Desktop/website-builder/node_modules/.pnpm/inngest%403.45.1_%40opentelemetry%2Bcore%402.2.0_%40opentelemetry%2Bapi%401.9.0__express%405.1.0_next%401_e029d374516642dd9a767b32fbb0beec/node_modules/src/helpers/net.ts"],"sourcesContent":["import canonicalize from \"canonicalize\";\nimport hashjs from \"hash.js\";\n\nconst { hmac, sha256 } = hashjs;\n\n/**\n * Send an HTTP request with the given signing key. If the response is a 401 or\n * 403, then try again with the fallback signing key\n */\nexport async function fetchWithAuthFallback<TFetch extends typeof fetch>({\n  authToken,\n  authTokenFallback,\n  fetch,\n  options,\n  url,\n}: {\n  authToken?: string;\n  authTokenFallback?: string;\n  fetch: TFetch;\n  options?: Parameters<TFetch>[1];\n  url: URL | string;\n}): Promise<Response> {\n  let res = await fetch(url, {\n    ...options,\n    headers: {\n      ...options?.headers,\n      Authorization: `Bearer ${authToken}`,\n    },\n  });\n\n  if ([401, 403].includes(res.status) && authTokenFallback) {\n    res = await fetch(url, {\n      ...options,\n      headers: {\n        ...options?.headers,\n        Authorization: `Bearer ${authTokenFallback}`,\n      },\n    });\n  }\n\n  return res;\n}\n\nexport function signDataWithKey(\n  data: unknown,\n  signingKey: string,\n  ts: string,\n): string {\n  // Calculate the HMAC of the request body ourselves.\n  // We make the assumption here that a stringified body is the same as the\n  // raw bytes; it may be pertinent in the future to always parse, then\n  // canonicalize the body to ensure it's consistent.\n  const encoded = typeof data === \"string\" ? data : canonicalize(data);\n  // Remove the `/signkey-[test|prod]-/` prefix from our signing key to calculate the HMAC.\n  const key = signingKey.replace(/signkey-\\w+-/, \"\");\n  // biome-ignore lint/suspicious/noExplicitAny: <explanation>\n  const mac = hmac(sha256 as any, key)\n    .update(encoded)\n    .update(ts)\n    .digest(\"hex\");\n\n  return mac;\n}\n"],"names":[],"mappings":";;;;;;;;;AAGA,MAAM,EAAE,IAAA,EAAM,MAAA,EAAA,sMAAW,UAAA;;;;GAMzB,eAAsB,sBAAmD,EACvE,SAAA,EACA,iBAAA,EACA,KAAA,EACA,OAAA,EACA,GAAA,EAAA,EAOoB;IACpB,IAAI,MAAM,MAAM,MAAM,KAAK;QACzB,GAAG,OAAA;QACH,SAAS;YACP,GAAG,SAAS,OAAA;YACZ,eAAe,CAAA,OAAA,EAAU,WAAA;SAC1B;KACF,CAAC;IAEF,IAAI;QAAC;QAAK;KAAI,CAAC,QAAA,CAAS,IAAI,MAAA,CAAO,IAAI,kBACrC,CAAA,MAAM,MAAM,MAAM,KAAK;QACrB,GAAG,OAAA;QACH,SAAS;YACP,GAAG,SAAS,OAAA;YACZ,eAAe,CAAA,OAAA,EAAU,mBAAA;SAC1B;KACF,CAAC;IAGJ,OAAO;;AAGT,SAAgB,gBACd,IAAA,EACA,UAAA,EACA,EAAA,EACQ;IAKR,MAAM,UAAU,OAAO,SAAS,WAAW,0NAAO,UAAA,EAAa,KAAK;IASpE,OALY,KAAK,QAFL,WAAW,OAAA,CAAQ,gBAAgB,GAAG,CAEd,CACjC,MAAA,CAAO,QAAQ,CACf,MAAA,CAAO,GAAG,CACV,MAAA,CAAO,MAAM","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 5167, "column": 0}, "map": {"version":3,"file":"api.js","sources":["file:///Users/amansatyawani/Desktop/website-builder/node_modules/.pnpm/inngest%403.45.1_%40opentelemetry%2Bcore%402.2.0_%40opentelemetry%2Bapi%401.9.0__express%405.1.0_next%401_e029d374516642dd9a767b32fbb0beec/node_modules/src/api/api.ts"],"sourcesContent":["import type { fetch } from \"cross-fetch\";\nimport { z } from \"zod/v3\";\nimport type { ActionResponse } from \"../components/InngestCommHandler.ts\";\nimport {\n  defaultDevServerHost,\n  defaultInngestApiBaseUrl,\n  type ExecutionVersion,\n} from \"../helpers/consts.ts\";\nimport { devServerAvailable } from \"../helpers/devserver.ts\";\nimport type { Mode } from \"../helpers/env.ts\";\nimport { getErrorMessage } from \"../helpers/errors.ts\";\nimport { fetchWithAuthFallback } from \"../helpers/net.ts\";\nimport { hashSigningKey } from \"../helpers/strings.ts\";\nimport {\n  type APIStepPayload,\n  err,\n  type OutgoingOp,\n  ok,\n  type Result,\n} from \"../types.ts\";\nimport {\n  type BatchResponse,\n  batchSchema,\n  type ErrorResponse,\n  errorSchema,\n  type StepsResponse,\n  stepsSchemas,\n} from \"./schema.ts\";\n\ntype FetchT = typeof fetch;\n\nconst realtimeSubscriptionTokenSchema = z.object({\n  jwt: z.string(),\n});\n\nconst sendSignalSuccessResponseSchema = z.object({\n  data: z.object({\n    run_id: z.string().min(1),\n  }),\n});\n\nconst checkpointNewRunResponseSchema = z.object({\n  data: z.object({\n    fn_id: z.string().min(1),\n    app_id: z.string().min(1),\n    run_id: z.string().min(1),\n    token: z.string().min(1).optional(),\n  }),\n});\n\nexport namespace InngestApi {\n  export interface Options {\n    baseUrl?: string;\n    signingKey: string;\n    signingKeyFallback: string | undefined;\n    fetch: FetchT;\n    mode: Mode;\n  }\n\n  export interface Subscription {\n    topics: string[];\n    channel: string;\n  }\n\n  export interface PublishOptions extends Subscription {\n    runId?: string;\n  }\n\n  export interface SendSignalOptions {\n    signal: string;\n    data?: unknown;\n  }\n\n  export interface SendSignalResponse {\n    /**\n     * The ID of the run that was signaled.\n     *\n     * If this is undefined, the signal could not be matched to a run.\n     */\n    runId: string | undefined;\n  }\n}\n\nexport class InngestApi {\n  public apiBaseUrl?: string;\n  private signingKey: string;\n  private signingKeyFallback: string | undefined;\n  private readonly fetch: FetchT;\n  private mode: Mode;\n\n  constructor({\n    baseUrl,\n    signingKey,\n    signingKeyFallback,\n    fetch,\n    mode,\n  }: InngestApi.Options) {\n    this.apiBaseUrl = baseUrl;\n    this.signingKey = signingKey;\n    this.signingKeyFallback = signingKeyFallback;\n    this.fetch = fetch;\n    this.mode = mode;\n  }\n\n  private get hashedKey(): string {\n    return hashSigningKey(this.signingKey);\n  }\n\n  private get hashedFallbackKey(): string | undefined {\n    if (!this.signingKeyFallback) {\n      return;\n    }\n\n    return hashSigningKey(this.signingKeyFallback);\n  }\n\n  // set the signing key in case it was not instantiated previously\n  setSigningKey(key: string | undefined) {\n    if (typeof key === \"string\" && this.signingKey === \"\") {\n      this.signingKey = key;\n    }\n  }\n\n  setSigningKeyFallback(key: string | undefined) {\n    if (typeof key === \"string\" && !this.signingKeyFallback) {\n      this.signingKeyFallback = key;\n    }\n  }\n\n  private async getTargetUrl(path: string): Promise<URL> {\n    if (this.apiBaseUrl) {\n      return new URL(path, this.apiBaseUrl);\n    }\n\n    let url = new URL(path, defaultInngestApiBaseUrl);\n\n    if (this.mode.isDev && this.mode.isInferred && !this.apiBaseUrl) {\n      const devAvailable = await devServerAvailable(\n        defaultDevServerHost,\n        this.fetch,\n      );\n\n      if (devAvailable) {\n        url = new URL(path, defaultDevServerHost);\n      }\n    }\n\n    return url;\n  }\n\n  private async req(\n    url: string | URL,\n    options?: RequestInit,\n  ): Promise<Result<Response, unknown>> {\n    const finalUrl: URL =\n      typeof url === \"string\" ? await this.getTargetUrl(url) : url;\n\n    try {\n      const res = await fetchWithAuthFallback({\n        authToken: this.hashedKey,\n        authTokenFallback: this.hashedFallbackKey,\n        fetch: this.fetch,\n        url: finalUrl,\n        options: {\n          ...options,\n          headers: {\n            \"Content-Type\": \"application/json\",\n            ...options?.headers,\n          },\n        },\n      });\n\n      return ok(res);\n    } catch (error) {\n      return err(error);\n    }\n  }\n\n  async getRunSteps(\n    runId: string,\n    version: ExecutionVersion,\n  ): Promise<Result<StepsResponse, ErrorResponse>> {\n    const result = await this.req(`/v0/runs/${runId}/actions`);\n    if (result.ok) {\n      const res = result.value;\n      const data: unknown = await res.json();\n\n      if (res.ok) {\n        return ok(stepsSchemas[version].parse(data));\n      }\n\n      return err(errorSchema.parse(data));\n    }\n\n    return err({\n      error: getErrorMessage(\n        result.error,\n        \"Unknown error retrieving step data\",\n      ),\n      status: 500,\n    });\n  }\n\n  async getRunBatch(\n    runId: string,\n  ): Promise<Result<BatchResponse, ErrorResponse>> {\n    const result = await this.req(`/v0/runs/${runId}/batch`);\n    if (result.ok) {\n      const res = result.value;\n      const data: unknown = await res.json();\n\n      if (res.ok) {\n        return ok(batchSchema.parse(data));\n      }\n\n      return err(errorSchema.parse(data));\n    }\n\n    return err({\n      error: getErrorMessage(\n        result.error,\n        \"Unknown error retrieving event batch\",\n      ),\n      status: 500,\n    });\n  }\n\n  async publish(\n    publishOptions: InngestApi.PublishOptions,\n    // biome-ignore lint/suspicious/noExplicitAny: anything is acceptable\n    data: any,\n  ): Promise<Result<void, ErrorResponse>> {\n    // todo it may not be a \"text/stream\"\n    const isStream = data instanceof ReadableStream;\n\n    const url = await this.getTargetUrl(\"/v1/realtime/publish\");\n    url.searchParams.set(\"channel\", publishOptions.channel || \"\");\n    if (publishOptions.runId) {\n      url.searchParams.set(\"run_id\", publishOptions.runId);\n    }\n    for (const topic of publishOptions.topics) {\n      url.searchParams.append(\"topic\", topic);\n    }\n\n    const result = await this.req(url, {\n      body: isStream\n        ? data\n        : typeof data === \"string\"\n          ? data\n          : JSON.stringify(data),\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": isStream ? \"text/stream\" : \"application/json\",\n      },\n      ...(isStream ? { duplex: \"half\" } : {}),\n    });\n    if (result.ok) {\n      const res = result.value;\n      if (!res.ok) {\n        throw new Error(\n          `Failed to publish event: ${res.status} ${res.statusText}`,\n        );\n      }\n\n      return ok<void>(undefined);\n    }\n\n    return err({\n      error: getErrorMessage(result.error, \"Unknown error publishing event\"),\n      status: 500,\n    });\n  }\n\n  async sendSignal(\n    signalOptions: InngestApi.SendSignalOptions,\n    options?: {\n      headers?: Record<string, string>;\n    },\n  ): Promise<Result<InngestApi.SendSignalResponse, ErrorResponse>> {\n    const url = await this.getTargetUrl(\"/v1/signals\");\n\n    const body = {\n      signal: signalOptions.signal,\n      data: signalOptions.data,\n    };\n\n    return fetchWithAuthFallback({\n      authToken: this.hashedKey,\n      authTokenFallback: this.hashedFallbackKey,\n      fetch: this.fetch,\n      url,\n      options: {\n        method: \"POST\",\n        body: JSON.stringify(body),\n        headers: {\n          \"Content-Type\": \"application/json\",\n          ...options?.headers,\n        },\n      },\n    })\n      .then(async (res) => {\n        // A 404 is valid if the signal was not found.\n        if (res.status === 404) {\n          return ok<InngestApi.SendSignalResponse>({\n            runId: undefined,\n          });\n        }\n\n        // Save a clone of the response we can use to get the text of if we fail\n        // to parse the JSON.\n        const resClone = res.clone();\n\n        // JSON!\n        let json: unknown;\n        try {\n          json = await res.json();\n        } catch {\n          // res.json() failed so not a valid JSON response\n          return err({\n            error: `Failed to send signal: ${res.status} ${\n              res.statusText\n            } - ${await resClone.text()}`,\n            status: res.status,\n          });\n        }\n\n        // If we're not 2xx, something went wrong.\n        if (!res.ok) {\n          try {\n            return err(errorSchema.parse(json));\n          } catch {\n            // schema parse failed\n            return err({\n              error: `Failed to send signal: ${res.status} ${\n                res.statusText\n              } - ${await res.text()}`,\n              status: res.status,\n            });\n          }\n        }\n\n        // If we are 2xx, we should have a run_id.\n        const parseRes = sendSignalSuccessResponseSchema.safeParse(json);\n        if (!parseRes.success) {\n          return err({\n            error: `Successfully sent signal, but response parsing failed: ${\n              res.status\n            } ${res.statusText} - ${await resClone.text()}`,\n            status: res.status,\n          });\n        }\n\n        return ok({\n          runId: parseRes.data.data.run_id,\n        });\n      })\n      .catch((error) => {\n        // Catch-all if various things go wrong\n        return err({\n          error: getErrorMessage(error, \"Unknown error sending signal\"),\n          status: 500,\n        });\n      });\n  }\n\n  async getSubscriptionToken(\n    channel: string,\n    topics: string[],\n  ): Promise<string> {\n    const url = await this.getTargetUrl(\"/v1/realtime/token\");\n\n    const body = topics.map((topic) => ({\n      channel,\n      name: topic,\n      kind: \"run\",\n    }));\n\n    return fetchWithAuthFallback({\n      authToken: this.hashedKey,\n      authTokenFallback: this.hashedFallbackKey,\n      fetch: this.fetch,\n      url,\n      options: {\n        method: \"POST\",\n        body: JSON.stringify(body),\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n      },\n    })\n      .then(async (res) => {\n        if (!res.ok) {\n          throw new Error(\n            `Failed to get subscription token: ${res.status} ${\n              res.statusText\n            } - ${await res.text()}`,\n          );\n        }\n\n        const data = realtimeSubscriptionTokenSchema.parse(await res.json());\n\n        return data.jwt;\n      })\n      .catch((error) => {\n        throw new Error(\n          getErrorMessage(error, \"Unknown error getting subscription token\"),\n        );\n      });\n  }\n\n  /**\n   * Start a new run, optionally passing in a number of steps to initialize the\n   * run with.\n   */\n  async checkpointNewRun(args: {\n    runId: string;\n    event: APIStepPayload;\n    steps?: OutgoingOp[];\n  }): Promise<z.output<typeof checkpointNewRunResponseSchema>> {\n    const body = JSON.stringify({\n      run_id: args.runId,\n      event: args.event,\n      steps: args.steps,\n    });\n\n    const result = await this.req(\"/v1/checkpoint\", {\n      method: \"POST\",\n      body,\n    });\n\n    if (!result.ok) {\n      throw new Error(\n        getErrorMessage(result.error, \"Unknown error checkpointing new run\"),\n      );\n    }\n\n    const res = result.value;\n    if (res.ok) {\n      const rawData: unknown = await res.json();\n      const data = checkpointNewRunResponseSchema.parse(rawData);\n\n      return data;\n    }\n\n    throw new Error(\n      `Failed to checkpoint new run: ${res.status} ${res.statusText} - ${await res.text()}`,\n    );\n  }\n\n  /**\n   * Checkpoint steps for a given run.\n   */\n  async checkpointSteps(args: {\n    runId: string;\n    fnId: string;\n    appId: string;\n    steps: OutgoingOp[];\n  }): Promise<void> {\n    const body = JSON.stringify({\n      fn_id: args.fnId,\n      app_id: args.appId,\n      run_id: args.runId,\n      steps: args.steps,\n    });\n\n    const result = await this.req(`/v1/checkpoint/${args.runId}/steps`, {\n      method: \"POST\",\n      body,\n    });\n\n    if (!result.ok) {\n      throw new Error(\n        getErrorMessage(result.error, \"Unknown error checkpointing steps\"),\n      );\n    }\n\n    const res = result.value;\n    if (!res.ok) {\n      throw new Error(\n        `Failed to checkpoint steps: ${res.status} ${res.statusText} - ${await res.text()}`,\n      );\n    }\n  }\n}\n"],"names":["finalUrl: URL","data: unknown","json: unknown","rawData: unknown"],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 5438, "column": 0}, "map": {"version":3,"file":"crypto.js","sources":["file:///Users/amansatyawani/Desktop/website-builder/node_modules/.pnpm/inngest%403.45.1_%40opentelemetry%2Bcore%402.2.0_%40opentelemetry%2Bapi%401.9.0__express%405.1.0_next%401_e029d374516642dd9a767b32fbb0beec/node_modules/src/helpers/crypto.ts"],"sourcesContent":["/**\n * Create a cryptographically secure random value.\n *\n * @throws {Error} If the crypto module is not available.\n */\nexport function createEntropy(byteLength: number): Uint8Array {\n  const bytes = new Uint8Array(byteLength);\n\n  // https://developer.mozilla.org/en-US/docs/Web/API/Crypto#browser_compatibility\n  const { crypto } = globalThis;\n  if (!crypto) {\n    // This should only happen in Node <19.\n    throw new Error(\"missing crypto module\");\n  }\n  if (!crypto.getRandomValues) {\n    throw new Error(\"missing crypto.getRandomValues\");\n  }\n\n  crypto.getRandomValues(bytes);\n  return bytes;\n}\n"],"names":[],"mappings":";;;;;;;;AAKA,SAAgB,cAAc,UAAA,EAAgC;IAC5D,MAAM,QAAQ,IAAI,WAAW,WAAW;IAGxC,MAAM,EAAE,MAAA,EAAA,GAAW;IACnB,IAAI,CAAC,OAEH,CAAA,MAAM,IAAI,MAAM,wBAAwB;IAE1C,IAAI,CAAC,OAAO,eAAA,CACV,CAAA,MAAM,IAAI,MAAM,iCAAiC;IAGnD,OAAO,eAAA,CAAgB,MAAM;IAC7B,OAAO","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 5462, "column": 0}, "map": {"version":3,"file":"logger.js","sources":["file:///Users/amansatyawani/Desktop/website-builder/node_modules/.pnpm/inngest%403.45.1_%40opentelemetry%2Bcore%402.2.0_%40opentelemetry%2Bapi%401.9.0__express%405.1.0_next%401_e029d374516642dd9a767b32fbb0beec/node_modules/src/middleware/logger.ts"],"sourcesContent":["import { resolveNextTick } from \"../helpers/promises.ts\";\n\n/**\n * All kinds of arguments can come through\n *\n * Examples seen are\n * - string\n * - object / hash\n * - values used for string interpolation, basically anything\n *\n * See https://linear.app/inngest/issue/INN-1342/flush-logs-on-function-exitreturns for more details\n *\n * @public\n */\nexport type LogArg = unknown;\n\n/**\n * Based on https://datatracker.ietf.org/doc/html/rfc5424#autoid-11\n * it's pretty reasonable to expect a logger to have the following interfaces\n * available.\n */\nexport interface Logger {\n  info(...args: LogArg[]): void;\n  warn(...args: LogArg[]): void;\n  error(...args: LogArg[]): void;\n  debug(...args: LogArg[]): void;\n}\n\nexport class DefaultLogger implements Logger {\n  info(...args: LogArg[]) {\n    console.info(...args);\n  }\n\n  warn(...args: LogArg[]) {\n    console.warn(...args);\n  }\n\n  error(...args: LogArg[]) {\n    console.error(...args);\n  }\n\n  debug(...args: LogArg[]) {\n    console.debug(...args);\n  }\n}\n\n/**\n * ProxyLogger aims to provide a thin wrapper on user's provided logger.\n * It's expected to be turned on and off based on the function execution\n * context, so it doesn't result in duplicated logging.\n *\n * And also attempt to allow enough time for the logger to flush all logs.\n *\n * @public\n */\nexport class ProxyLogger implements Logger {\n  private readonly logger: Logger;\n  private enabled = false;\n\n  constructor(logger: Logger) {\n    this.logger = logger;\n\n    // Return a Proxy to forward arbitrary property access to the underlying\n    // logger. For example, if the user provides a logger that has a `foo`\n    // method, they can call `foo` on the ProxyLogger and it will call the\n    // underlying logger's `foo` method.\n    return new Proxy(this, {\n      get(target, prop, receiver): unknown {\n        // Handle ProxyLogger's own methods/properties.\n        if (prop in target) {\n          return Reflect.get(target, prop, receiver);\n        }\n\n        // Forward property access to the underlying logger.\n        return Reflect.get(target.logger, prop, receiver);\n      },\n    }) as ProxyLogger;\n  }\n\n  info(...args: LogArg[]) {\n    if (!this.enabled) return;\n    this.logger.info(...args);\n  }\n\n  warn(...args: LogArg[]) {\n    if (!this.enabled) return;\n    this.logger.warn(...args);\n  }\n\n  error(...args: LogArg[]) {\n    if (!this.enabled) return;\n    this.logger.error(...args);\n  }\n\n  debug(...args: LogArg[]) {\n    // there are loggers that don't implement \"debug\" by default\n    if (!this.enabled || !(typeof this.logger.debug === \"function\")) return;\n    this.logger.debug(...args);\n  }\n\n  enable() {\n    this.enabled = true;\n  }\n\n  disable() {\n    this.enabled = false;\n  }\n\n  async flush() {\n    // If DefaultLogger, nothing to wait for\n    if (this.logger.constructor.name == DefaultLogger.name) {\n      return;\n    }\n\n    const logger = this.logger as Logger & {\n      flush?: () => Promise<void> | void;\n    };\n\n    // If the logger has its own flush, defer to it\n    if (typeof logger.flush === \"function\") {\n      await logger.flush();\n      return;\n    }\n\n    // Otherwise yield one event-loop tick (non-blocking hint for buffered loggers)\n    await resolveNextTick();\n  }\n}\n"],"names":[],"mappings":";;;;;;;AA4BA,IAAa,gBAAb,MAA6C;IAC3C,KAAK,GAAG,IAAA,EAAgB;QACtB,QAAQ,IAAA,CAAK,GAAG,KAAK;;IAGvB,KAAK,GAAG,IAAA,EAAgB;QACtB,QAAQ,IAAA,CAAK,GAAG,KAAK;;IAGvB,MAAM,GAAG,IAAA,EAAgB;QACvB,QAAQ,KAAA,CAAM,GAAG,KAAK;;IAGxB,MAAM,GAAG,IAAA,EAAgB;QACvB,QAAQ,KAAA,CAAM,GAAG,KAAK;;;;;;;;;;;GAa1B,IAAa,cAAb,MAA2C;IACxB,OAAA;IACT,UAAU,MAAA;IAElB,YAAY,MAAA,CAAgB;QAC1B,IAAA,CAAK,MAAA,GAAS;QAMd,OAAO,IAAI,MAAM,IAAA,EAAM;YACrB,KAAI,MAAA,EAAQ,IAAA,EAAM,QAAA,EAAmB;gBAEnC,IAAI,QAAQ,OACV,CAAA,OAAO,QAAQ,GAAA,CAAI,QAAQ,MAAM,SAAS;gBAI5C,OAAO,QAAQ,GAAA,CAAI,OAAO,MAAA,EAAQ,MAAM,SAAS;;SAEpD,CAAC;;IAGJ,KAAK,GAAG,IAAA,EAAgB;QACtB,IAAI,CAAC,IAAA,CAAK,OAAA,CAAS,CAAA;QACnB,IAAA,CAAK,MAAA,CAAO,IAAA,CAAK,GAAG,KAAK;;IAG3B,KAAK,GAAG,IAAA,EAAgB;QACtB,IAAI,CAAC,IAAA,CAAK,OAAA,CAAS,CAAA;QACnB,IAAA,CAAK,MAAA,CAAO,IAAA,CAAK,GAAG,KAAK;;IAG3B,MAAM,GAAG,IAAA,EAAgB;QACvB,IAAI,CAAC,IAAA,CAAK,OAAA,CAAS,CAAA;QACnB,IAAA,CAAK,MAAA,CAAO,KAAA,CAAM,GAAG,KAAK;;IAG5B,MAAM,GAAG,IAAA,EAAgB;QAEvB,IAAI,CAAC,IAAA,CAAK,OAAA,IAAW,CAAA,CAAE,OAAO,IAAA,CAAK,MAAA,CAAO,KAAA,KAAU,UAAA,EAAa,CAAA;QACjE,IAAA,CAAK,MAAA,CAAO,KAAA,CAAM,GAAG,KAAK;;IAG5B,SAAS;QACP,IAAA,CAAK,OAAA,GAAU;;IAGjB,UAAU;QACR,IAAA,CAAK,OAAA,GAAU;;IAGjB,MAAM,QAAQ;QAEZ,IAAI,IAAA,CAAK,MAAA,CAAO,WAAA,CAAY,IAAA,IAAQ,cAAc,IAAA,CAChD,CAAA;QAGF,MAAM,SAAS,IAAA,CAAK,MAAA;QAKpB,IAAI,OAAO,OAAO,KAAA,KAAU,YAAY;YACtC,MAAM,OAAO,KAAA,EAAO;YACpB;;QAIF,uWAAM,kBAAA,EAAiB","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 5543, "column": 0}, "map": {"version":3,"file":"Inngest.js","sources":["file:///Users/amansatyawani/Desktop/website-builder/node_modules/.pnpm/inngest%403.45.1_%40opentelemetry%2Bcore%402.2.0_%40opentelemetry%2Bapi%401.9.0__express%405.1.0_next%401_e029d374516642dd9a767b32fbb0beec/node_modules/src/components/Inngest.ts"],"sourcesContent":["import { InngestApi } from \"../api/api.ts\";\nimport {\n  defaultDevServerHost,\n  defaultInngestApiBaseUrl,\n  defaultInngestEventBaseUrl,\n  dummyEventKey,\n  envKeys,\n  headerKeys,\n  logPrefix,\n} from \"../helpers/consts.ts\";\nimport { createEntropy } from \"../helpers/crypto.ts\";\nimport { devServerAvailable, devServerUrl } from \"../helpers/devserver.ts\";\nimport {\n  allProcessEnv,\n  getFetch,\n  getMode,\n  inngestHeaders,\n  type Mode,\n  processEnv,\n} from \"../helpers/env.ts\";\nimport { fixEventKeyMissingSteps, prettyError } from \"../helpers/errors.ts\";\nimport type { Jsonify } from \"../helpers/jsonify.ts\";\nimport { retryWithBackoff } from \"../helpers/promises.ts\";\nimport { stringify } from \"../helpers/strings.ts\";\nimport type {\n  AsArray,\n  IsNever,\n  SendEventPayload,\n  SimplifyDeep,\n  SingleOrArray,\n  WithoutInternal,\n} from \"../helpers/types.ts\";\nimport {\n  DefaultLogger,\n  type Logger,\n  ProxyLogger,\n} from \"../middleware/logger.ts\";\nimport {\n  type ClientOptions,\n  type EventNameFromTrigger,\n  type EventPayload,\n  type FailureEventArgs,\n  type Handler,\n  type InvokeTargetFunctionDefinition,\n  type SendEventOutput,\n  type SendEventResponse,\n  sendEventResponseSchema,\n  type TriggersFromClient,\n} from \"../types.ts\";\nimport type { EventSchemas } from \"./EventSchemas.ts\";\nimport { InngestFunction } from \"./InngestFunction.ts\";\nimport type { InngestFunctionReference } from \"./InngestFunctionReference.ts\";\nimport {\n  type ExtendWithMiddleware,\n  getHookStack,\n  InngestMiddleware,\n  type MiddlewareRegisterFn,\n  type MiddlewareRegisterReturn,\n  type SendEventHookStack,\n} from \"./InngestMiddleware.ts\";\n\n/**\n * Capturing the global type of fetch so that we can reliably access it below.\n */\ntype FetchT = typeof fetch;\n\n/**\n * Given a set of client options for Inngest, return the event types that can\n * be sent or received.\n *\n * @public\n */\nexport type EventsFromOpts<TOpts extends ClientOptions> =\n  TOpts[\"schemas\"] extends EventSchemas<infer U>\n    ? U\n    : Record<string, EventPayload>;\n\n/**\n * A client used to interact with the Inngest API by sending or reacting to\n * events.\n *\n * To provide event typing, see {@link EventSchemas}.\n *\n * ```ts\n * const inngest = new Inngest({ id: \"my-app\" });\n *\n * // or to provide event typing too\n * const inngest = new Inngest({\n *   id: \"my-app\",\n *   schemas: new EventSchemas().fromRecord<{\n *     \"app/user.created\": {\n *       data: { userId: string };\n *     };\n *   }>(),\n * });\n * ```\n *\n * @public\n */\nexport class Inngest<TClientOpts extends ClientOptions = ClientOptions>\n  implements Inngest.Like\n{\n  get [Symbol.toStringTag](): typeof Inngest.Tag {\n    return Inngest.Tag;\n  }\n\n  /**\n   * The ID of this instance, most commonly a reference to the application it\n   * resides in.\n   *\n   * The ID of your client should remain the same for its lifetime; if you'd\n   * like to change the name of your client as it appears in the Inngest UI,\n   * change the `name` property instead.\n   */\n  public readonly id: string;\n\n  /**\n   * Stores the options so we can remember explicit settings the user has\n   * provided.\n   */\n  private readonly options: TClientOpts;\n\n  /**\n   * Inngest event key, used to send events to Inngest Cloud.\n   */\n  private eventKey = \"\";\n\n  private _apiBaseUrl: string | undefined;\n  private _eventBaseUrl: string | undefined;\n\n  private readonly inngestApi: InngestApi;\n\n  /**\n   * The absolute URL of the Inngest Cloud API.\n   */\n  private sendEventUrl: URL = new URL(\n    `e/${this.eventKey}`,\n    defaultInngestEventBaseUrl,\n  );\n\n  private headers!: Record<string, string>;\n\n  private readonly fetch: FetchT;\n\n  // biome-ignore lint/correctness/noUnusedPrivateClassMembers: used in the SDK\n  private readonly logger: Logger;\n\n  private localFns: InngestFunction.Any[] = [];\n\n  /**\n   * A promise that resolves when the middleware stack has been initialized and\n   * the client is ready to be used.\n   */\n  private readonly middleware: Promise<MiddlewareRegisterReturn[]>;\n\n  /**\n   * Whether the client is running in a production environment. This can\n   * sometimes be `undefined` if the client has expressed no preference or\n   * perhaps environment variables are only available at a later stage in the\n   * runtime, for example when receiving a request.\n   *\n   * An {@link InngestCommHandler} should prioritize this value over all other\n   * settings, but should still check for the presence of an environment\n   * variable if it is not set.\n   */\n  private _mode!: Mode;\n\n  protected readonly schemas?: NonNullable<TClientOpts[\"schemas\"]>;\n\n  private _appVersion: string | undefined;\n\n  get apiBaseUrl(): string | undefined {\n    return this._apiBaseUrl;\n  }\n\n  get eventBaseUrl(): string | undefined {\n    return this._eventBaseUrl;\n  }\n\n  get env(): string | null {\n    return this.headers[headerKeys.Environment] ?? null;\n  }\n\n  get appVersion(): string | undefined {\n    return this._appVersion;\n  }\n\n  /**\n   * A client used to interact with the Inngest API by sending or reacting to\n   * events.\n   *\n   * To provide event typing, see {@link EventSchemas}.\n   *\n   * ```ts\n   * const inngest = new Inngest({ name: \"My App\" });\n   *\n   * // or to provide event typing too\n   * const inngest = new Inngest({\n   *   name: \"My App\",\n   *   schemas: new EventSchemas().fromRecord<{\n   *     \"app/user.created\": {\n   *       data: { userId: string };\n   *     };\n   *   }>(),\n   * });\n   * ```\n   */\n  constructor(options: TClientOpts) {\n    this.options = options;\n\n    const {\n      id,\n      fetch,\n      logger = new DefaultLogger(),\n      middleware,\n      isDev,\n      schemas,\n      appVersion,\n    } = this.options;\n\n    if (!id) {\n      // TODO PrettyError\n      throw new Error(\"An `id` must be passed to create an Inngest instance.\");\n    }\n\n    this.id = id;\n\n    this._mode = getMode({\n      explicitMode:\n        typeof isDev === \"boolean\" ? (isDev ? \"dev\" : \"cloud\") : undefined,\n    });\n\n    this.fetch = getFetch(fetch);\n\n    this.inngestApi = new InngestApi({\n      baseUrl: this.apiBaseUrl,\n      signingKey: processEnv(envKeys.InngestSigningKey) || \"\",\n      signingKeyFallback: processEnv(envKeys.InngestSigningKeyFallback),\n      fetch: this.fetch,\n      mode: this.mode,\n    });\n\n    this.schemas = schemas;\n    this.loadModeEnvVars();\n\n    this.logger = logger;\n\n    this.middleware = this.initializeMiddleware([\n      ...builtInMiddleware,\n      ...(middleware || []),\n    ]);\n\n    this._appVersion = appVersion;\n  }\n\n  /**\n   * Returns a `Promise` that resolves when the app is ready and all middleware\n   * has been initialized.\n   */\n  public get ready(): Promise<void> {\n    return this.middleware.then(() => {});\n  }\n\n  /**\n   * Set the environment variables for this client. This is useful if you are\n   * passed environment variables at runtime instead of as globals and need to\n   * update the client with those values as requests come in.\n   */\n  public setEnvVars(\n    env: Record<string, string | undefined> = allProcessEnv(),\n  ): this {\n    this.mode = getMode({ env, client: this });\n\n    return this;\n  }\n\n  private loadModeEnvVars(): void {\n    this._apiBaseUrl =\n      this.options.baseUrl ||\n      this.mode[\"env\"][envKeys.InngestApiBaseUrl] ||\n      this.mode[\"env\"][envKeys.InngestBaseUrl] ||\n      this.mode.getExplicitUrl(defaultInngestApiBaseUrl);\n\n    this._eventBaseUrl =\n      this.options.baseUrl ||\n      this.mode[\"env\"][envKeys.InngestEventApiBaseUrl] ||\n      this.mode[\"env\"][envKeys.InngestBaseUrl] ||\n      this.mode.getExplicitUrl(defaultInngestEventBaseUrl);\n\n    this.setEventKey(\n      this.options.eventKey || this.mode[\"env\"][envKeys.InngestEventKey] || \"\",\n    );\n\n    this.headers = inngestHeaders({\n      inngestEnv: this.options.env,\n      env: this.mode[\"env\"],\n    });\n\n    this.inngestApi[\"mode\"] = this.mode;\n    this.inngestApi[\"apiBaseUrl\"] = this._apiBaseUrl;\n  }\n\n  /**\n   * Initialize all passed middleware, running the `register` function on each\n   * in sequence and returning the requested hook registrations.\n   */\n  private async initializeMiddleware(\n    middleware: InngestMiddleware.Like[] = [],\n    opts?: {\n      registerInput?: Omit<Parameters<MiddlewareRegisterFn>[0], \"client\">;\n      prefixStack?: Promise<MiddlewareRegisterReturn[]>;\n    },\n  ): Promise<MiddlewareRegisterReturn[]> {\n    /**\n     * Wait for the prefix stack to run first; do not trigger ours before this\n     * is complete.\n     */\n    const prefix = await (opts?.prefixStack ?? []);\n\n    const stack = middleware.reduce<Promise<MiddlewareRegisterReturn[]>>(\n      async (acc, m) => {\n        // Be explicit about waiting for the previous middleware to finish\n        const prev = await acc;\n        const next = await (m as InngestMiddleware.Any).init({\n          client: this,\n          ...opts?.registerInput,\n        });\n\n        return [...prev, next];\n      },\n      Promise.resolve([]),\n    );\n\n    return [...prefix, ...(await stack)];\n  }\n\n  private get mode(): Mode {\n    return this._mode;\n  }\n\n  private set mode(m) {\n    this._mode = m;\n    this.loadModeEnvVars();\n  }\n\n  /**\n   * Given a response from Inngest, relay the error to the caller.\n   */\n  private async getResponseError(\n    response: globalThis.Response,\n    rawBody: unknown,\n    foundErr = \"Unknown error\",\n  ): Promise<Error> {\n    let errorMessage = foundErr;\n\n    if (errorMessage === \"Unknown error\") {\n      switch (response.status) {\n        case 401:\n          errorMessage = \"Event key Not Found\";\n          break;\n        case 400:\n          errorMessage = \"Cannot process event payload\";\n          break;\n        case 403:\n          errorMessage = \"Forbidden\";\n          break;\n        case 404:\n          errorMessage = \"Event key not found\";\n          break;\n        case 406:\n          errorMessage = `${JSON.stringify(await rawBody)}`;\n          break;\n        case 409:\n        case 412:\n          errorMessage = \"Event transformation failed\";\n          break;\n        case 413:\n          errorMessage = \"Event payload too large\";\n          break;\n        case 500:\n          errorMessage = \"Internal server error\";\n          break;\n        default:\n          try {\n            errorMessage = await response.text();\n          } catch (_err) {\n            errorMessage = `${JSON.stringify(await rawBody)}`;\n          }\n          break;\n      }\n    }\n\n    return new Error(`Inngest API Error: ${response.status} ${errorMessage}`);\n  }\n\n  /**\n   * Set the event key for this instance of Inngest. This is useful if for some\n   * reason the key is not available at time of instantiation or present in the\n   * `INNGEST_EVENT_KEY` environment variable.\n   */\n  public setEventKey(\n    /**\n     * Inngest event key, used to send events to Inngest Cloud. Use this is your\n     * key is for some reason not available at time of instantiation or present\n     * in the `INNGEST_EVENT_KEY` environment variable.\n     */\n    eventKey: string,\n  ): void {\n    this.eventKey = eventKey || dummyEventKey;\n\n    this.sendEventUrl = new URL(\n      `e/${this.eventKey}`,\n      this.eventBaseUrl || defaultInngestEventBaseUrl,\n    );\n  }\n\n  private eventKeySet(): boolean {\n    return Boolean(this.eventKey) && this.eventKey !== dummyEventKey;\n  }\n\n  /**\n   * EXPERIMENTAL: This API is not yet stable and may change in the future\n   * without a major version bump.\n   *\n   * Send a Signal to Inngest.\n   */\n  public async sendSignal({\n    signal,\n    data,\n    env,\n  }: {\n    /**\n     * The signal to send.\n     */\n    signal: string;\n\n    /**\n     * The data to send with the signal.\n     */\n    data?: unknown;\n\n    /**\n     * The Inngest environment to send the signal to. Defaults to whichever\n     * environment this client's key is associated with.\n     *\n     * It's like you never need to change this unless you're trying to sync\n     * multiple systems together using branch names.\n     */\n    env?: string;\n  }): Promise<InngestApi.SendSignalResponse> {\n    const headers: Record<string, string> = {\n      ...(env ? { [headerKeys.Environment]: env } : {}),\n    };\n\n    return this._sendSignal({ signal, data, headers });\n  }\n\n  private async _sendSignal({\n    signal,\n    data,\n    headers,\n  }: {\n    signal: string;\n    data?: unknown;\n    headers?: Record<string, string>;\n  }): Promise<InngestApi.SendSignalResponse> {\n    const res = await this.inngestApi.sendSignal(\n      { signal, data },\n      { ...this.headers, ...headers },\n    );\n    if (res.ok) {\n      return res.value;\n    }\n\n    throw new Error(\n      `Failed to send signal: ${res.error?.error || \"Unknown error\"}`,\n    );\n  }\n\n  /**\n   * Send one or many events to Inngest. Takes an entire payload (including\n   * name) as each input.\n   *\n   * ```ts\n   * await inngest.send({ name: \"app/user.created\", data: { id: 123 } });\n   * ```\n   *\n   * Returns a promise that will resolve if the event(s) were sent successfully,\n   * else throws with an error explaining what went wrong.\n   *\n   * If you wish to send an event with custom types (i.e. one that hasn't been\n   * generated), make sure to add it when creating your Inngest instance, like\n   * so:\n   *\n   * ```ts\n   * const inngest = new Inngest({\n   *   name: \"My App\",\n   *   schemas: new EventSchemas().fromRecord<{\n   *     \"my/event\": {\n   *       name: \"my/event\";\n   *       data: { bar: string };\n   *     };\n   *   }>(),\n   * });\n   * ```\n   */\n  public async send<Payload extends SendEventPayload<GetEvents<this>>>(\n    payload: Payload,\n    options?: {\n      /**\n       * The Inngest environment to send events to. Defaults to whichever\n       * environment this client's event key is associated with.\n       *\n       * It's likely you never need to change this unless you're trying to sync\n       * multiple systems together using branch names.\n       */\n      env?: string;\n    },\n  ): Promise<SendEventOutput<TClientOpts>> {\n    const headers: Record<string, string> = {\n      ...(options?.env ? { [headerKeys.Environment]: options.env } : {}),\n    };\n\n    return this._send({ payload, headers });\n  }\n\n  /**\n   * Internal method for sending an event, used to allow Inngest internals to\n   * further customize the request sent to an Inngest Server.\n   */\n  private async _send<Payload extends SendEventPayload<GetEvents<this>>>({\n    payload,\n    headers,\n  }: {\n    payload: Payload;\n    headers?: Record<string, string>;\n  }): Promise<SendEventOutput<TClientOpts>> {\n    const nowMillis = new Date().getTime();\n\n    let maxAttempts = 5;\n\n    // Attempt to set the event ID seed header. If it fails then disable retries\n    // (but we still want to send the event).\n    try {\n      const entropy = createEntropy(10);\n      const entropyBase64 = Buffer.from(entropy).toString(\"base64\");\n      headers = {\n        ...headers,\n        [headerKeys.EventIdSeed]: `${nowMillis},${entropyBase64}`,\n      };\n    } catch (err) {\n      let message = \"Event-sending retries disabled\";\n      if (err instanceof Error) {\n        message += `: ${err.message}`;\n      }\n\n      console.debug(message);\n\n      // Disable retries.\n      maxAttempts = 1;\n    }\n\n    const hooks = await getHookStack(\n      this.middleware,\n      \"onSendEvent\",\n      undefined,\n      {\n        transformInput: (prev, output) => {\n          return { ...prev, ...output };\n        },\n        transformOutput(prev, output) {\n          return {\n            result: { ...prev.result, ...output?.result },\n          };\n        },\n      },\n    );\n\n    let payloads: EventPayload[] = Array.isArray(payload)\n      ? (payload as EventPayload[])\n      : payload\n        ? ([payload] as [EventPayload])\n        : [];\n\n    const inputChanges = await hooks.transformInput?.({\n      payloads: [...payloads],\n    });\n    if (inputChanges?.payloads) {\n      payloads = [...inputChanges.payloads];\n    }\n\n    // Ensure that we always add \"ts\" and \"data\" fields to events. \"ts\" is auto-\n    // filled by the event server so is safe, and adding here fixes Next.js\n    // server action cache issues.\n    payloads = payloads.map((p) => {\n      return {\n        ...p,\n        // Always generate an idempotency ID for an event for retries\n        id: p.id,\n        ts: p.ts || nowMillis,\n        data: p.data || {},\n      };\n    });\n\n    const applyHookToOutput = async (\n      arg: Parameters<NonNullable<SendEventHookStack[\"transformOutput\"]>>[0],\n    ): Promise<SendEventOutput<TClientOpts>> => {\n      const hookOutput = await hooks.transformOutput?.(arg);\n      return {\n        ...arg.result,\n        ...hookOutput?.result,\n        // \n      } as unknown as SendEventOutput<TClientOpts>;\n    };\n\n    /**\n     * It can be valid for a user to send an empty list of events; if this\n     * happens, show a warning that this may not be intended, but don't throw.\n     */\n    if (!payloads.length) {\n      console.warn(\n        prettyError({\n          type: \"warn\",\n          whatHappened: \"`inngest.send()` called with no events\",\n          reassurance:\n            \"This is not an error, but you may not have intended to do this.\",\n          consequences:\n            \"The returned promise will resolve, but no events have been sent to Inngest.\",\n          stack: true,\n        }),\n      );\n\n      return await applyHookToOutput({ result: { ids: [] } });\n    }\n\n    // When sending events, check if the dev server is available.  If so, use the\n    // dev server.\n    let url = this.sendEventUrl.href;\n\n    /**\n     * If in prod mode and key is not present, fail now.\n     */\n    if (this.mode.isCloud && !this.eventKeySet()) {\n      throw new Error(\n        prettyError({\n          whatHappened: \"Failed to send event\",\n          consequences: \"Your event or events were not sent to Inngest.\",\n          why: \"We couldn't find an event key to use to send events to Inngest.\",\n          toFixNow: fixEventKeyMissingSteps,\n        }),\n      );\n    }\n\n    /**\n     * If dev mode has been inferred, try to hit the dev server first to see if\n     * it exists. If it does, use it, otherwise fall back to whatever server we\n     * have configured.\n     *\n     * `INNGEST_BASE_URL` is used to set both dev server and prod URLs, so if a\n     * user has set this it means they have already chosen a URL to hit.\n     */\n    if (this.mode.isDev && this.mode.isInferred && !this.eventBaseUrl) {\n      const devAvailable = await devServerAvailable(\n        defaultDevServerHost,\n        this.fetch,\n      );\n\n      if (devAvailable) {\n        url = devServerUrl(defaultDevServerHost, `e/${this.eventKey}`).href;\n      }\n    }\n\n    const body = await retryWithBackoff(\n      async () => {\n        let rawBody: unknown;\n        let body: SendEventResponse | undefined;\n\n        // We don't need to do fallback auth here because this uses event keys and\n        // not signing keys\n        const response = await this.fetch(url, {\n          method: \"POST\",\n          body: stringify(payloads),\n          headers: { ...this.headers, ...headers },\n        });\n\n        try {\n          rawBody = await response.json();\n          body = await sendEventResponseSchema.parseAsync(rawBody);\n        } catch (_err) {\n          throw await this.getResponseError(response, rawBody);\n        }\n\n        if (body.status !== 200 || body.error) {\n          throw await this.getResponseError(response, rawBody, body.error);\n        }\n\n        return body;\n      },\n      {\n        maxAttempts,\n        baseDelay: 100,\n      },\n    );\n\n    return await applyHookToOutput({ result: { ids: body.ids } });\n  }\n\n  public createFunction: Inngest.CreateFunction<this> = (\n    rawOptions,\n    rawTrigger,\n    handler,\n  ) => {\n    const fn = this._createFunction(rawOptions, rawTrigger, handler);\n\n    this.localFns.push(fn);\n\n    return fn;\n  };\n\n  public get funcs() {\n    return this.localFns;\n  }\n\n  private _createFunction: Inngest.CreateFunction<this> = (\n    rawOptions,\n    rawTrigger,\n    handler,\n  ) => {\n    const options = this.sanitizeOptions(rawOptions);\n    const triggers = this.sanitizeTriggers(rawTrigger);\n\n    return new InngestFunction(\n      this,\n      {\n        ...options,\n        triggers,\n      },\n      handler,\n    );\n  };\n\n  /**\n   * Runtime-only validation.\n   */\n  private sanitizeOptions<T extends InngestFunction.Options>(options: T): T {\n    if (Object.hasOwn(options, \"fns\")) {\n      // v2 -> v3 migration warning\n      console.warn(\n        `${logPrefix} InngestFunction: \\`fns\\` option has been deprecated in v3; use \\`middleware\\` instead. See https://www.inngest.com/docs/sdk/migration`,\n      );\n    }\n\n    if (typeof options === \"string\") {\n      // v2 -> v3 runtime migraton warning\n      console.warn(\n        `${logPrefix} InngestFunction: Creating a function with a string as the first argument has been deprecated in v3; pass an object instead. See https://www.inngest.com/docs/sdk/migration`,\n      );\n\n      return { id: options as string } as T;\n    }\n\n    return options;\n  }\n\n  /**\n   * Runtime-only validation.\n   */\n  private sanitizeTriggers<\n    T extends SingleOrArray<InngestFunction.Trigger<string>>,\n  >(triggers: T): AsArray<T> {\n    if (typeof triggers === \"string\") {\n      // v2 -> v3 migration warning\n      console.warn(\n        `${logPrefix} InngestFunction: Creating a function with a string as the second argument has been deprecated in v3; pass an object instead. See https://www.inngest.com/docs/sdk/migration`,\n      );\n\n      return [{ event: triggers as string }] as AsArray<T>;\n    }\n\n    if (!Array.isArray(triggers)) {\n      return [triggers] as AsArray<T>;\n    }\n\n    return triggers as AsArray<T>;\n  }\n}\n\n/**\n * Default middleware that is included in every client, placed after the user's\n * middleware on the client but before function-level middleware.\n *\n * It is defined here to ensure that comments are included in the generated TS\n * definitions. Without this, we infer the stack of built-in middleware without\n * comments, losing a lot of value.\n *\n * If this is moved, please ensure that using this package in another project\n * can correctly access comments on mutated input and output.\n *\n * This return pattern mimics the output of a `satisfies` suffix; it's used as\n * we support versions of TypeScript prior to the introduction of `satisfies`.\n */\nexport const builtInMiddleware = (<T extends InngestMiddleware.Stack>(\n  m: T,\n): T => m)([\n  new InngestMiddleware({\n    name: \"Inngest: Logger\",\n    init({ client }) {\n      return {\n        onFunctionRun(arg) {\n          const { ctx } = arg;\n\n          const metadata = {\n            runID: ctx.runId,\n            eventName: ctx.event.name,\n            functionName: arg.fn.name,\n          };\n\n          let providedLogger: Logger = client[\"logger\"];\n          // create a child logger if the provided logger has child logger implementation\n          try {\n            if (\"child\" in providedLogger) {\n              type ChildLoggerFn = (\n                metadata: Record<string, unknown>,\n              ) => Logger;\n              providedLogger = (providedLogger.child as ChildLoggerFn)(\n                metadata,\n              );\n            }\n          } catch (err) {\n            console.error('failed to create \"childLogger\" with error: ', err);\n            // no-op\n          }\n          const logger = new ProxyLogger(providedLogger);\n\n          return {\n            transformInput() {\n              return {\n                ctx: {\n                  /**\n                   * The passed in logger from the user.\n                   * Defaults to a console logger if not provided.\n                   */\n                  logger: logger as Logger,\n                },\n              };\n            },\n            beforeExecution() {\n              logger.enable();\n            },\n            transformOutput({ result: { error } }) {\n              if (error) {\n                logger.error(error);\n              }\n            },\n            async beforeResponse() {\n              await logger.flush();\n            },\n          };\n        },\n      };\n    },\n  }),\n]);\n\n/**\n * A client used to interact with the Inngest API by sending or reacting to\n * events.\n *\n * To provide event typing, see {@link EventSchemas}.\n *\n * ```ts\n * const inngest = new Inngest({ name: \"My App\" });\n *\n * // or to provide event typing too\n * const inngest = new Inngest({\n *   name: \"My App\",\n *   schemas: new EventSchemas().fromRecord<{\n *     \"app/user.created\": {\n *       data: { userId: string };\n *     };\n *   }>(),\n * });\n * ```\n *\n * @public\n */\nexport namespace Inngest {\n  export const Tag = \"Inngest.App\" as const;\n\n  /**\n   * Represents any `Inngest` instance, regardless of generics and inference.\n   *\n   * Prefer use of `Inngest.Like` where possible to ensure compatibility with\n   * multiple versions.\n   */\n  export type Any = Inngest;\n\n  /**\n   * References any `Inngest` instance across library versions, useful for use\n   * in public APIs to ensure compatibility with multiple versions.\n   *\n   * Prefer use of `Inngest.Any` internally and `Inngest.Like` for public APIs.\n   */\n  export interface Like {\n    readonly [Symbol.toStringTag]: typeof Inngest.Tag;\n  }\n\n  export type CreateFunction<TClient extends Inngest.Any> = <\n    TMiddleware extends InngestMiddleware.Stack,\n    TTrigger extends SingleOrArray<\n      InngestFunction.Trigger<TriggersFromClient<TClient>>\n    >,\n    THandler extends Handler.Any = Handler<\n      TClient,\n      EventNameFromTrigger<GetEvents<TClient, true>, AsArray<TTrigger>[number]>,\n      ExtendWithMiddleware<\n        [\n          typeof builtInMiddleware,\n          NonNullable<ClientOptionsFromInngest<TClient>[\"middleware\"]>,\n          TMiddleware,\n        ]\n      >\n    >,\n    TFailureHandler extends Handler.Any = Handler<\n      TClient,\n      EventNameFromTrigger<GetEvents<TClient, true>, AsArray<TTrigger>[number]>,\n      ExtendWithMiddleware<\n        [\n          typeof builtInMiddleware,\n          NonNullable<ClientOptionsFromInngest<TClient>[\"middleware\"]>,\n          TMiddleware,\n        ],\n        FailureEventArgs<\n          GetEvents<TClient, true>[EventNameFromTrigger<\n            GetEvents<TClient, true>,\n            AsArray<TTrigger>[number]\n          >]\n        >\n      >\n    >,\n  >(\n    options: Omit<\n      InngestFunction.Options<\n        TClient,\n        TMiddleware,\n        AsArray<TTrigger>,\n        TFailureHandler\n      >,\n      \"triggers\"\n    >,\n    trigger: TTrigger,\n    handler: THandler,\n  ) => InngestFunction<\n    Omit<\n      InngestFunction.Options<\n        TClient,\n        TMiddleware,\n        AsArray<TTrigger>,\n        TFailureHandler\n      >,\n      \"triggers\"\n    >,\n    THandler,\n    TFailureHandler,\n    TClient,\n    TMiddleware,\n    AsArray<TTrigger>\n  >;\n}\n\n/**\n * A helper type to extract the type of a set of event tooling from a given\n * Inngest instance and optionally a trigger.\n *\n * @example Get generic step tools for an Inngest instance.\n * ```ts\n * type StepTools = GetStepTools<typeof inngest>;\n * ```\n *\n * @example Get step tools with a trigger, ensuring tools like `waitForEvent` are typed.\n * ```ts\n * type StepTools = GetStepTools<typeof Inngest, \"github/pull_request\">;\n * ```\n *\n * @public\n */\nexport type GetStepTools<\n  TInngest extends Inngest.Any,\n  TTrigger extends keyof GetEvents<TInngest> &\n    string = keyof GetEvents<TInngest> & string,\n> = GetFunctionInput<TInngest, TTrigger> extends { step: infer TStep }\n  ? TStep\n  : never;\n\n/**\n * A helper type to extract the type of the input to a function from a given\n * Inngest instance and optionally a trigger.\n *\n * @example Get generic function input for an Inngest instance.\n * ```ts\n * type Input = GetFunctionInput<typeof inngest>;\n * ```\n *\n * @example Get function input with a trigger, ensuring tools like `waitForEvent` are typed.\n * ```ts\n * type Input = GetFunctionInput<typeof Inngest, \"github/pull_request\">;\n * ```\n *\n * @public\n */\nexport type GetFunctionInput<\n  TClient extends Inngest.Any,\n  TTrigger extends TriggersFromClient<TClient> = TriggersFromClient<TClient>,\n> = Parameters<\n  // Handler<\n  //   ClientOptionsFromInngest<TInngest>,\n  //   GetEvents<TInngest, true>,\n  //   TTrigger,\n  //   ExtendWithMiddleware<\n  //     [\n  //       typeof builtInMiddleware,\n  //       NonNullable<ClientOptionsFromInngest<TInngest>[\"middleware\"]>,\n  //     ]\n  //   >\n  // >\n  Handler<\n    TClient,\n    TTrigger,\n    ExtendWithMiddleware<\n      [\n        typeof builtInMiddleware,\n        NonNullable<ClientOptionsFromInngest<TClient>[\"middleware\"]>,\n      ]\n    >\n  >\n>[0];\n\n/**\n * A helper type to extract the type of the output of an Inngest function.\n *\n * @example Get a function's output\n * ```ts\n * type Output = GetFunctionOutput<typeof myFunction>;\n * ```\n *\n * @public\n */\nexport type GetFunctionOutput<\n  TFunction extends InvokeTargetFunctionDefinition,\n> = TFunction extends InngestFunction.Any\n  ? GetFunctionOutputFromInngestFunction<TFunction>\n  : TFunction extends InngestFunctionReference.Any\n    ? GetFunctionOutputFromReferenceInngestFunction<TFunction>\n    : unknown;\n\n/**\n * A helper type to extract the type of the output of an Inngest function.\n *\n * Used internally for {@link GetFunctionOutput}. Code outside of this package\n * should use {@link GetFunctionOutput} instead.\n *\n * @internal\n */\nexport type GetFunctionOutputFromInngestFunction<\n  TFunction extends InngestFunction.Any,\n  // biome-ignore lint/suspicious/noExplicitAny: <explanation>\n> = TFunction extends InngestFunction<any, infer IHandler, any, any, any, any>\n  ? IsNever<SimplifyDeep<Jsonify<Awaited<ReturnType<IHandler>>>>> extends true\n    ? null\n    : SimplifyDeep<Jsonify<Awaited<ReturnType<IHandler>>>>\n  : unknown;\n\n/**\n * A helper type to extract the type of the output of a referenced Inngest\n * function.\n *\n * Used internally for {@link GetFunctionOutput}. Code outside of this package\n * should use {@link GetFunctionOutput} instead.\n *\n * @internal\n */\nexport type GetFunctionOutputFromReferenceInngestFunction<\n  TFunction extends InngestFunctionReference.Any,\n  // biome-ignore lint/suspicious/noExplicitAny: <explanation>\n> = TFunction extends InngestFunctionReference<any, infer IOutput>\n  ? IsNever<SimplifyDeep<Jsonify<IOutput>>> extends true\n    ? null\n    : SimplifyDeep<Jsonify<IOutput>>\n  : unknown;\n\n/**\n * When passed an Inngest client, will return all event types for that client.\n *\n * It's recommended to use this instead of directly reusing your event types, as\n * Inngest will add extra properties and internal events such as `ts` and\n * `inngest/function.finished`.\n *\n * @example\n * ```ts\n * import { EventSchemas, Inngest, type GetEvents } from \"inngest\";\n *\n * export const inngest = new Inngest({\n *   id: \"example-app\",\n *   schemas: new EventSchemas().fromRecord<{\n *     \"app/user.created\": { data: { userId: string } };\n *   }>(),\n * });\n *\n * type Events = GetEvents<typeof inngest>;\n * type AppUserCreated = Events[\"app/user.created\"];\n *\n * ```\n *\n * @public\n */\nexport type GetEvents<\n  TInngest extends Inngest.Any,\n  TWithInternal extends boolean = false,\n> = TWithInternal extends true\n  ? EventsFromOpts<ClientOptionsFromInngest<TInngest>>\n  : WithoutInternal<EventsFromOpts<ClientOptionsFromInngest<TInngest>>>;\n\n/**\n * A helper type to extract the inferred options from a given Inngest instance.\n *\n * @example\n * ```ts\n * type Options = ClientOptionsFromInngest<typeof inngest>;\n * ```\n *\n * @public\n */\n\nexport type ClientOptionsFromInngest<TInngest extends Inngest.Any> =\n  TInngest extends Inngest<infer U> ? U : ClientOptions;\n"],"names":["headers: Record<string, string>","payloads: EventPayload[]","rawBody: unknown","body: SendEventResponse | undefined","providedLogger: Logger"],"mappings":"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","ignoreList":[0],"debugId":null}}]
}