{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 7, "column": 0}, "map": {"version":3,"sources":["file:///Users/amansatyawani/Desktop/website-builder/node_modules/.pnpm/%40inngest%2Bagent-kit%400.13.2_inngest%403.45.1_%40opentelemetry%2Bcore%402.2.0_%40opentelemetry%2Bapi%401_72b4b5017e99274ceeae5e0c8735609d/node_modules/%40inngest/agent-kit/src/types.ts","file:///Users/amansatyawani/Desktop/website-builder/node_modules/.pnpm/%40inngest%2Bagent-kit%400.13.2_inngest%403.45.1_%40opentelemetry%2Bcore%402.2.0_%40opentelemetry%2Bapi%401_72b4b5017e99274ceeae5e0c8735609d/node_modules/%40inngest/agent-kit/src/state.ts","file:///Users/amansatyawani/Desktop/website-builder/node_modules/.pnpm/%40inngest%2Bagent-kit%400.13.2_inngest%403.45.1_%40opentelemetry%2Bcore%402.2.0_%40opentelemetry%2Bapi%401_72b4b5017e99274ceeae5e0c8735609d/node_modules/%40inngest/agent-kit/src/util.ts","file:///Users/amansatyawani/Desktop/website-builder/node_modules/.pnpm/%40inngest%2Bagent-kit%400.13.2_inngest%403.45.1_%40opentelemetry%2Bcore%402.2.0_%40opentelemetry%2Bapi%401_72b4b5017e99274ceeae5e0c8735609d/node_modules/%40inngest/agent-kit/src/network.ts","file:///Users/amansatyawani/Desktop/website-builder/node_modules/.pnpm/%40inngest%2Bagent-kit%400.13.2_inngest%403.45.1_%40opentelemetry%2Bcore%402.2.0_%40opentelemetry%2Bapi%401_72b4b5017e99274ceeae5e0c8735609d/node_modules/%40inngest/agent-kit/src/agent.ts","file:///Users/amansatyawani/Desktop/website-builder/node_modules/.pnpm/%40inngest%2Bagent-kit%400.13.2_inngest%403.45.1_%40opentelemetry%2Bcore%402.2.0_%40opentelemetry%2Bapi%401_72b4b5017e99274ceeae5e0c8735609d/node_modules/%40inngest/agent-kit/src/model.ts","file:///Users/amansatyawani/Desktop/website-builder/node_modules/.pnpm/%40inngest%2Bagent-kit%400.13.2_inngest%403.45.1_%40opentelemetry%2Bcore%402.2.0_%40opentelemetry%2Bapi%401_72b4b5017e99274ceeae5e0c8735609d/node_modules/%40inngest/agent-kit/src/adapters/index.ts","file:///Users/amansatyawani/Desktop/website-builder/node_modules/.pnpm/%40inngest%2Bagent-kit%400.13.2_inngest%403.45.1_%40opentelemetry%2Bcore%402.2.0_%40opentelemetry%2Bapi%401_72b4b5017e99274ceeae5e0c8735609d/node_modules/%40inngest/agent-kit/src/adapters/anthropic.ts","file:///Users/amansatyawani/Desktop/website-builder/node_modules/.pnpm/%40inngest%2Bagent-kit%400.13.2_inngest%403.45.1_%40opentelemetry%2Bcore%402.2.0_%40opentelemetry%2Bapi%401_72b4b5017e99274ceeae5e0c8735609d/node_modules/%40inngest/agent-kit/src/tool.ts","file:///Users/amansatyawani/Desktop/website-builder/node_modules/.pnpm/%40inngest%2Bagent-kit%400.13.2_inngest%403.45.1_%40opentelemetry%2Bcore%402.2.0_%40opentelemetry%2Bapi%401_72b4b5017e99274ceeae5e0c8735609d/node_modules/%40inngest/agent-kit/src/adapters/openai.ts","file:///Users/amansatyawani/Desktop/website-builder/node_modules/.pnpm/%40inngest%2Bagent-kit%400.13.2_inngest%403.45.1_%40opentelemetry%2Bcore%402.2.0_%40opentelemetry%2Bapi%401_72b4b5017e99274ceeae5e0c8735609d/node_modules/%40inngest/agent-kit/src/adapters/azure-openai.ts","file:///Users/amansatyawani/Desktop/website-builder/node_modules/.pnpm/%40inngest%2Bagent-kit%400.13.2_inngest%403.45.1_%40opentelemetry%2Bcore%402.2.0_%40opentelemetry%2Bapi%401_72b4b5017e99274ceeae5e0c8735609d/node_modules/%40inngest/agent-kit/src/adapters/gemini.ts","file:///Users/amansatyawani/Desktop/website-builder/node_modules/.pnpm/%40inngest%2Bagent-kit%400.13.2_inngest%403.45.1_%40opentelemetry%2Bcore%402.2.0_%40opentelemetry%2Bapi%401_72b4b5017e99274ceeae5e0c8735609d/node_modules/%40inngest/agent-kit/src/adapters/grok.ts","file:///Users/amansatyawani/Desktop/website-builder/node_modules/.pnpm/%40inngest%2Bagent-kit%400.13.2_inngest%403.45.1_%40opentelemetry%2Bcore%402.2.0_%40opentelemetry%2Bapi%401_72b4b5017e99274ceeae5e0c8735609d/node_modules/%40inngest/agent-kit/src/streaming.ts","file:///Users/amansatyawani/Desktop/website-builder/node_modules/.pnpm/%40inngest%2Bagent-kit%400.13.2_inngest%403.45.1_%40opentelemetry%2Bcore%402.2.0_%40opentelemetry%2Bapi%401_72b4b5017e99274ceeae5e0c8735609d/node_modules/%40inngest/agent-kit/src/history.ts"],"sourcesContent":["import xxh from \"xxhashjs\";\n\nexport type Message = TextMessage | ToolCallMessage | ToolResultMessage;\n\n/**\n * UserMessage represents a rich message object from a client that can contain\n * not just the message content but also client-side state, timestamps, and\n * optional system prompts for a single turn.\n */\nexport interface UserMessage {\n  /** The canonical, client-generated unique identifier for the message. */\n  id: string;\n\n  /** The text content of the user's message. */\n  content: string;\n\n  /** The role is always 'user' to accurately represent the source. */\n  role: \"user\";\n\n  /** Optional, client-provided state snapshot to be persisted. */\n  state?: Record<string, unknown>;\n\n  /** Optional, client-provided timestamp for optimistic UI ordering. */\n  clientTimestamp?: Date | string;\n\n  /** Optional, one-time system prompt to prepend for this specific turn. */\n  systemPrompt?: string;\n}\n\n/**\n * TextMessage represents plain text messages in the chat history, eg. the user's prompt or\n * an assistant's reply.\n */\nexport interface TextMessage {\n  type: \"text\";\n  role: \"system\" | \"user\" | \"assistant\";\n  content: string | Array<TextContent>;\n  // Anthropic:\n  // stop_reason: \"end_turn\" | \"max_tokens\" | \"stop_sequence\" | \"tool_use\" | null;\n  // OpenAI:\n  // finish_reason: 'stop' | 'length' | 'tool_calls' | 'content_filter' | 'function_call' | null;\n  stop_reason?: \"tool\" | \"stop\";\n}\n\n/**\n * ToolCallMessage represents a message for a tool call.\n */\nexport interface ToolCallMessage {\n  type: \"tool_call\";\n  role: \"user\" | \"assistant\";\n  tools: ToolMessage[];\n  stop_reason: \"tool\";\n}\n\n/**\n * ToolResultMessage represents the output of a tool call.\n */\nexport interface ToolResultMessage {\n  type: \"tool_result\";\n  role: \"tool_result\";\n  // tool contains the tool call request for this result.\n  tool: ToolMessage;\n  content: unknown;\n  stop_reason: \"tool\";\n}\n\n// Message content.\n\nexport interface TextContent {\n  type: \"text\";\n  text: string;\n}\n\nexport interface ToolMessage {\n  type: \"tool\";\n  id: string;\n  name: string;\n  input: Record<string, unknown>;\n}\n\n/**\n * AgentResult represents a single iteration of an agent call in the router\n * loop.  This includes the input prompt, the resulting messages, and any\n * tool call results.\n *\n * This is used in several ways:\n *\n *   1. To track the results of a given agent, including output and tool results.\n *   2. To construct chat history for each agent call in a network loop.\n *   3. To track what was sent to a given agent at any time.\n *\n *\n * ## Chat history and agent inputs in Networks.\n *\n * Networks call agents in a loop.  Each iteration of the loop adds to conversation\n * history.\n *\n * We construct the agent input by:\n *\n *   1. Taking the system prompt from an agent\n *   2. Adding the user request as a message\n *   3. If provided, adding the agent's assistant message.\n *\n * These two or three messages are ALWAYS the start of an agent's request:\n * [system, input, ?assistant].\n *\n * We then iterate through the state's AgentResult objects, adding the output\n * and tool calls from each result to chat history.\n *\n */\nexport class AgentResult {\n  constructor(\n    /**\n     * agentName represents the name of the agent which created this result.\n     */\n    public agentName: string,\n\n    /**\n     * output represents the parsed output from the inference call.  This may be blank\n     * if the agent responds with tool calls only.\n     */\n    public output: Message[],\n\n    /**\n     * toolCalls represents output from any tools called by the agent.\n     */\n    public toolCalls: ToolResultMessage[],\n\n    /**\n     * createdAt represents when this message was created.\n     */\n    public createdAt: Date,\n\n    /**\n     * prompt represents the input instructions - without any additional history\n     * - as created by the agent.  This includes the system prompt, the user input,\n     * and any initial agent assistant message.\n     *\n     * This is ONLY used for tracking and debugging purposes, and is entirely optional.\n     * It is not used to construct messages for future calls, and only serves to see\n     * what was sent to the agent in this specific request.\n     */\n    public prompt?: Message[],\n\n    /**\n     * history represents the history sent to the inference call, appended to the\n     * prompt to form a complete conversation log.\n     *\n     * This is ONLY used for tracking and debugging purposes, and is entirely optional.\n     * It is not used to construct messages for future calls, and only serves to see\n     * what was sent to the agent in this specific request.\n     */\n    public history?: Message[],\n\n    /**\n     * raw represents the raw API response from the call.  This is a JSON\n     * string, and the format depends on the agent's model.\n     */\n    public raw?: string,\n\n    /**\n     * id represents the unique identifier for this agent result.\n     * This is used for persistence and message identification.\n     */\n    public id?: string\n  ) {}\n\n  // checksum memoizes a checksum so that it doe snot have to be calculated many times.\n  #checksum?: string;\n\n  /**\n   * export returns all fields necessary to store the AgentResult for future use.\n   */\n  export() {\n    return {\n      agentName: this.agentName,\n      output: this.output,\n      toolCalls: this.toolCalls,\n      createdAt: this.createdAt,\n      checksum: this.checksum,\n    };\n  }\n\n  /**\n   * checksum is a unique ID for this result.\n   *\n   * It is generated by taking a checksum of the message output and the created at date.\n   * This allows you to dedupe items when saving conversation history.\n   */\n  get checksum(): string {\n    if (this.#checksum === undefined) {\n      const input =\n        JSON.stringify(this.output.concat(this.toolCalls)) +\n        this.createdAt.toString();\n      this.#checksum = xxh.h64(input, 0).toString();\n    }\n    return this.#checksum;\n  }\n}\n","import { type AgentResult, type Message } from \"./types\";\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type StateData = Record<string, any>;\n\n/**\n * createState creates new state for a given network.  You can add any\n * initial state data for routing, plus provide an object of previous\n * AgentResult objects or conversation history within Message.\n *\n * To store chat history, we strongly recommend serializing and storing\n * the list of AgentResult items from state after each network run.\n *\n * You can then load and pass those messages into this constructor to\n * create conversational memory.\n *\n * You can optionally pass a list of Message types in this constructor.\n * Any messages in this State will always be added after the system and\n * user prompt.\n */\nexport const createState = <T extends StateData>(\n  initialState?: T,\n  opts?: Omit<State.Constructor<T>, \"data\">\n): State<T> => {\n  return new State({ ...opts, data: initialState });\n};\n\n/**\n * State stores state (history) for a given network of agents.  The state\n * includes a stack of all AgentResult items and strongly-typed data\n * modified via tool calls.\n *\n * From this, the chat history can be reconstructed (and manipulated) for each\n * subsequent agentic call.\n */\nexport class State<T extends StateData> {\n  public data: T;\n  public threadId?: string;\n\n  private _data: T;\n\n  /**\n   * _results stores all agent results.  This is internal and is used to\n   * track each call made in the network loop.\n   */\n  private _results: AgentResult[];\n\n  /**\n   * _messages stores a linear history of ALL messages from the current\n   * network.  You can seed this with initial messages to create conversation\n   * history.\n   */\n  private _messages: Message[];\n\n  constructor({\n    data,\n    messages,\n    threadId,\n    results,\n  }: State.Constructor<T> = {}) {\n    this._results = results || [];\n    this._messages = messages || [];\n    this._data = data ? { ...data } : ({} as T);\n    this.threadId = threadId;\n\n    // Create a new proxy that allows us to intercept the setting of state.\n    //\n    // This will be used to add middleware hooks to record state\n    // before and after setting.\n    this.data = new Proxy(this._data, {\n      set: (target, prop: string | symbol, value) => {\n        if (typeof prop === \"string\" && prop in target) {\n          // Update the property\n          Reflect.set(target, prop, value);\n          return true;\n        }\n        return Reflect.set(target, prop, value);\n      },\n    });\n\n    // NOTE: KV is deprecated and should be fully typed.\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    this.#_kv = new Map<string, any>(Object.entries(this._data));\n    this.kv = {\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      set: (key: string, value: any) => {\n        this.#_kv.set(key, value);\n      },\n      get: (key: string) => {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n        return this.#_kv.get(key);\n      },\n      delete: (key: string) => {\n        return this.#_kv.delete(key);\n      },\n      has: (key: string) => {\n        return this.#_kv.has(key);\n      },\n      all: () => {\n        return Object.fromEntries(this.#_kv);\n      },\n    };\n  }\n\n  /**\n   * Results returns a new array containing all past inference results in the\n   * network. This array is safe to modify.\n   */\n  get results(): AgentResult[] {\n    return this._results.slice();\n  }\n\n  /**\n   * Replaces all results with the provided array\n   * used when loading initial results from history.get()\n   */\n  setResults(results: AgentResult[]) {\n    this._results = results;\n  }\n\n  /**\n   * Returns a slice of results from the given start index\n   * used when saving results to a database via history.appendResults()\n   */\n  getResultsFrom(startIndex: number): AgentResult[] {\n    return this._results.slice(startIndex);\n  }\n\n  /**\n   * Messages returns a new array containing all initial messages that were\n   * provided to the constructor. This array is safe to modify.\n   */\n  get messages(): Message[] {\n    return this._messages.slice();\n  }\n\n  /**\n   * formatHistory returns the memory used for agentic calls based off of prior\n   * agentic calls.\n   *\n   * This is used to format the current State as a conversation log when\n   * calling an individual agent.\n   *\n   */\n  formatHistory(formatter?: (r: AgentResult) => Message[]): Message[] {\n    if (!formatter) {\n      formatter = defaultResultFormatter;\n    }\n\n    // Always add any messages before any AgentResult items.  This allows\n    // you to preload any\n    return this._messages.concat(\n      this._results.map((result) => formatter(result)).flat()\n    );\n  }\n\n  /**\n   * appendResult appends a given result to the current state.  This\n   * is called by the network after each iteration.\n   */\n  appendResult(call: AgentResult) {\n    this._results.push(call);\n  }\n\n  /**\n   * clone allows you to safely clone the state.\n   */\n  clone() {\n    const state = new State<T>({\n      data: this.data,\n      threadId: this.threadId,\n      messages: this._messages.slice(),\n      results: this._results.slice(),\n    });\n    return state;\n  }\n\n  /**\n   * @deprecated Fully type state instead of using the KV.\n   */\n  public kv: {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    set: <T = any>(key: string, value: T) => void;\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    get: <T = any>(key: string) => T | undefined;\n    delete: (key: string) => boolean;\n    has: (key: string) => boolean;\n    all: () => Record<string, unknown>;\n  };\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  #_kv: Map<string, any>;\n}\n\nexport namespace State {\n  export type Constructor<T extends StateData> = {\n    /**\n     * Data represents initial typed data\n     */\n    data?: T;\n\n    /**\n     * Results represents any previous AgentResult entries for\n     * conversation history and memory.\n     */\n    results?: AgentResult[];\n\n    /**\n     * Messages allows you to pas custom messages which will be appended\n     * after the system and user message to each agent.\n     */\n    messages?: Message[];\n\n    /**\n     * threadId is the unique identifier for a conversation thread.\n     */\n    threadId?: string;\n  };\n}\n\nconst defaultResultFormatter = (r: AgentResult): Message[] => {\n  return ([] as Message[]).concat(r.output).concat(r.toolCalls);\n};\n","import { type Inngest, type InngestFunction, isInngestFunction } from \"inngest\";\nimport { type AsyncContext, getAsyncCtx } from \"inngest/experimental\";\nimport { type ZodType, ZodObject } from \"zod\";\n\nexport type MaybePromise<T> = T | Promise<T>;\n\n/**\n * AnyZodType is a type alias for any Zod type.\n *\n * It specifically matches the typing used for the OpenAI JSON schema typings,\n * which do not use the standardized `z.ZodTypeAny` type.\n *\n * Not that using this type directly can break between any versions of Zod\n * (including minor and patch versions). It may be pertinent to maintain a\n * custom type which matches many versions in the future.\n */\nexport type AnyZodType = ZodType;\n\n/**\n * Given an unknown value, return a string representation of the error if it is\n * an error, otherwise return the stringified value.\n */\nexport const stringifyError = (e: unknown): string => {\n  if (e instanceof Error) {\n    return e.message;\n  }\n\n  return String(e);\n};\n\n/**\n * Attempts to retrieve the step tools from the async context.\n */\nexport const getStepTools = async (): Promise<\n  AsyncContext[\"ctx\"][\"step\"] | undefined\n> => {\n  // The shape of the experimental async context changed across versions.\n  // This is now stable, but we support both shapes here for compatibility.\n  const asyncCtx = await getAsyncCtx();\n\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-member-access\n  const ctx = asyncCtx?.ctx || (asyncCtx as any)?.execution?.ctx;\n\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-return, @typescript-eslint/no-unsafe-member-access\n  return ctx?.step;\n};\n\nexport const isInngestFn = (fn: unknown): fn is InngestFunction.Any => {\n  // Derivation of `InngestFunction` means it's definitely correct\n  if (isInngestFunction(fn)) {\n    return true;\n  }\n\n  // If it's not derived from `InngestFunction`, it could still be a function\n  // but from a different version of the library. Depending on your other deps\n  // this could be likely and multiple versions of the `inngest` package are\n  // installed at the same time. Thus, we check the generic shape here instead.\n  if (\n    typeof fn === \"object\" &&\n    fn !== null &&\n    \"createExecution\" in fn &&\n    typeof fn.createExecution === \"function\"\n  ) {\n    return true;\n  }\n\n  return false;\n};\n\nexport const getInngestFnInput = (\n  fn: InngestFunction.Any\n): AnyZodType | undefined => {\n  const runtimeSchemas = (fn[\"client\"] as Inngest.Any)[\"schemas\"]?.[\n    \"runtimeSchemas\"\n  ];\n  if (!runtimeSchemas) {\n    return;\n  }\n\n  const schemasToAttempt = new Set<string>(\n    (fn[\"opts\"] as InngestFunction.Options).triggers?.reduce((acc, trigger) => {\n      if (trigger.event) {\n        return [...acc, trigger.event];\n      }\n\n      return acc;\n    }, [] as string[]) ?? []\n  );\n\n  if (!schemasToAttempt.size) {\n    return;\n  }\n\n  let schema: AnyZodType | undefined;\n\n  for (const eventSchema of schemasToAttempt) {\n    const runtimeSchema = runtimeSchemas[eventSchema];\n\n    // We only support Zod atm\n    if (\n      typeof runtimeSchema === \"object\" &&\n      runtimeSchema !== null &&\n      \"data\" in runtimeSchema &&\n      helpers.isZodObject(runtimeSchema.data)\n    ) {\n      if (schema) {\n        schema = schema.or(runtimeSchema.data);\n      } else {\n        schema = runtimeSchema.data;\n      }\n      continue;\n    }\n\n    // TODO It could also be a regular object with inidivudal fields, so\n    // validate that too\n  }\n\n  return schema;\n};\n\nconst helpers = {\n  isZodObject: (value: unknown): value is ZodObject => {\n    return value instanceof ZodObject;\n  },\n\n  isObject: (value: unknown): value is Record<string, unknown> => {\n    return typeof value === \"object\" && value !== null && !Array.isArray(value);\n  },\n};\n","import { type AiAdapter } from \"@inngest/ai\";\nimport { randomUUID } from \"crypto\";\nimport { z } from \"zod\";\nimport { createRoutingAgent, type Agent, RoutingAgent } from \"./agent\";\nimport { createState, State, type StateData } from \"./state\";\nimport { createTool } from \"./tool\";\nimport type { AgentResult, Message, UserMessage } from \"./types\";\nimport { type MaybePromise } from \"./util\";\nimport {\n  type HistoryConfig,\n  initializeThread,\n  loadThreadFromStorage,\n  saveThreadToStorage,\n} from \"./history\";\nimport {\n  StreamingContext,\n  createStepWrapper,\n  generateId,\n  type StreamingConfig,\n} from \"./streaming\";\nimport { getStepTools } from \"./util\";\n\n/**\n * Network represents a network of agents.\n */\nexport const createNetwork = <T extends StateData>(\n  opts: Network.Constructor<T>\n) => new Network(opts);\n\n/**\n * Network represents a network of agents.\n */\nexport class Network<T extends StateData> {\n  /**\n   * The name for the system of agents\n   */\n  name: string;\n\n  description?: string;\n\n  /**\n   * agents are all publicly available agents in the netwrok\n   */\n  agents: Map<string, Agent<T>>;\n\n  /**\n   * state is the entire agent's state.\n   */\n  state: State<T>;\n\n  /**\n   * defaultModel is the default model to use with the network.  This will not\n   * override an agent's specific model if the agent already has a model defined\n   * (eg. via withModel or via its constructor).\n   */\n  defaultModel?: AiAdapter.Any;\n\n  router?: Network.Router<T>;\n\n  /**\n   * maxIter is the maximum number of times the we can call agents before ending\n   * the network's run loop.\n   */\n  maxIter: number;\n\n  // _stack is an array of strings, each representing an agent name to call.\n  protected _stack: string[];\n\n  protected _counter = 0;\n\n  // _agents stores all agents.  note that you may not include eg. the\n  // defaultRoutingAgent within the network constructor, and you may return an\n  // agent in the router that's not included.  This is okay;  we store all\n  // agents referenced in the router here.\n  protected _agents: Map<string, Agent<T>>;\n\n  /**\n   * history config for managing thread creation and persistence\n   * used to create a new thread, load initial results/history and\n   * append new results to your database\n   */\n  public history?: HistoryConfig<T>;\n\n  constructor({\n    name,\n    description,\n    agents,\n    defaultModel,\n    maxIter,\n    defaultState,\n    router,\n    defaultRouter,\n    history,\n  }: Network.Constructor<T>) {\n    this.name = name;\n    this.description = description;\n    this.agents = new Map();\n    this._agents = new Map();\n    this.defaultModel = defaultModel;\n    this.router = defaultRouter ?? router;\n    this.maxIter = maxIter || 0;\n    this._stack = [];\n    this.history = history;\n\n    if (defaultState) {\n      this.state = defaultState;\n    } else {\n      this.state = createState<T>();\n    }\n\n    for (const agent of agents) {\n      // Store all agents publicly visible.\n      this.agents.set(agent.name, agent);\n      // Store an internal map of all agents referenced.\n      this._agents.set(agent.name, agent);\n    }\n  }\n\n  async availableAgents(\n    networkRun: NetworkRun<T> = new NetworkRun(this, new State())\n  ): Promise<Agent<T>[]> {\n    const available: Agent<T>[] = [];\n    const all = Array.from(this.agents.values());\n    for (const a of all) {\n      const enabled = a?.lifecycles?.enabled;\n      if (!enabled || (await enabled({ agent: a, network: networkRun }))) {\n        available.push(a);\n      }\n    }\n    return available;\n  }\n\n  /**\n   * addAgent adds a new agent to the network.\n   */\n  addAgent(agent: Agent<T>) {\n    this.agents.set(agent.name, agent);\n  }\n\n  /**\n   * run handles a given request using the network of agents.  It is not\n   * concurrency-safe; you can only call run on a network once, as networks are\n   * stateful.\n   *\n   */\n  public run(\n    ...[input, overrides]: Network.RunArgs<T>\n  ): Promise<NetworkRun<T>> {\n    // Automatically normalize a string clientTimestamp to a Date object.\n    if (\n      typeof input === \"object\" &&\n      typeof input.clientTimestamp === \"string\"\n    ) {\n      input.clientTimestamp = new Date(input.clientTimestamp);\n    }\n\n    let state: State<T>;\n    if (overrides?.state) {\n      if (overrides.state instanceof State) {\n        state = overrides.state;\n      } else {\n        const stateObj = overrides.state as {\n          data?: T;\n          _messages?: Message[];\n          _results?: AgentResult[];\n        };\n        state = new State<T>({\n          data: stateObj.data || ({} as T),\n          messages: stateObj._messages || [],\n          results: stateObj._results || [],\n        });\n      }\n    } else {\n      state = this.state?.clone() || new State<T>();\n    }\n\n    return new NetworkRun(this, state)[\"execute\"](input, overrides);\n  }\n}\n\n/**\n * defaultRoutingAgent is an AI agent that selects the appropriate agent from\n * the network to handle the incoming request.\n *\n * It is no set model and so relies on the presence of a default model in the\n * network or being explicitly given one.\n */\nlet defaultRoutingAgent: RoutingAgent<any> | undefined; // eslint-disable-line @typescript-eslint/no-explicit-any\n\nexport const getDefaultRoutingAgent = () => {\n  defaultRoutingAgent ??= createRoutingAgent({\n    name: \"Default routing agent\",\n\n    description:\n      \"Selects which agents to work on based off of the current prompt and input.\",\n\n    lifecycle: {\n      onRoute: ({ result }) => {\n        const tool = result.toolCalls[0];\n        if (!tool) {\n          return;\n        }\n\n        // Check if the done tool was called\n        if (tool.tool.name === \"done\") {\n          return undefined; // Signal to exit the agent loop\n        }\n\n        // Check if select_agent was called\n        if (tool.tool.name === \"select_agent\") {\n          if (\n            typeof tool.content === \"object\" &&\n            tool.content !== null &&\n            \"data\" in tool.content &&\n            typeof tool.content.data === \"string\"\n          ) {\n            return [tool.content.data];\n          }\n        }\n\n        return;\n      },\n    },\n\n    tools: [\n      createTool({\n        name: \"select_agent\",\n        description:\n          \"Select an agent to handle the next step of the conversation\",\n        parameters: z\n          .object({\n            name: z\n              .string()\n              .describe(\"The name of the agent that should handle the request\"),\n            reason: z\n              .string()\n              .optional()\n              .describe(\"Brief explanation of why this agent was chosen\"),\n          })\n          .strict(),\n        handler: ({ name }, { network }) => {\n          if (typeof name !== \"string\") {\n            throw new Error(\"The routing agent requested an invalid agent\");\n          }\n\n          const agent = network.agents.get(name);\n          if (agent === undefined) {\n            throw new Error(\n              `The routing agent requested an agent that doesn't exist: ${name}`\n            );\n          }\n\n          // This returns the agent name to call.  The default routing functon\n          // schedules this agent by inpsecting this name via the tool call output.\n          return agent.name;\n        },\n      }),\n\n      createTool({\n        name: \"done\",\n        description:\n          \"Signal that the conversation is complete and no more agents need to be called\",\n        parameters: z\n          .object({\n            summary: z\n              .string()\n              .optional()\n              .describe(\"Brief summary of what was accomplished\"),\n          })\n          .strict(),\n        handler: ({ summary }) => {\n          // Return a completion message\n          return summary || \"Conversation completed successfully\";\n        },\n      }),\n    ],\n\n    tool_choice: \"any\", // Allow the model to choose between select_agent or done\n\n    system: async ({ network }): Promise<string> => {\n      if (!network) {\n        throw new Error(\n          \"The routing agent can only be used within a network of agents\"\n        );\n      }\n\n      const agents = await network?.availableAgents();\n\n      return `You are the orchestrator between a group of agents. Each agent is suited for specific tasks and has a name, description, and tools.\n\nThe following agents are available:\n<agents>\n  ${agents\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    .map((a: Agent<any>) => {\n      return `\n    <agent>\n      <name>${a.name}</name>\n      <description>${a.description}</description>\n      <tools>${JSON.stringify(Array.from(a.tools.values()))}</tools>\n    </agent>`;\n    })\n    .join(\"\\n\")}\n</agents>\n\nYour responsibilities:\n1. Analyze the conversation history and current state\n2. Determine if the request has been completed or if more work is needed\n3. Either:\n   - Call select_agent to route to the appropriate agent for the next step\n   - Call done if the conversation is complete or the user's request has been fulfilled\n\n<instructions>\n  - If the user's request has been addressed and no further action is needed, call the done tool\n  - If more work is needed, select the most appropriate agent based on their capabilities\n  - Consider the context and history when making routing decisions\n  - Be efficient - don't route to agents unnecessarily if the task is complete\n</instructions>`;\n    },\n  });\n\n  return defaultRoutingAgent;\n};\n\nexport namespace Network {\n  export type Constructor<T extends StateData> = {\n    name: string;\n    description?: string;\n    agents: Agent<T>[];\n    defaultModel?: AiAdapter.Any;\n    maxIter?: number;\n    // state is any pre-existing network state to use in this Network instance.  By\n    // default, new state is created without any history for every Network.\n    defaultState?: State<T>;\n    router?: Router<T>;\n    defaultRouter?: Router<T>;\n    history?: HistoryConfig<T>;\n  };\n\n  export type RunArgs<T extends StateData> = [\n    input: UserMessage | string,\n    overrides?: {\n      router?: Router<T>;\n      defaultRouter?: Router<T>;\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      state?: State<T> | Record<string, any>;\n      streaming?: StreamingConfig;\n    },\n  ];\n\n  /**\n   * Router defines how a network coordinates between many agents.  A router is\n   * either a RoutingAgent which uses inference calls to choose the next Agent,\n   * or a function which chooses the next Agent to call.\n   *\n   * The function gets given the network, current state, future\n   * agentic calls, and the last inference result from the network.\n   *\n   */\n  export type Router<T extends StateData> =\n    | RoutingAgent<T>\n    | Router.FnRouter<T>;\n\n  export namespace Router {\n    /**\n     * FnRouter defines a function router which returns an Agent, an AgentRouter, or\n     * undefined if the network should stop.\n     *\n     * If the FnRouter returns an AgentRouter (an agent with the .route function),\n     * the agent will first be ran, then the `.route` function will be called.\n     *\n     */\n    export type FnRouter<T extends StateData> = (\n      args: Args<T>\n    ) => MaybePromise<RoutingAgent<T> | Agent<T> | Agent<T>[] | undefined>;\n\n    export interface Args<T extends StateData> {\n      /**\n       * input is the input called to the network (always the string content for backwards compatibility)\n       */\n      input: string;\n\n      /**\n       * userMessage is the rich UserMessage object if provided (new in Phase 1)\n       * Contains client state, timestamps, and optional system prompts\n       */\n      userMessage?: UserMessage;\n\n      /**\n       * Network is the network that this router is coordinating.  Network state\n       * is accessible via `network.state`.\n       */\n      network: NetworkRun<T>;\n\n      /**\n       * stack is an ordered array of agents that will be called next.\n       */\n      stack: Agent<T>[];\n\n      /**\n       * callCount is the number of current agent invocations that the network\n       * has made.  This is a shorthand for `network.state.results.length`.\n       */\n      callCount: number;\n\n      /**\n       * lastResult is the last inference result that the network made.  This is\n       * a shorthand for `network.state.results.pop()`.\n       */\n      lastResult?: AgentResult;\n    }\n  }\n}\n\nexport class NetworkRun<T extends StateData> extends Network<T> {\n  constructor(network: Network<T>, state: State<T>) {\n    super({\n      name: network.name,\n      description: network.description,\n      agents: Array.from(network.agents.values()),\n      defaultModel: network.defaultModel,\n      defaultState: network.state,\n      router: network.router,\n      maxIter: network.maxIter,\n      history: network.history,\n    });\n\n    this.state = state;\n  }\n\n  public override run(): never {\n    throw new Error(\"NetworkRun does not support run\");\n  }\n\n  public override async availableAgents(): Promise<Agent<T>[]> {\n    return super.availableAgents(this);\n  }\n\n  /**\n   * Schedule is used to push an agent's run function onto the stack.\n   */\n  schedule(agentName: string) {\n    this[\"_stack\"].push(agentName);\n  }\n\n  private async execute(\n    ...[input, overrides]: Network.RunArgs<T>\n  ): Promise<this> {\n    // Generate network run ID inside Inngest steps to ensure deterministic replay behavior\n    const stepTools = await getStepTools();\n    let networkRunId: string;\n\n    if (stepTools) {\n      // Use Inngest steps for deterministic ID generation\n      networkRunId = await stepTools.run(\"generate-network-id\", () => {\n        return randomUUID();\n      });\n    } else {\n      // Fallback for non-Inngest contexts\n      networkRunId = randomUUID();\n    }\n\n    const streamingPublish = overrides?.streaming?.publish;\n    let streamingContext: StreamingContext | undefined;\n\n    // If history.get is configured AND the state is empty, use it to load initial history\n    // When passing passing in messages from the client, history.get() is disabled - allowing the client to maintain conversation state and send it with each request\n    // Enables a client-authoritative pattern where the UI maintains conversation state and sends it with each request. Allows `history.get()` to serve as a fallback for new threads or recovery\n\n    // Extract string content for history functions that expect string input\n    const inputContent =\n      typeof input === \"object\" && input !== null && \"content\" in input\n        ? input.content\n        : input;\n\n    // Initialize conversation thread: Creates a new thread or auto-generates if needed\n    // Capture whether the client provided a threadId BEFORE initialization. If absent, this\n    // implies a brand-new thread and we can skip the initial history load (no-op DB read).\n    const hadClientThreadId = Boolean(this.state.threadId);\n    await initializeThread({\n      state: this.state,\n      history: this.history,\n      input: inputContent,\n      network: this,\n    });\n\n    // Persist the user's message at the beginning of the run for resilience\n    if (this.history?.appendUserMessage) {\n      let userMessage: {\n        id: string;\n        content: string;\n        role: \"user\";\n        timestamp: Date;\n      };\n\n      if (typeof input === \"object\" && input !== null && \"id\" in input) {\n        // Input is a UserMessage object - extract data from it\n        const userInput = input;\n\n        // Ensure clientTimestamp is a Date object before assignment\n        const timestamp =\n          userInput.clientTimestamp instanceof Date\n            ? userInput.clientTimestamp\n            : userInput.clientTimestamp\n              ? new Date(userInput.clientTimestamp)\n              : new Date();\n\n        userMessage = {\n          id: userInput.id,\n          content: userInput.content,\n          role: \"user\",\n          timestamp,\n        };\n      } else {\n        // Input is a string - generate a new ID\n        userMessage = {\n          id: randomUUID(),\n          content: input,\n          role: \"user\",\n          timestamp: new Date(),\n        };\n      }\n\n      await this.history.appendUserMessage({\n        state: this.state,\n        network: this,\n        input: inputContent,\n        threadId: this.state.threadId,\n        userMessage,\n        step: stepTools || undefined,\n      });\n    }\n\n    // Load existing conversation history from storage only when the client provided a threadId.\n    // If the threadId was omitted (new thread created this run), skip the initial get().\n    if (hadClientThreadId) {\n      await loadThreadFromStorage({\n        state: this.state,\n        history: this.history,\n        input: inputContent,\n        network: this,\n      });\n    }\n\n    // Prepare streaming context after thread initialization\n    if (streamingPublish) {\n      streamingContext = StreamingContext.fromNetworkState(this.state, {\n        publish: streamingPublish,\n        runId: networkRunId,\n        messageId: networkRunId, // Use networkRunId as messageId for network-level events\n        scope: \"network\",\n        simulateChunking: overrides?.streaming?.simulateChunking,\n      });\n      await streamingContext.publishEvent({\n        event: \"run.started\",\n        data: {\n          runId: networkRunId,\n          scope: \"network\",\n          name: this.name,\n          messageId: networkRunId, // Network events use networkRunId as messageId\n          threadId: this.state.threadId,\n        },\n      });\n    }\n\n    // Wrap step tools for automatic step lifecycle events\n    const step = await getStepTools();\n    const wrappedStep = createStepWrapper(step, streamingContext);\n\n    const available = await this.availableAgents();\n    if (available.length === 0) {\n      throw new Error(\"no agents enabled in network\");\n    }\n\n    // Store initial result count to track new results\n    // Used to track new results in history.appendResults\n    const initialResultCount = this.state.results.length;\n\n    try {\n      // If there's no default agent used to run the request, use our internal\n      // routing agent which attempts to figure out the best agent to choose based\n      // off of the network.\n      const next = await this.getNextAgents(\n        input, // Pass full UserMessage object, not extracted content\n        overrides?.router || overrides?.defaultRouter || this.router\n      );\n      if (!next?.length) {\n        // TODO: If call count is 0, error.\n        return this;\n      }\n\n      // Schedule the agent to run on our stack, then start popping off the stack.\n      for (const agent of next) {\n        this.schedule(agent.name);\n      }\n\n      while (\n        this._stack.length > 0 &&\n        (this.maxIter === 0 || this._counter < this.maxIter)\n      ) {\n        // XXX: It would be possible to parallel call these agents here by\n        // fetching the entire stack, parallel running, then awaiting the\n        // responses.   However, this confuses history and we'll take our time to\n        // introduce parallelisation after the foundations are set.\n\n        // Fetch the agent we need to call next off of the stack.\n        const agentName = this._stack.shift();\n\n        // Grab agents from the private map, as this may have been introduced in\n        // the router.\n        const agent = agentName && this._agents.get(agentName);\n        if (!agent) {\n          // We're done.\n          // Emit run.completed and stream.ended if streaming\n          if (streamingContext) {\n            await streamingContext.publishEvent({\n              event: \"run.completed\",\n              data: {\n                runId: networkRunId,\n                scope: \"network\",\n                name: this.name,\n                messageId: networkRunId, // Use networkRunId for network completion\n              },\n            });\n            await streamingContext.publishEvent({\n              event: \"stream.ended\",\n              data: {\n                scope: \"network\",\n                messageId: networkRunId,\n              },\n            });\n          }\n          return this;\n        }\n\n        // We force Agent to emit structured output in case of the use of tools by\n        // setting maxIter to 0.\n        // Generate unique IDs for this agent's execution using durable steps\n        let agentRunId: string;\n        let agentMessageId: string;\n\n        if (stepTools) {\n          // Use Inngest steps for deterministic agent ID generation\n          const agentIds = await stepTools.run(\n            `generate-agent-ids-${this._counter}`,\n            () => {\n              return {\n                agentRunId: generateId(),\n                agentMessageId: randomUUID(),\n              };\n            }\n          );\n          agentRunId = agentIds.agentRunId;\n          agentMessageId = agentIds.agentMessageId;\n        } else {\n          // Fallback for non-Inngest contexts\n          agentRunId = generateId();\n          agentMessageId = randomUUID();\n        }\n\n        // Create agent streaming context that shares the sequence counter\n        let agentStreamingContext: StreamingContext | undefined;\n        if (streamingContext) {\n          // Create context with shared sequence counter but agent-specific messageId\n          agentStreamingContext =\n            streamingContext.createContextWithSharedSequence({\n              runId: agentRunId,\n              messageId: agentMessageId,\n              scope: \"agent\",\n            });\n\n          await streamingContext.publishEvent({\n            event: \"run.started\",\n            data: {\n              runId: agentRunId,\n              parentRunId: networkRunId,\n              scope: \"agent\",\n              name: agent.name,\n              messageId: agentMessageId, // Use agent-specific messageId\n            },\n          });\n        }\n\n        const call = await agent.run(inputContent, {\n          network: this,\n          maxIter: 0,\n          // Provide streaming context so the agent can emit part/text/tool events\n          streamingContext: agentStreamingContext,\n          // Provide wrapped step tools for automatic step lifecycle events\n          step: wrappedStep,\n        });\n\n        // CRITICAL FIX: Set the canonical message ID on the AgentResult\n        // This ensures the streaming agentMessageId becomes the persisted message_id\n        call.id = agentMessageId;\n\n        if (agentStreamingContext) {\n          await agentStreamingContext.publishEvent({\n            event: \"run.completed\",\n            data: {\n              runId: agentRunId,\n              scope: \"agent\",\n              name: agent.name,\n              messageId: agentMessageId, // Include agent-specific messageId in completion event\n            },\n          });\n        }\n        this._counter += 1;\n\n        // Ensure that we store the call network history.\n        this.state.appendResult(call);\n\n        // Here we face a problem: what's the definition of done?   An agent may\n        // have just been called with part of the information to solve an input.\n        // We may need to delegate to another agent.\n        //\n        // In this case, we defer to the router provided to give us next steps.\n        // By default, this is an agentic router which takes the current state,\n        // agents, then figures out next steps.  This can, and often should, be\n        // custom code.\n        const next = await this.getNextAgents(\n          input, // Pass full UserMessage object, not extracted content\n          overrides?.router || overrides?.defaultRouter || this.router\n        );\n\n        for (const a of next || []) {\n          this.schedule(a.name);\n        }\n      }\n\n      // Save new network results to storage: Persists all new AgentResults generated\n      // during this network run (from all agents that executed). Only saves the new\n      // results, excluding any historical results that were loaded at the start.\n      await saveThreadToStorage({\n        state: this.state,\n        history: this.history,\n        input: inputContent,\n        initialResultCount,\n        network: this,\n      });\n    } catch (error) {\n      // Emit error events for network streaming\n      if (streamingContext) {\n        try {\n          await streamingContext.publishEvent({\n            event: \"run.failed\",\n            data: {\n              runId: networkRunId,\n              scope: \"network\",\n              name: this.name,\n              messageId: networkRunId, // Use networkRunId for network error events\n              error: error instanceof Error ? error.message : String(error),\n              recoverable: false,\n            },\n          });\n        } catch (streamingError) {\n          // Swallow streaming errors to prevent masking the original error\n          console.warn(\"Failed to publish run.failed event:\", streamingError);\n        }\n      }\n      // Re-throw the original error\n      throw error;\n    } finally {\n      // Always emit completion events for network streaming\n      if (streamingContext) {\n        try {\n          await streamingContext.publishEvent({\n            event: \"run.completed\",\n            data: {\n              runId: networkRunId,\n              scope: \"network\",\n              name: this.name,\n              messageId: networkRunId, // Use networkRunId for network completion in finally block\n            },\n          });\n          await streamingContext.publishEvent({\n            event: \"stream.ended\",\n            data: {\n              scope: \"network\",\n              messageId: networkRunId,\n            },\n          });\n        } catch (streamingError) {\n          // Swallow streaming errors to prevent breaking the application\n          console.warn(\"Failed to publish completion events:\", streamingError);\n        }\n      }\n    }\n\n    return this;\n  }\n\n  private async getNextAgents(\n    input: UserMessage | string,\n    router?: Network.Router<T>\n  ): Promise<Agent<T>[] | undefined> {\n    // A router may do one of two things:\n    //\n    //   1. Return one or more Agents to run\n    //   2. Return undefined, meaning we're done.\n    //\n    // It can do this by using code, or by calling routing agents directly.\n    if (!router && !this.defaultModel) {\n      throw new Error(\n        \"No router or model defined in network.  You must pass a router or a default model to use the built-in agentic router.\"\n      );\n    }\n    if (!router) {\n      router = getDefaultRoutingAgent();\n    }\n    if (router instanceof RoutingAgent) {\n      // RoutingAgents expect string input, so extract content from UserMessage\n      const inputContent =\n        typeof input === \"object\" && input !== null && \"content\" in input\n          ? input.content\n          : input;\n      return await this.getNextAgentsViaRoutingAgent(router, inputContent);\n    }\n\n    // This is a function call which determines the next agent to call.  Note that the result\n    // of this function call may be another RoutingAgent.\n    const stack: Agent<T>[] = this._stack.map((name) => {\n      const agent = this._agents.get(name);\n      if (!agent) {\n        throw new Error(`unknown agent in the network stack: ${name}`);\n      }\n      return agent;\n    });\n\n    // Extract string content for router (routers always receive string for backwards compatibility)\n    const routerInputContent =\n      typeof input === \"object\" && input !== null && \"content\" in input\n        ? input.content\n        : input;\n\n    const agent = await router({\n      input: routerInputContent, // Always pass string content for backwards compatibility\n      userMessage:\n        typeof input === \"object\" && input !== null && \"content\" in input\n          ? input\n          : undefined,\n      network: this,\n      stack,\n      lastResult: this.state.results[this.state.results.length - 1],\n      callCount: this._counter,\n    });\n\n    if (!agent) {\n      return;\n    }\n    if (agent instanceof RoutingAgent) {\n      // Functions may also return routing agents - extract content for RoutingAgent\n      const inputContent =\n        typeof input === \"object\" && input !== null && \"content\" in input\n          ? input.content\n          : input;\n      return await this.getNextAgentsViaRoutingAgent(agent, inputContent);\n    }\n\n    for (const a of Array.isArray(agent) ? agent : [agent]) {\n      // Ensure this agent is part of the network.  If not, we're going to\n      // automatically add it.\n      if (!this._agents.has(a.name)) {\n        this._agents.set(a.name, a);\n      }\n    }\n\n    return Array.isArray(agent) ? agent : [agent];\n  }\n\n  private async getNextAgentsViaRoutingAgent(\n    routingAgent: RoutingAgent<T>,\n    input: string\n  ): Promise<Agent<T>[] | undefined> {\n    const result = await routingAgent.run(input, {\n      network: this,\n      model: routingAgent.model || this.defaultModel,\n    });\n\n    const agentNames = routingAgent.lifecycles.onRoute({\n      result,\n      agent: routingAgent,\n      network: this,\n    });\n\n    return (agentNames || [])\n      .map((name) => this.agents.get(name))\n      .filter(Boolean) as Agent<T>[];\n  }\n}\n","import type { JSONSchema } from \"@dmitryrechkin/json-schema-to-zod\";\nimport { type AiAdapter } from \"@inngest/ai\";\nimport { Client as MCPClient } from \"@modelcontextprotocol/sdk/client/index.js\";\nimport { StreamableHTTPClientTransport } from \"@modelcontextprotocol/sdk/client/streamableHttp.js\";\nimport { SSEClientTransport } from \"@modelcontextprotocol/sdk/client/sse.js\";\nimport { WebSocketClientTransport } from \"@modelcontextprotocol/sdk/client/websocket.js\";\nimport { StdioClientTransport } from \"@modelcontextprotocol/sdk/client/stdio.js\";\nimport { type Transport } from \"@modelcontextprotocol/sdk/shared/transport.js\";\nimport { ListToolsResultSchema } from \"@modelcontextprotocol/sdk/types.js\";\nimport { EventSource } from \"eventsource\";\nimport { randomUUID } from \"crypto\";\nimport { referenceFunction, type Inngest, type GetStepTools } from \"inngest\";\nimport { errors } from \"inngest/internals\";\nimport { type InngestFunction } from \"inngest\";\nimport { type MinimalEventPayload } from \"inngest/types\";\nimport type { ZodType } from \"zod\";\nimport { createAgenticModelFromAiAdapter, type AgenticModel } from \"./model\";\nimport { createNetwork, NetworkRun } from \"./network\";\nimport { State, type StateData } from \"./state\";\nimport { type MCP, type Tool } from \"./tool\";\nimport {\n  AgentResult,\n  type Message,\n  type ToolResultMessage,\n  type UserMessage,\n} from \"./types\";\nimport {\n  getInngestFnInput,\n  getStepTools,\n  isInngestFn,\n  type MaybePromise,\n} from \"./util\";\nimport {\n  type HistoryConfig,\n  initializeThread,\n  loadThreadFromStorage,\n  saveThreadToStorage,\n} from \"./history\";\n// Streaming integration will be handled at the network level for now\nimport {\n  StreamingContext,\n  createStepWrapper,\n  generateId,\n  type StreamingConfig,\n} from \"./streaming\";\n\n/**\n * Agent represents a single agent, responsible for a set of tasks.\n */\nexport const createAgent = <T extends StateData>(opts: Agent.Constructor<T>) =>\n  new Agent(opts);\n\nexport const createRoutingAgent = <T extends StateData>(\n  opts: Agent.RoutingConstructor<T>\n) => new RoutingAgent(opts);\n\n/**\n * Agent represents a single agent, responsible for a set of tasks.\n */\nexport class Agent<T extends StateData> {\n  /**\n   * name is the name of the agent.\n   */\n  name: string;\n\n  /**\n   * description is the description of the agent.\n   */\n  description: string;\n\n  /**\n   * system is the system prompt for the agent.\n   */\n  system: string | ((ctx: { network?: NetworkRun<T> }) => MaybePromise<string>);\n\n  /**\n   * Assistant is the assistent message used for completion, if any.\n   */\n  assistant: string;\n\n  /**\n   * tools are a list of tools that this specific agent has access to.\n   */\n  tools: Map<string, Tool.Any>;\n\n  /**\n   * tool_choice allows you to specify whether tools are automatically.  this defaults\n   * to \"auto\", allowing the model to detect when to call tools automatically.  Choices are:\n   *\n   * - \"auto\": allow the model to choose tools automatically\n   * - \"any\": force the use of any tool in the tools map\n   * - string: force the name of a particular tool\n   */\n  tool_choice?: Tool.Choice;\n\n  /**\n   * lifecycles are programmatic hooks used to manage the agent.\n   */\n  lifecycles: Agent.Lifecycle<T> | Agent.RoutingLifecycle<T> | undefined;\n\n  /**\n   * model is the step caller to use for this agent.  This allows the agent\n   * to use a specific model which may be different to other agents in the\n   * system\n   */\n  model: AiAdapter.Any | undefined;\n\n  /**\n   * mcpServers is a list of MCP (model-context-protocol) servers which can\n   * provide tools to the agent.\n   */\n  mcpServers?: MCP.Server[];\n\n  /**\n   * history configuration for managing conversation history\n   */\n  private history?: HistoryConfig<T>;\n\n  // _mcpInit records whether the MCP tool list has been initialized.\n  private _mcpClients: MCPClient[];\n\n  constructor(opts: Agent.Constructor<T> | Agent.RoutingConstructor<T>) {\n    this.name = opts.name;\n    this.description = opts.description || \"\";\n    this.system = opts.system;\n    this.assistant = opts.assistant || \"\";\n    this.tools = new Map();\n    this.tool_choice = opts.tool_choice;\n    this.lifecycles = opts.lifecycle;\n    this.model = opts.model;\n    this.history = opts.history;\n    this.setTools(opts.tools);\n    this.mcpServers = opts.mcpServers;\n    this._mcpClients = [];\n  }\n\n  private setTools(tools: Agent.Constructor<T>[\"tools\"]): void {\n    for (const tool of tools || []) {\n      if (isInngestFn(tool)) {\n        this.tools.set(tool[\"absoluteId\"], {\n          name: tool[\"absoluteId\"],\n          description: tool.description,\n          // TODO Should we error here if we can't find an input schema?\n          parameters: getInngestFnInput(tool),\n          handler: async (input: MinimalEventPayload[\"data\"], opts) => {\n            // Doing this late means a potential throw if we use the agent in a\n            // non-Inngest environment. We could instead calculate the tool list\n            // JIT and omit any Inngest tools if we're not in an Inngest\n            // context.\n            const step = await getStepTools();\n            if (!step) {\n              throw new Error(\"Inngest tool called outside of Inngest context\");\n            }\n\n            const stepId = `${opts.agent.name}/tools/${tool[\"absoluteId\"]}`;\n\n            return step.invoke(stepId, {\n              function: referenceFunction({\n                appId: (tool[\"client\"] as Inngest.Any)[\"id\"],\n                functionId: tool.id(),\n              }),\n              data: input,\n            });\n          },\n        });\n      } else {\n        this.tools.set(tool.name, tool);\n      }\n    }\n  }\n\n  withModel(model: AiAdapter.Any): Agent<T> {\n    return new Agent({\n      name: this.name,\n      description: this.description,\n      system: this.system,\n      assistant: this.assistant,\n      tools: Array.from(this.tools.values()),\n      lifecycle: this.lifecycles,\n      model,\n    });\n  }\n\n  /**\n   * Run runs an agent with the given user input, treated as a user message.  If\n   * the input is an empty string, only the system prompt will execute.\n   */\n  async run(\n    input: UserMessage | string,\n    {\n      model,\n      network,\n      state,\n      maxIter = 0,\n      streaming,\n      streamingContext,\n      step,\n    }: Agent.RunOptions<T> | undefined = {}\n  ): Promise<AgentResult> {\n    // Attempt to resolve the MCP tools, if we haven't yet done so.\n    await this.initMCP();\n\n    const rawModel = model || this.model || network?.defaultModel;\n    if (!rawModel) {\n      throw new Error(\"No model provided to agent\");\n    }\n\n    const p = createAgenticModelFromAiAdapter(rawModel);\n\n    // input state always overrides the network state.\n    const s = state || network?.state || new State();\n    const run = new NetworkRun(\n      network || createNetwork<T>({ name: \"default\", agents: [] }),\n      s\n    );\n\n    // Handle standalone agent streaming (ignored if part of a network)\n    let standaloneStreamingContext: StreamingContext | undefined;\n    let standaloneWrappedStep: GetStepTools<Inngest.Any> | undefined;\n    if (!network && streaming?.publish) {\n      // Generate IDs for this standalone agent run using Inngest steps for deterministic replay\n      const stepTools = await getStepTools();\n      let agentRunId: string;\n      let messageId: string;\n\n      if (stepTools) {\n        // Use Inngest steps for deterministic ID generation\n        const ids = await stepTools.run(\"generate-standalone-agent-ids\", () => {\n          return {\n            agentRunId: generateId(),\n            messageId: randomUUID(),\n          };\n        });\n        agentRunId = ids.agentRunId;\n        messageId = ids.messageId;\n      } else {\n        // Fallback for non-Inngest contexts\n        agentRunId = generateId();\n        messageId = randomUUID();\n      }\n\n      // Create streaming context for this standalone agent\n      standaloneStreamingContext = StreamingContext.fromNetworkState(s, {\n        publish: streaming.publish,\n        runId: agentRunId,\n        messageId,\n        scope: \"agent\",\n        simulateChunking: streaming.simulateChunking,\n      });\n\n      // Create wrapped step for standalone agent streaming\n      standaloneWrappedStep = createStepWrapper(\n        stepTools,\n        standaloneStreamingContext\n      );\n\n      // Emit agent run.started event\n      await standaloneStreamingContext.publishEvent({\n        event: \"run.started\",\n        data: {\n          runId: agentRunId,\n          scope: \"agent\",\n          name: this.name,\n          messageId,\n          threadId: s.threadId,\n        },\n      });\n    }\n\n    // Use standalone streaming context if available, otherwise use network-provided context\n    const effectiveStreamingContext =\n      streamingContext || standaloneStreamingContext;\n    // Use standalone wrapped step if available, otherwise use network-provided step\n    const effectiveStep: GetStepTools<Inngest.Any> | undefined =\n      step || standaloneWrappedStep;\n\n    // Note: Streaming is controlled at the network level when part of a network.\n    // For standalone agents, streaming is controlled by the streaming parameter.\n\n    // Extract string content for history functions that expect string input\n    const inputContent =\n      typeof input === \"object\" && input !== null && \"content\" in input\n        ? input.content\n        : input;\n\n    // Initialize conversation thread: Creates a new thread or auto-generates if needed\n    await initializeThread({\n      state: s,\n      history: this.history,\n      input: inputContent,\n      network: run,\n    });\n\n    // Load existing conversation history from storage: If threadId exists and history.get() is configured\n    await loadThreadFromStorage({\n      state: s,\n      history: this.history,\n      input: inputContent,\n      network: run,\n    });\n\n    // Get formatted history and initial prompt\n    let history = s ? s.formatHistory() : [];\n    let prompt = await this.agentPrompt(input, run);\n    let result = new AgentResult(\n      this.name,\n      [],\n      [],\n      new Date(),\n      prompt,\n      history,\n      \"\"\n    );\n    let hasMoreActions = true;\n    let iter = 0;\n\n    // Store initial result count to track new results\n    const initialResultCount = s.results.length;\n\n    try {\n      do {\n        // Call lifecycles each time we perform inference.\n        if (this.lifecycles?.onStart) {\n          const modified = await this.lifecycles.onStart({\n            agent: this,\n            network: run,\n            input: inputContent,\n            prompt,\n            history,\n          });\n\n          if (modified.stop) {\n            // We allow users to prevent calling the LLM directly here.\n            return result;\n          }\n\n          prompt = modified.prompt;\n          history = modified.history;\n        }\n\n        const inference = await this.performInference(\n          p,\n          prompt,\n          history,\n          run,\n          effectiveStreamingContext,\n          effectiveStep\n        );\n\n        hasMoreActions = Boolean(\n          this.tools.size > 0 &&\n            inference.output.length &&\n            inference.output[inference.output.length - 1]!.stop_reason !==\n              \"stop\"\n        );\n\n        result = inference;\n        // Set the canonical message ID from streaming context for standalone agents\n        if (standaloneStreamingContext) {\n          result.id = standaloneStreamingContext.messageId;\n        }\n        history = [...inference.output];\n        iter++;\n      } while (hasMoreActions && iter < maxIter);\n\n      if (this.lifecycles?.onFinish) {\n        result = await this.lifecycles.onFinish({\n          agent: this,\n          network: run,\n          result,\n        });\n      }\n\n      // Note that the routing lifecycles aren't called by the agent.  They're called\n      // by the network.\n\n      // Save new conversation results to storage: Persists only the new AgentResults\n      // generated during this run (excluding any historical results that were loaded).\n      // This allows the conversation to be continued in future runs with full context.\n      await saveThreadToStorage({\n        state: s,\n        history: this.history,\n        input: inputContent,\n        initialResultCount,\n        network: run,\n      });\n    } catch (error) {\n      // Emit error events for standalone agent streaming\n      if (standaloneStreamingContext) {\n        try {\n          await standaloneStreamingContext.publishEvent({\n            event: \"run.failed\",\n            data: {\n              runId: standaloneStreamingContext.runId,\n              scope: \"agent\",\n              name: this.name,\n              error: error instanceof Error ? error.message : String(error),\n              recoverable: false,\n            },\n          });\n        } catch (streamingError) {\n          // Swallow streaming errors to prevent masking the original error\n          console.warn(\"Failed to publish run.failed event:\", streamingError);\n        }\n      }\n      // Re-throw the original error\n      throw error;\n    } finally {\n      // Always emit completion events for standalone agent streaming\n      if (standaloneStreamingContext) {\n        try {\n          await standaloneStreamingContext.publishEvent({\n            event: \"run.completed\",\n            data: {\n              runId: standaloneStreamingContext.runId,\n              scope: \"agent\",\n              name: this.name,\n            },\n          });\n          await standaloneStreamingContext.publishEvent({\n            event: \"stream.ended\",\n            data: {\n              scope: \"agent\",\n              messageId: standaloneStreamingContext.messageId,\n            },\n          });\n        } catch (streamingError) {\n          // Swallow streaming errors to prevent breaking the application\n          console.warn(\"Failed to publish completion events:\", streamingError);\n        }\n      }\n    }\n\n    return result;\n  }\n\n  private async performInference(\n    p: AgenticModel.Any,\n    prompt: Message[],\n    history: Message[],\n    network: NetworkRun<T>,\n    streamingContext?: StreamingContext,\n    step?: GetStepTools<Inngest.Any>\n  ): Promise<AgentResult> {\n    const { output, raw } = await p.infer(\n      this.name,\n      prompt.concat(history),\n      Array.from(this.tools.values()),\n      this.tool_choice || \"auto\"\n    );\n\n    // Now that we've made the call, we instantiate a new AgentResult for\n    // lifecycles and history.\n    let result = new AgentResult(\n      this.name,\n      output,\n      [],\n      new Date(),\n      prompt,\n      history,\n      typeof raw === \"string\" ? raw : JSON.stringify(raw)\n    );\n    if (this.lifecycles?.onResponse) {\n      result = await this.lifecycles.onResponse({\n        agent: this,\n        network,\n        result,\n      });\n    }\n\n    // Fallback streaming of assistant text if streaming context exists\n    if (streamingContext) {\n      // Find the last assistant text message\n      const lastTextMsg = [...result.output]\n        .reverse()\n        .find((m) => m.type === \"text\" && m.role === \"assistant\");\n      let content = \"\";\n      if (lastTextMsg && lastTextMsg.type === \"text\") {\n        const anyMsg = lastTextMsg as unknown as {\n          content: string | Array<{ type: \"text\"; text: string }>;\n        };\n        if (typeof anyMsg.content === \"string\") {\n          content = anyMsg.content;\n        } else if (Array.isArray(anyMsg.content)) {\n          content = anyMsg.content.map((c) => c.text).join(\"\");\n        }\n      }\n\n      if (content && content.length > 0) {\n        // Generate partId deterministically within a step to avoid replay issues\n        const stepTools = step || (await getStepTools());\n        const partId = stepTools\n          ? await stepTools.run(\n              `generate-text-part-id-${streamingContext.messageId}`,\n              () => {\n                return streamingContext.generatePartId();\n              }\n            )\n          : streamingContext.generatePartId();\n\n        await streamingContext.publishEvent({\n          event: \"part.created\",\n          data: {\n            partId,\n            runId: streamingContext.runId,\n            messageId: streamingContext.messageId,\n            type: \"text\",\n            metadata: { agentName: this.name },\n          },\n        });\n\n        if (streamingContext.isSimulatedChunking()) {\n          const chunkSize = 50;\n          for (let i = 0; i < content.length; i += chunkSize) {\n            await streamingContext.publishEvent({\n              event: \"text.delta\",\n              data: {\n                partId,\n                messageId: streamingContext.messageId,\n                delta: content.slice(i, i + chunkSize),\n              },\n            });\n          }\n        } else {\n          // Single delta when not simulating chunking\n          await streamingContext.publishEvent({\n            event: \"text.delta\",\n            data: {\n              partId,\n              messageId: streamingContext.messageId,\n              delta: content,\n            },\n          });\n        }\n\n        await streamingContext.publishEvent({\n          event: \"part.completed\",\n          data: {\n            partId,\n            runId: streamingContext.runId,\n            messageId: streamingContext.messageId,\n            type: \"text\",\n            finalContent: content,\n          },\n        });\n      }\n    }\n\n    // And ensure we invoke any call from the agent, streaming tool I/O if possible\n    const toolCallOutput = await this.invokeTools(\n      result.output,\n      network,\n      streamingContext,\n      step\n    );\n    if (toolCallOutput.length > 0) {\n      result.toolCalls = result.toolCalls.concat(toolCallOutput);\n    }\n\n    return result;\n  }\n\n  /**\n   * invokeTools takes output messages from an inference call then invokes any tools\n   * in the message responses.\n   */\n  private async invokeTools(\n    msgs: Message[],\n    network: NetworkRun<T>,\n    streamingContext?: StreamingContext,\n    step?: GetStepTools<Inngest.Any>\n  ): Promise<ToolResultMessage[]> {\n    const output: ToolResultMessage[] = [];\n    // Best-effort streaming for tool execution: emit tool-call and output deltas via network streaming if available\n    // Determine if a StreamingContext exists by checking for a symbol on step wrapper (not exposed); for now rely on model-level streaming additions later\n\n    for (const msg of msgs) {\n      if (msg.type !== \"tool_call\") {\n        continue;\n      }\n\n      if (!Array.isArray(msg.tools)) {\n        continue;\n      }\n\n      for (const tool of msg.tools) {\n        const found = this.tools.get(tool.name);\n        if (!found) {\n          throw new Error(\n            `Inference requested a non-existent tool: ${tool.name}`\n          );\n        }\n\n        // Stream tool arguments if context available\n        const toolArgsJson = JSON.stringify(tool.input ?? {});\n        if (streamingContext) {\n          // Generate partId deterministically within a step to avoid replay issues\n          const stepTools = step || (await getStepTools());\n          const toolCallPartId = stepTools\n            ? await stepTools.run(\n                `generate-tool-part-id-${streamingContext.messageId}-${tool.name}`,\n                () => {\n                  return streamingContext.generatePartId();\n                }\n              )\n            : streamingContext.generatePartId();\n\n          await streamingContext.publishEvent({\n            event: \"part.created\",\n            data: {\n              partId: toolCallPartId,\n              runId: streamingContext.runId,\n              messageId: streamingContext.messageId,\n              type: \"tool-call\",\n              metadata: { toolName: tool.name, agentName: this.name },\n            },\n          });\n          if (streamingContext.isSimulatedChunking()) {\n            const argChunkSize = 50;\n            for (let i = 0; i < toolArgsJson.length; i += argChunkSize) {\n              await streamingContext.publishEvent({\n                event: \"tool_call.arguments.delta\",\n                data: {\n                  partId: toolCallPartId,\n                  delta: toolArgsJson.slice(i, i + argChunkSize),\n                  toolName: i === 0 ? tool.name : undefined,\n                  messageId: streamingContext.messageId,\n                },\n              });\n            }\n          } else {\n            await streamingContext.publishEvent({\n              event: \"tool_call.arguments.delta\",\n              data: {\n                partId: toolCallPartId,\n                delta: toolArgsJson,\n                toolName: tool.name,\n                messageId: streamingContext.messageId,\n              },\n            });\n          }\n          await streamingContext.publishEvent({\n            event: \"part.completed\",\n            data: {\n              partId: toolCallPartId,\n              runId: streamingContext.runId,\n              messageId: streamingContext.messageId,\n              type: \"tool-call\",\n              finalContent: tool.input ?? {},\n              metadata: { toolName: tool.name, agentName: this.name },\n            },\n          });\n        }\n\n        // Call this tool.\n        //\n        // XXX: You might expect this to be wrapped in a step, but each tool can\n        // use multiple step tools, eg. `step.run`, then `step.waitForEvent` for\n        // human in the loop tasks.\n        //\n\n        type ToolHandlerResult =\n          | { data: unknown }\n          | { error: ReturnType<typeof errors.serializeError> };\n\n        const result: ToolHandlerResult = await Promise.resolve(\n          found.handler(tool.input, {\n            agent: this,\n            network,\n            step: step as GetStepTools<Inngest.Any>,\n          })\n        )\n          .then((r) => {\n            return {\n              data:\n                typeof r === \"undefined\"\n                  ? `${tool.name} successfully executed`\n                  : r,\n            };\n          })\n          .catch((err: Error) => {\n            return { error: errors.serializeError(err) };\n          });\n\n        // Stream tool output if context available\n        if (streamingContext) {\n          // Generate partId deterministically within a step to avoid replay issues\n          const stepTools = step || (await getStepTools());\n          const outputPartId = stepTools\n            ? await stepTools.run(\n                `generate-output-part-id-${streamingContext.messageId}-${tool.name}`,\n                () => {\n                  return streamingContext.generatePartId();\n                }\n              )\n            : streamingContext.generatePartId();\n\n          await streamingContext.publishEvent({\n            event: \"part.created\",\n            data: {\n              partId: outputPartId,\n              runId: streamingContext.runId,\n              messageId: streamingContext.messageId,\n              type: \"tool-output\",\n              metadata: { toolName: tool.name, agentName: this.name },\n            },\n          });\n\n          const resultJson = JSON.stringify(result);\n          if (streamingContext.isSimulatedChunking()) {\n            const outChunk = 80;\n            for (let i = 0; i < resultJson.length; i += outChunk) {\n              await streamingContext.publishEvent({\n                event: \"tool_call.output.delta\",\n                data: {\n                  partId: outputPartId,\n                  delta: resultJson.slice(i, i + outChunk),\n                  messageId: streamingContext.messageId,\n                },\n              });\n            }\n          } else {\n            await streamingContext.publishEvent({\n              event: \"tool_call.output.delta\",\n              data: {\n                partId: outputPartId,\n                delta: resultJson,\n                messageId: streamingContext.messageId,\n              },\n            });\n          }\n\n          await streamingContext.publishEvent({\n            event: \"part.completed\",\n            data: {\n              partId: outputPartId,\n              runId: streamingContext.runId,\n              messageId: streamingContext.messageId,\n              type: \"tool-output\",\n              finalContent: result,\n              metadata: { toolName: tool.name, agentName: this.name },\n            },\n          });\n        }\n\n        output.push({\n          role: \"tool_result\",\n          type: \"tool_result\",\n          tool: {\n            type: \"tool\",\n            id: tool.id,\n            name: tool.name,\n            input: tool.input.arguments as Record<string, unknown>,\n          },\n\n          content: result,\n          stop_reason: \"tool\",\n        });\n      }\n    }\n\n    return output;\n  }\n\n  private async agentPrompt(\n    input: UserMessage | string,\n    network?: NetworkRun<T>\n  ): Promise<Message[]> {\n    // Prompt returns the full prompt for the current agent.  This does NOT\n    // include the existing network's state as part of the prompt.\n    //\n    // Note that the agent's system message always comes first.\n    const systemContent =\n      typeof this.system === \"string\"\n        ? this.system\n        : await this.system({ network });\n\n    // Extract content and optional system prompt from input\n    const inputContent =\n      typeof input === \"object\" && input !== null && \"content\" in input\n        ? input.content\n        : input;\n\n    const userSystemPrompt =\n      typeof input === \"object\" && input !== null && \"systemPrompt\" in input\n        ? input.systemPrompt\n        : undefined;\n\n    const messages: Message[] = [\n      {\n        type: \"text\",\n        role: \"system\",\n        content: userSystemPrompt\n          ? `${systemContent}\\n\\n${userSystemPrompt}`\n          : systemContent,\n      },\n    ];\n\n    if (inputContent.length > 0) {\n      messages.push({ type: \"text\", role: \"user\", content: inputContent });\n    }\n\n    if (this.assistant.length > 0) {\n      messages.push({\n        type: \"text\",\n        role: \"assistant\",\n        content: this.assistant,\n      });\n    }\n\n    return messages;\n  }\n\n  // initMCP fetches all tools from the agent's MCP servers, adding them to the tool list.\n  // This is all that's necessary in order to enable MCP tool use within agents\n  private async initMCP() {\n    if (!this.mcpServers || this._mcpClients.length >= this.mcpServers.length) {\n      return;\n    }\n\n    const promises = [];\n    for (const server of this.mcpServers) {\n      promises.push(this.listMCPTools(server));\n    }\n\n    await Promise.all(promises);\n  }\n\n  /**\n   * listMCPTools lists all available tools for a given MCP server\n   */\n  private async listMCPTools(server: MCP.Server) {\n    const { JSONSchemaToZod } = await import(\n      \"@dmitryrechkin/json-schema-to-zod\"\n    );\n    const client = await this.mcpClient(server);\n    this._mcpClients.push(client);\n    try {\n      const results = await client.request(\n        { method: \"tools/list\" },\n        ListToolsResultSchema\n      );\n      results.tools.forEach((t) => {\n        const name = `${server.name}-${t.name}`;\n\n        let zschema: undefined | ZodType;\n        try {\n          // The converter may return a Zod v3 schema type; coerce to v4 type or fallback\n          zschema = JSONSchemaToZod.convert(\n            t.inputSchema as JSONSchema\n          ) as unknown as ZodType;\n          // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        } catch (e) {\n          // Do nothing here.\n          zschema = undefined;\n        }\n\n        // Add the MCP tools directly to the tool set.\n        this.tools.set(name, {\n          name: name,\n          description: t.description,\n          parameters: zschema,\n          mcp: {\n            server,\n            tool: t,\n          },\n          handler: async (input: { [x: string]: unknown } | undefined) => {\n            const fn = () =>\n              client.callTool({\n                name: t.name,\n                arguments: input,\n              });\n\n            const step = await getStepTools();\n            const result = await (step?.run(name, fn) ?? fn());\n\n            return result.content;\n          },\n        });\n      });\n    } catch (e) {\n      console.warn(\"error listing mcp tools\", e);\n    }\n  }\n\n  /**\n   * mcpClient creates a new MCP client for the given server.\n   */\n  private async mcpClient(server: MCP.Server): Promise<MCPClient> {\n    // Does this client already exist?\n    const transport: Transport = (() => {\n      switch (server.transport.type) {\n        case \"streamable-http\":\n          return new StreamableHTTPClientTransport(\n            new URL(server.transport.url),\n            {\n              requestInit: server.transport.requestInit,\n              authProvider: server.transport.authProvider,\n              reconnectionOptions: server.transport.reconnectionOptions,\n              sessionId: server.transport.sessionId,\n            }\n          );\n        case \"sse\":\n          // Check if EventSource is defined.  If not, we use a polyfill.\n          if (global.EventSource === undefined) {\n            global.EventSource = EventSource;\n          }\n          return new SSEClientTransport(new URL(server.transport.url), {\n            eventSourceInit: server.transport.eventSourceInit,\n            requestInit: server.transport.requestInit,\n          });\n        case \"ws\":\n          return new WebSocketClientTransport(new URL(server.transport.url));\n        case \"stdio\": {\n          const { command, args, env } = server.transport;\n          const safeProcessEnv = Object.fromEntries(\n            Object.entries(process.env).filter(([, v]) => v !== undefined)\n          ) as Record<string, string>;\n          const finalEnv = { ...safeProcessEnv, ...env };\n          return new StdioClientTransport({\n            command,\n            args,\n            env: finalEnv,\n          });\n        }\n      }\n    })();\n\n    const client = new MCPClient(\n      {\n        name: this.name,\n        // XXX: This version should change.\n        version: \"1.0.0\",\n      },\n      {\n        capabilities: {},\n      }\n    );\n    try {\n      await client.connect(transport);\n    } catch (e) {\n      // The transport closed.\n      console.warn(\"mcp server disconnected\", server, e);\n    }\n    return client;\n  }\n}\n\nexport class RoutingAgent<T extends StateData> extends Agent<T> {\n  type = \"routing\";\n  override lifecycles: Agent.RoutingLifecycle<T>;\n  constructor(opts: Agent.RoutingConstructor<T>) {\n    super(opts);\n    this.lifecycles = opts.lifecycle;\n  }\n\n  override withModel(model: AiAdapter.Any): RoutingAgent<T> {\n    return new RoutingAgent({\n      name: this.name,\n      description: this.description,\n      system: this.system,\n      assistant: this.assistant,\n      tools: Array.from(this.tools.values()),\n      lifecycle: this.lifecycles,\n      model,\n    });\n  }\n}\n\nexport namespace Agent {\n  export interface Constructor<T extends StateData> {\n    name: string;\n    description?: string;\n    system:\n      | string\n      | ((ctx: { network?: NetworkRun<T> }) => MaybePromise<string>);\n    assistant?: string;\n    tools?: (Tool.Any | InngestFunction.Any)[];\n    tool_choice?: Tool.Choice;\n    lifecycle?: Lifecycle<T>;\n    model?: AiAdapter.Any;\n    mcpServers?: MCP.Server[];\n    history?: HistoryConfig<T>;\n  }\n\n  export interface RoutingConstructor<T extends StateData>\n    extends Omit<Constructor<T>, \"lifecycle\"> {\n    lifecycle: RoutingLifecycle<T>;\n  }\n\n  export interface RoutingConstructor<T extends StateData>\n    extends Omit<Constructor<T>, \"lifecycle\"> {\n    lifecycle: RoutingLifecycle<T>;\n  }\n\n  export interface RoutingConstructor<T extends StateData>\n    extends Omit<Constructor<T>, \"lifecycle\"> {\n    lifecycle: RoutingLifecycle<T>;\n  }\n\n  export interface RunOptions<T extends StateData> {\n    model?: AiAdapter.Any;\n    network?: NetworkRun<T>;\n    /**\n     * State allows you to pass custom state into a single agent run call.  This should only\n     * be provided if you are running agents outside of a network.  Networks automatically\n     * supply their own state.\n     */\n    state?: State<T>;\n    maxIter?: number;\n    /**\n     * Streaming configuration for standalone agent runs. When provided, the agent will\n     * automatically emit streaming events throughout its execution. Note: this is ignored\n     * when the agent is run within a network, as networks control streaming.\n     */\n    streaming?: StreamingConfig;\n    // Internal: provided by Network to enable runtime streaming from agents\n    streamingContext?: StreamingContext;\n    // Internal: provided by Network to pass wrapped step tools for automatic step events\n    step?: GetStepTools<Inngest.Any>;\n  }\n\n  export interface Lifecycle<T extends StateData> {\n    /**\n     * enabled selectively enables or disables this agent based off of network\n     * state.  If this function is not provided, the agent is always enabled.\n     */\n    enabled?: (args: Agent.LifecycleArgs.Base<T>) => MaybePromise<boolean>;\n\n    /**\n     * onStart is called just before an agent starts an inference call.\n     *\n     * This receives the full agent prompt.  If this is a networked agent, the\n     * agent will also receive the network's history which will be concatenated\n     * to the end of the prompt when making the inference request.\n     *\n     * The return values can be used to adjust the prompt, history, or to stop\n     * the agent from making the call altogether.\n     *\n     */\n    onStart?: (args: Agent.LifecycleArgs.Before<T>) => MaybePromise<{\n      prompt: Message[];\n      history: Message[];\n      // stop, if true, will prevent calling the agent\n      stop: boolean;\n    }>;\n\n    /**\n     * onResponse is called after the inference call finishes, before any tools\n     * have been invoked. This allows you to moderate the response prior to\n     * running tools.\n     */\n    onResponse?: (\n      args: Agent.LifecycleArgs.Result<T>\n    ) => MaybePromise<AgentResult>;\n\n    /**\n     * onFinish is called with a finalized AgentResult, including any tool\n     * call results. The returned AgentResult will be saved to network\n     * history, if the agent is part of the network.\n     *\n     */\n    onFinish?: (\n      args: Agent.LifecycleArgs.Result<T>\n    ) => MaybePromise<AgentResult>;\n  }\n\n  export namespace LifecycleArgs {\n    export interface Base<T extends StateData> {\n      // Agent is the agent that made the call.\n      agent: Agent<T>;\n      // Network represents the network that this agent or lifecycle belongs to.\n      network?: NetworkRun<T>;\n    }\n\n    export interface Result<T extends StateData> extends Base<T> {\n      result: AgentResult;\n    }\n\n    export interface Before<T extends StateData> extends Base<T> {\n      // input is the user request for the entire agentic operation.\n      input?: string;\n\n      // prompt is the system, user, and any assistant prompt as generated\n      // by the Agent.  This does not include any past history.\n      prompt: Message[];\n\n      // history is the past history as generated via State.  Ths will be added\n      // after the prompt to form a single conversation log.\n      history?: Message[];\n    }\n  }\n\n  export interface RoutingLifecycle<T extends StateData> extends Lifecycle<T> {\n    onRoute: RouterFn<T>;\n  }\n\n  export type RouterFn<T extends StateData> = (\n    args: Agent.RouterArgs<T>\n  ) => string[] | undefined;\n\n  /**\n   * Router args are the arguments passed to the onRoute lifecycle hook.\n   */\n  export type RouterArgs<T extends StateData> = Agent.LifecycleArgs.Result<T>;\n}\n","import { type AiAdapter } from \"@inngest/ai\";\nimport { adapters } from \"./adapters\";\nimport { type Message } from \"./types\";\nimport { type Tool } from \"./tool\";\nimport { getStepTools } from \"./util\";\n\nexport const createAgenticModelFromAiAdapter = <\n  TAiAdapter extends AiAdapter.Any,\n>(\n  adapter: TAiAdapter\n): AgenticModel<TAiAdapter> => {\n  const opts = adapters[adapter.format as AiAdapter.Format];\n\n  return new AgenticModel({\n    model: adapter,\n    requestParser:\n      opts.request as unknown as AgenticModel.RequestParser<TAiAdapter>,\n    responseParser:\n      opts.response as unknown as AgenticModel.ResponseParser<TAiAdapter>,\n  });\n};\n\nexport class AgenticModel<TAiAdapter extends AiAdapter.Any> {\n  #model: TAiAdapter;\n  requestParser: AgenticModel.RequestParser<TAiAdapter>;\n  responseParser: AgenticModel.ResponseParser<TAiAdapter>;\n\n  constructor({\n    model,\n    requestParser,\n    responseParser,\n  }: AgenticModel.Constructor<TAiAdapter>) {\n    this.#model = model;\n    this.requestParser = requestParser;\n    this.responseParser = responseParser;\n  }\n\n  async infer(\n    stepID: string,\n    input: Message[],\n    tools: Tool.Any[],\n    tool_choice: Tool.Choice\n  ): Promise<AgenticModel.InferenceResponse> {\n    // TODO: Implement true token-by-token streaming from LLM providers\n    // Currently using completed response chunking for streaming simulation\n    // Future enhancement: Process real-time token streams from OpenAI/Anthropic/etc.\n    const body = this.requestParser(this.#model, input, tools, tool_choice);\n    let result: AiAdapter.Input<TAiAdapter>;\n\n    const step = await getStepTools();\n\n    if (step) {\n      result = (await step.ai.infer(stepID, {\n        model: this.#model,\n        body,\n      })) as AiAdapter.Input<TAiAdapter>;\n    } else {\n      // Allow the model to mutate options and body for this call\n      const modelCopy = { ...this.#model };\n      this.#model.onCall?.(modelCopy, body);\n\n      const url = new URL(modelCopy.url || \"\");\n\n      const headers: Record<string, string> = {\n        \"Content-Type\": \"application/json\",\n      };\n\n      // Make sure we handle every known format in `@inngest/ai`.\n      const formatHandlers: Record<AiAdapter.Format, () => void> = {\n        \"openai-chat\": () => {\n          headers[\"Authorization\"] = `Bearer ${modelCopy.authKey}`;\n        },\n        \"azure-openai\": () => {\n          headers[\"api-key\"] = modelCopy.authKey;\n        },\n        anthropic: () => {\n          headers[\"x-api-key\"] = modelCopy.authKey;\n          headers[\"anthropic-version\"] = \"2023-06-01\";\n        },\n        gemini: () => {},\n        grok: () => {},\n      };\n\n      formatHandlers[modelCopy.format as AiAdapter.Format]();\n\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n      result = await (\n        await fetch(url, {\n          method: \"POST\",\n          headers,\n          body: JSON.stringify(body),\n        })\n      ).json();\n    }\n\n    return { output: this.responseParser(result), raw: result };\n  }\n}\n\nexport namespace AgenticModel {\n  export type Any = AgenticModel<AiAdapter.Any>;\n\n  /**\n   * InferenceResponse is the response from a model for an inference request.\n   * This contains parsed messages and the raw result, with the type of the raw\n   * result depending on the model's API repsonse.\n   */\n  export type InferenceResponse<T = unknown> = {\n    output: Message[];\n    raw: T;\n  };\n\n  export interface Constructor<TAiAdapter extends AiAdapter.Any> {\n    model: TAiAdapter;\n    requestParser: RequestParser<TAiAdapter>;\n    responseParser: ResponseParser<TAiAdapter>;\n  }\n\n  export type RequestParser<TAiAdapter extends AiAdapter.Any> = (\n    model: TAiAdapter,\n    state: Message[],\n    tools: Tool.Any[],\n    tool_choice: Tool.Choice\n  ) => AiAdapter.Input<TAiAdapter>;\n\n  export type ResponseParser<TAiAdapter extends AiAdapter.Any> = (\n    output: AiAdapter.Output<TAiAdapter>\n  ) => Message[];\n}\n","import { type AiAdapter, type AiAdapters } from \"@inngest/ai\";\nimport { type AgenticModel } from \"../model\";\nimport * as anthropic from \"./anthropic\";\nimport * as openai from \"./openai\";\nimport * as azureOpenai from \"./azure-openai\";\nimport * as gemini from \"./gemini\";\nimport * as grok from \"./grok\";\n\nexport type Adapters = {\n  [Format in AiAdapter.Format]: {\n    request: AgenticModel.RequestParser<AiAdapters[Format]>;\n    response: AgenticModel.ResponseParser<AiAdapters[Format]>;\n  };\n};\n\nexport const adapters: Adapters = {\n  \"openai-chat\": {\n    request: openai.requestParser,\n    response: openai.responseParser,\n  },\n  \"azure-openai\": {\n    request: azureOpenai.requestParser,\n    response: azureOpenai.responseParser,\n  },\n  anthropic: {\n    request: anthropic.requestParser,\n    response: anthropic.responseParser,\n  },\n  gemini: {\n    request: gemini.requestParser,\n    response: gemini.responseParser,\n  },\n  grok: {\n    request: grok.requestParser,\n    response: grok.responseParser,\n  },\n};\n","/**\n * Adapters for Anthropic I/O to transform to/from internal network messages.\n *\n * @module\n */\nimport {\n  type AiAdapter,\n  type Anthropic,\n  type AnthropicAiAdapter,\n} from \"@inngest/ai\";\nimport { z } from \"zod\";\nimport { type AgenticModel } from \"../model\";\nimport { type Message, type TextMessage } from \"../types\";\nimport { type Tool } from \"../tool\";\n\n/**\n * Parse a request from internal network messages to an Anthropic input.\n */\nexport const requestParser: AgenticModel.RequestParser<Anthropic.AiModel> = (\n  model,\n  messages,\n  tools,\n  tool_choice = \"auto\"\n) => {\n  // Note that Anthropic has a top-level system prompt, then a series of prompts\n  // for assistants and users.\n  const systemMessage = messages.find(\n    (m: Message) => m.role === \"system\" && m.type === \"text\"\n  ) as TextMessage;\n  const system =\n    typeof systemMessage?.content === \"string\" ? systemMessage.content : \"\";\n\n  const anthropicMessages: AiAdapter.Input<Anthropic.AiModel>[\"messages\"] =\n    messages\n      .filter((m: Message) => m.role !== \"system\")\n      .reduce(\n        (\n          acc: AiAdapter.Input<Anthropic.AiModel>[\"messages\"],\n          m: Message\n        ): AiAdapter.Input<Anthropic.AiModel>[\"messages\"] => {\n          switch (m.type) {\n            case \"text\":\n              return [\n                ...acc,\n                {\n                  role: m.role,\n                  content: Array.isArray(m.content)\n                    ? m.content.map((text) => ({ type: \"text\", text }))\n                    : m.content,\n                },\n              ] as AiAdapter.Input<Anthropic.AiModel>[\"messages\"];\n            case \"tool_call\":\n              return [\n                ...acc,\n                {\n                  role: m.role,\n                  content: m.tools.map((tool) => ({\n                    type: \"tool_use\",\n                    id: tool.id,\n                    input: tool.input,\n                    name: tool.name,\n                  })),\n                },\n              ];\n            case \"tool_result\":\n              return [\n                ...acc,\n                {\n                  role: \"user\",\n                  content: [\n                    {\n                      type: \"tool_result\",\n                      tool_use_id: m.tool.id,\n                      content:\n                        typeof m.content === \"string\"\n                          ? m.content\n                          : JSON.stringify(m.content),\n                    },\n                  ],\n                },\n              ];\n          }\n        },\n        [] as AiAdapter.Input<Anthropic.AiModel>[\"messages\"]\n      );\n\n  // We need to patch the last message if it's an assistant message.  This is a known limitation of Anthropic's API.\n  // cf: https://github.com/langchain-ai/langgraph/discussions/952#discussioncomment-10012320\n  const lastMessage = anthropicMessages[anthropicMessages.length - 1];\n  if (lastMessage?.role === \"assistant\") {\n    lastMessage.role = \"user\";\n  }\n\n  const request: AiAdapter.Input<Anthropic.AiModel> = {\n    system,\n    model: model.options.model,\n    max_tokens: model.options.defaultParameters.max_tokens,\n    messages: anthropicMessages,\n  };\n\n  if (tools?.length) {\n    request.tools = tools.map((t: Tool.Any) => {\n      return {\n        name: t.name,\n        description: t.description,\n        input_schema: (t.parameters\n          ? z.toJSONSchema(t.parameters, {\n              target: \"draft-2020-12\",\n            })\n          : z.toJSONSchema(z.object({}), {\n              target: \"draft-2020-12\",\n            })) as AnthropicAiAdapter.Tool.InputSchema,\n      };\n    });\n    request.tool_choice = toolChoice(tool_choice);\n  }\n\n  return request;\n};\n\n/**\n * Parse a response from Anthropic output to internal network messages.\n */\nexport const responseParser: AgenticModel.ResponseParser<Anthropic.AiModel> = (\n  input\n) => {\n  if (input.type === \"error\") {\n    throw new Error(\n      input.error?.message ||\n        `Anthropic request failed: ${JSON.stringify(input.error)}`\n    );\n  }\n\n  return (input?.content ?? []).reduce<Message[]>((acc, item) => {\n    if (!item.type) {\n      return acc;\n    }\n\n    switch (item.type) {\n      case \"text\":\n        return [\n          ...acc,\n          {\n            type: \"text\",\n            role: input.role,\n            content: item.text,\n            // XXX: Better stop reason parsing\n            stop_reason: \"stop\",\n          },\n        ];\n      case \"tool_use\": {\n        let args;\n        try {\n          // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n          args =\n            typeof item.input === \"string\"\n              ? JSON.parse(item.input)\n              : item.input;\n        } catch {\n          args = item.input;\n        }\n\n        return [\n          ...acc,\n          {\n            type: \"tool_call\",\n            role: input.role,\n            stop_reason: \"tool\",\n            tools: [\n              {\n                type: \"tool\",\n                id: item.id,\n                name: item.name,\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n                input: args,\n              },\n            ],\n          },\n        ];\n      }\n    }\n  }, []);\n};\n\nconst toolChoice = (\n  choice: Tool.Choice\n): AiAdapter.Input<Anthropic.AiModel>[\"tool_choice\"] => {\n  switch (choice) {\n    case \"auto\":\n      return { type: \"auto\" };\n    case \"any\":\n      return { type: \"any\" };\n    default:\n      if (typeof choice === \"string\") {\n        return {\n          type: \"tool\",\n          name: choice as string,\n        };\n      }\n  }\n};\n","import { type GetStepTools, type Inngest } from \"inngest\";\nimport { type output as ZodOutput } from \"zod\";\nimport { type Agent } from \"./agent\";\nimport { type StateData } from \"./state\";\nimport { type NetworkRun } from \"./network\";\nimport { type AnyZodType, type MaybePromise } from \"./util\";\nimport type { StreamableHTTPReconnectionOptions } from \"@modelcontextprotocol/sdk/client/streamableHttp.js\";\nimport type { OAuthClientProvider } from \"@modelcontextprotocol/sdk/client/auth.js\";\n\n/**\n * ToolResultPayload mirrors the UI package shape for structured tool outputs.\n */\nexport type ToolResultPayload<T> = { data: T };\n\n/**\n * createTool is a helper that properly types the input argument for a handler\n * based off of the Zod parameter types, and captures the handler output type.\n */\nexport function createTool<\n  TName extends string,\n  TInput extends Tool.Input,\n  TOutput,\n  TState extends StateData,\n>({\n  name,\n  description,\n  parameters,\n  handler,\n}: {\n  name: TName;\n  description?: string;\n  parameters?: TInput;\n  handler: (\n    input: ZodOutput<TInput>,\n    opts: Tool.Options<TState>\n  ) => MaybePromise<TOutput>;\n}): Tool<TName, TInput, TOutput> {\n  return {\n    name,\n    description,\n    parameters,\n    handler<TS extends StateData>(\n      input: ZodOutput<TInput>,\n      opts: Tool.Options<TS>\n    ): MaybePromise<TOutput> {\n      return handler(input, opts as unknown as Tool.Options<TState>);\n    },\n  };\n}\n\nexport type Tool<TName extends string, TInput extends Tool.Input, TOutput> = {\n  name: TName;\n  description?: string;\n  parameters?: TInput;\n\n  // mcp lists the MCP details for this tool, if this tool is provided by an\n  // MCP server.\n  mcp?: {\n    server: MCP.Server;\n    tool: MCP.Tool;\n  };\n\n  strict?: boolean;\n\n  handler<TState extends StateData>(\n    input: ZodOutput<TInput>,\n    opts: Tool.Options<TState>\n  ): MaybePromise<TOutput>;\n};\n\nexport namespace Tool {\n  export type Any = Tool<string, Tool.Input, unknown>;\n\n  export type Options<T extends StateData> = {\n    agent: Agent<T>;\n    network: NetworkRun<T>;\n    step?: GetStepTools<Inngest.Any>;\n  };\n\n  export type Input = AnyZodType;\n\n  export type Choice = \"auto\" | \"any\" | (string & {});\n}\n\n/**\n * Helper to create a strongly-typed tool manifest from a list of tools.\n *\n * Returns a simple runtime object keyed by tool name. The primary value is the\n * compile-time type that captures each tool's input and output types.\n */\nexport function createToolManifest<\n  TTools extends readonly Tool<string, Tool.Input, unknown>[],\n>(tools: TTools) {\n  const manifest: Record<string, { input: unknown; output: unknown }> = {};\n  for (const t of tools) {\n    // runtime structure is intentionally minimal; types carry the value\n    manifest[t.name] = { input: {}, output: {} };\n  }\n  type Result = {\n    [K in TTools[number] as K[\"name\"] & string]: K extends Tool<\n      string,\n      infer In extends AnyZodType,\n      infer Out\n    >\n      ? { input: ZodOutput<In>; output: ToolResultPayload<Out> }\n      : never;\n  };\n  return manifest as Result;\n}\n\nexport namespace MCP {\n  export type Server = {\n    // name is a short name for the MCP server, eg. \"github\".  This allows\n    // us to namespace tools for each MCP server.\n    name: string;\n    transport:\n      | TransportSSE\n      | TransportWebsocket\n      | TransportStreamableHttp\n      | TransportStdio;\n  };\n\n  export type Transport =\n    | TransportSSE\n    | TransportWebsocket\n    | TransportStreamableHttp\n    | TransportStdio;\n\n  export type TransportStreamableHttp = {\n    type: \"streamable-http\";\n    url: string;\n    requestInit?: RequestInit;\n    reconnectionOptions?: StreamableHTTPReconnectionOptions;\n    sessionId?: string;\n    authProvider?: OAuthClientProvider;\n  };\n\n  export type TransportStdio = {\n    type: \"stdio\";\n    command: string;\n    args: string[];\n    env?: Record<string, string>;\n  };\n\n  export type TransportSSE = {\n    type: \"sse\";\n    url: string;\n    eventSourceInit?: EventSourceInit;\n    requestInit?: RequestInit;\n  };\n\n  export type TransportWebsocket = {\n    type: \"ws\";\n    url: string;\n  };\n\n  export type Tool = {\n    name: string;\n    description?: string;\n    inputSchema?: {\n      type: \"object\";\n      properties?: unknown;\n    };\n  };\n}\n","/**\n * Adapters for OpenAI I/O to transform to/from internal network messages.\n *\n * @module\n */\n\nimport { type AiAdapter, type OpenAi } from \"@inngest/ai\";\nimport { z } from \"zod\";\nimport { type AgenticModel } from \"../model\";\nimport {\n  type Message,\n  type TextMessage,\n  type ToolCallMessage,\n  type ToolMessage,\n} from \"../types\";\nimport { type Tool } from \"../tool\";\nimport { stringifyError } from \"../util\";\n\n/**\n * Parse a request from internal network messages to an OpenAI input.\n */\nexport const requestParser: AgenticModel.RequestParser<OpenAi.AiModel> = (\n  model,\n  messages,\n  tools,\n  tool_choice = \"auto\"\n) => {\n  const request: AiAdapter.Input<OpenAi.AiModel> = {\n    messages: messages.map((m: Message) => {\n      switch (m.type) {\n        case \"text\":\n          return {\n            role: m.role,\n            content: m.content,\n          };\n        case \"tool_call\":\n          return {\n            role: \"assistant\",\n            content: null,\n            tool_calls: m.tools\n              ? m.tools?.map((tool) => ({\n                  id: tool.id,\n                  type: \"function\",\n                  function: {\n                    name: tool.name,\n                    arguments: JSON.stringify(tool.input),\n                  },\n                }))\n              : undefined,\n          };\n        case \"tool_result\":\n          return {\n            role: \"tool\",\n            tool_call_id: m.tool.id,\n            content:\n              typeof m.content === \"string\"\n                ? m.content\n                : JSON.stringify(m.content),\n          };\n      }\n    }) as AiAdapter.Input<OpenAi.AiModel>[\"messages\"],\n  };\n\n  if (tools?.length) {\n    request.tool_choice = toolChoice(tool_choice);\n    // OpenAI o3 models have several issues with tool calling.\n    //  one of them is not supporting the `parallel_tool_calls` parameter\n    //  https://community.openai.com/t/o3-mini-api-with-tools-only-ever-returns-1-tool-no-matter-prompt/1112390/6\n    if (\n      !model.options.model?.includes(\"o3\") &&\n      !model.options.model?.includes(\"o1\")\n    ) {\n      // it is recommended to disable parallel tool calls with structured output\n      // https://platform.openai.com/docs/guides/function-calling#parallel-function-calling-and-structured-outputs\n      request.parallel_tool_calls = false;\n    }\n\n    request.tools = tools.map((t: Tool.Any) => {\n      return {\n        type: \"function\",\n        function: {\n          name: t.name,\n          description: t.description,\n          parameters:\n            t.parameters && z.toJSONSchema(t.parameters, { target: \"draft-7\" }),\n          strict:\n            typeof t.strict !== \"undefined\" ? t.strict : Boolean(t.parameters), // strict mode is only supported with parameters\n        },\n      };\n    });\n  }\n\n  return request;\n};\n\n/**\n * Parse a response from OpenAI output to internal network messages.\n *\n * This function transforms OpenAI's response format into our internal Message format,\n * handling both text responses and tool calls. It processes multiple choices if present\n * and creates separate messages for text content and tool calls when both exist.\n */\nexport const responseParser: AgenticModel.ResponseParser<OpenAi.AiModel> = (\n  input\n) => {\n  // Handle API errors first - throw immediately if the request failed\n  if (input.error) {\n    throw new Error(\n      input.error.message ||\n        `OpenAI request failed: ${JSON.stringify(input.error)}`\n    );\n  }\n\n  // Process all choices from the OpenAI response using reduce to flatten into a single Message array\n  // OpenAI can return multiple choices, though typically only one is returned\n  return (input?.choices ?? []).reduce<Message[]>((acc, choice) => {\n    const { message, finish_reason } = choice;\n\n    // Skip empty messages - can happen in some edge cases\n    if (!message) {\n      return acc;\n    }\n\n    // Create base message properties shared by all message types\n    // Maps OpenAI's finish_reason to our internal stop_reason format\n    const base = {\n      role: choice.message.role,\n      stop_reason:\n        openAiStopReasonToStateStopReason[finish_reason ?? \"\"] || \"stop\",\n    };\n\n    // Handle text content - only create a text message if content exists and isn't empty/whitespace\n    // This check prevents empty content messages that can occur when only tool calls are present\n    if (message.content && message.content.trim() !== \"\") {\n      acc.push({\n        ...base,\n        type: \"text\",\n        content: message.content,\n      } as TextMessage);\n    }\n\n    // Handle tool calls - create a separate tool_call message containing all tools\n    // OpenAI can return multiple tool calls in a single response (parallel tool calling)\n    if ((message.tool_calls?.length ?? 0) > 0) {\n      acc.push({\n        ...base,\n        type: \"tool_call\",\n        tools: message.tool_calls.map((tool) => {\n          return {\n            type: \"tool\",\n            id: tool.id,\n            name: tool.function.name,\n            function: tool.function.name, // Duplicate for backward compatibility\n            // Use safe parser to handle OpenAI's JSON quirks (like backticks in strings)\n            input: safeParseOpenAIJson(tool.function.arguments || \"{}\"),\n          } as ToolMessage;\n        }),\n      } as ToolCallMessage);\n    }\n\n    return acc;\n  }, []);\n};\n\n/**\n * Parse the given `str` `string` as JSON, also handling backticks, a common\n * OpenAI quirk.\n *\n * @example Input\n * ```\n * \"{\\n  \\\"files\\\": [\\n    {\\n      \\\"filename\\\": \\\"fibo.ts\\\",\\n      \\\"content\\\": `\\nfunction fibonacci(n: number): number {\\n  if (n < 2) {\\n    return n;\\n  } else {\\n    return fibonacci(n - 1) + fibonacci(n - 2);\\n  }\\n}\\n\\nexport default fibonacci;\\n`\\n    }\\n  ]\\n}\"\n * ```\n */\nconst safeParseOpenAIJson = (str: string): unknown => {\n  // Remove any leading/trailing quotes if present\n  const trimmed = str.replace(/^[\"']|[\"']$/g, \"\");\n\n  try {\n    // First try direct JSON parse\n    return JSON.parse(trimmed);\n  } catch {\n    try {\n      // Replace backtick strings with regular JSON strings\n      // Match content between backticks, preserving newlines\n      const withQuotes = trimmed.replace(/`([\\s\\S]*?)`/g, (_, content) =>\n        JSON.stringify(content)\n      );\n      return JSON.parse(withQuotes);\n    } catch (e) {\n      throw new Error(\n        `Failed to parse JSON with backticks: ${stringifyError(e)}`\n      );\n    }\n  }\n};\n\nconst openAiStopReasonToStateStopReason: Record<string, string> = {\n  tool_calls: \"tool\",\n  stop: \"stop\",\n  length: \"stop\",\n  content_filter: \"stop\",\n  function_call: \"tool\",\n};\n\nconst toolChoice = (choice: Tool.Choice) => {\n  switch (choice) {\n    case \"auto\":\n      return \"auto\";\n    case \"any\":\n      return \"required\";\n    default:\n      return {\n        type: \"function\" as const,\n        function: { name: choice as string },\n      };\n  }\n};\n","import { type AiAdapter, type AzureOpenAi, type OpenAi } from \"@inngest/ai\";\nimport { type AgenticModel } from \"../model\";\nimport {\n  requestParser as openaiRequestParser,\n  responseParser as openaiResponseParser,\n} from \"./openai\";\n\nexport const requestParser: AgenticModel.RequestParser<AzureOpenAi.AiModel> = (\n  model,\n  messages,\n  tools,\n  tool_choice = \"auto\"\n) =>\n  openaiRequestParser(\n    model as unknown as OpenAi.AiModel,\n    messages,\n    tools,\n    tool_choice\n  );\n\nexport const responseParser: AgenticModel.ResponseParser<\n  AzureOpenAi.AiModel\n> = (output) =>\n  openaiResponseParser(output as unknown as AiAdapter.Output<OpenAi.AiModel>);\n","/* eslint-disable @typescript-eslint/no-unsafe-member-access */\n/* eslint-disable @typescript-eslint/no-unsafe-assignment */\n/**\n * Adapters for Gemini I/O to transform to/from internal network messages.\n *\n * @module\n */\nimport { type AiAdapter, type Gemini } from \"@inngest/ai\";\nimport { z, type ZodSchema } from \"zod\";\n\nimport { type AgenticModel } from \"../model\";\nimport type { Message, TextContent } from \"../types\";\nimport { type Tool } from \"../tool\";\n\n/**\n * Parse a request from internal network messages to an Gemini input.\n */\nexport const requestParser: AgenticModel.RequestParser<Gemini.AiModel> = (\n  _model,\n  messages,\n  tools,\n  tool_choice = \"auto\"\n) => {\n  const contents = messages.map((m: Message) => messageToContent(m));\n\n  const functionDeclarations = tools.map((t: Tool.Any) => ({\n    name: t.name,\n    description: t.description,\n    parameters: t.parameters\n      ? geminiZodToJsonSchema(t.parameters)\n      : // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        (geminiZodToJsonSchema(z.object({})) as any),\n  }));\n\n  return {\n    contents,\n    ...(tools.length > 0\n      ? {\n          tools: [\n            {\n              functionDeclarations,\n            },\n          ],\n          tool_config: toolChoice(tool_choice),\n        }\n      : {}),\n  };\n};\n\nconst messageContentToString = (content: string | TextContent[]): string => {\n  if (typeof content === \"string\") {\n    return content;\n  }\n  return content.map((c) => c.text).join(\"\");\n};\n\n/**\n * Parse a response from Gemini output to internal network messages.\n */\nexport const responseParser: AgenticModel.ResponseParser<Gemini.AiModel> = (\n  input\n) => {\n  if (input.error) {\n    throw new Error(\n      input.error?.message ||\n        `Gemini request failed: ${JSON.stringify(input.error)}`\n    );\n  }\n\n  const messages: Message[] = [];\n\n  for (const candidate of input.candidates ?? []) {\n    if ((candidate.finishReason as string) === \"MALFORMED_FUNCTION_CALL\") {\n      console.warn(\n        \"Gemini returned MALFORMED_FUNCTION_CALL, skipping this candidate. This typically indicates an issue with tool/function call formatting. Check your tool definitions and parameters.\"\n      );\n      continue; // Skip this candidate but continue processing others\n    }\n    if (!candidate.content?.parts) {\n      continue; // Skip candidates without parts\n    }\n    for (const content of candidate.content.parts) {\n      // user text\n      if (candidate.content.role === \"user\" && \"text\" in content) {\n        messages.push({\n          role: \"user\",\n          type: \"text\",\n          content: content.text,\n        });\n      }\n      // assistant text\n      else if (candidate.content.role === \"model\" && \"text\" in content) {\n        messages.push({\n          role: \"assistant\",\n          type: \"text\",\n          content: content.text,\n        });\n      }\n      // tool call\n      else if (\n        candidate.content.role === \"model\" &&\n        \"functionCall\" in content\n      ) {\n        messages.push({\n          role: \"assistant\",\n          type: \"tool_call\",\n          stop_reason: \"tool\",\n          tools: [\n            {\n              name: content.functionCall.name,\n              input: content.functionCall.args,\n              type: \"tool\",\n              id: content.functionCall.name,\n            },\n          ],\n        });\n      }\n      // tool result\n      else if (\n        candidate.content.role === \"user\" &&\n        \"functionResponse\" in content\n      ) {\n        messages.push({\n          role: \"tool_result\",\n          type: \"tool_result\",\n          stop_reason: \"tool\",\n          tool: {\n            name: content.functionResponse.name,\n            input: content.functionResponse.response,\n            type: \"tool\",\n            id: content.functionResponse.name,\n          },\n          content: JSON.stringify(content.functionResponse.response),\n        });\n      } else {\n        throw new Error(\"Unknown content type\");\n      }\n    }\n  }\n\n  return messages;\n};\n\nconst messageToContent = (\n  m: Message\n): AiAdapter.Input<Gemini.AiModel>[\"contents\"][0] => {\n  switch (m.role) {\n    case \"system\":\n      return {\n        role: \"user\",\n        parts: [{ text: messageContentToString(m.content) }],\n      };\n    case \"user\":\n      switch (m.type) {\n        case \"tool_call\":\n          if (m.tools.length === 0) {\n            throw new Error(\"Tool call message must have at least one tool\");\n          }\n          // Note: multiple tools is only supported over WS (Compositional function calling)\n          return {\n            role: \"model\",\n            parts: [\n              {\n                functionCall: {\n                  name: m.tools[0]!.name,\n                  args: m.tools[0]!.input,\n                },\n              },\n            ],\n          };\n        case \"text\":\n        default:\n          return {\n            role: \"user\",\n            parts: [{ text: messageContentToString(m.content) }],\n          };\n      }\n    case \"assistant\":\n      switch (m.type) {\n        case \"tool_call\":\n          if (m.tools.length === 0) {\n            throw new Error(\"Tool call message must have at least one tool\");\n          }\n          // Note: multiple tools is only supported over WS (Compositional function calling)\n          return {\n            role: \"model\",\n            parts: [\n              {\n                functionCall: {\n                  name: m.tools[0]!.name,\n                  args: m.tools[0]!.input,\n                },\n              },\n            ],\n          };\n        case \"text\":\n        default:\n          return {\n            role: \"model\",\n            parts: [{ text: messageContentToString(m.content) }],\n          };\n      }\n    case \"tool_result\":\n      return {\n        role: \"user\",\n        parts: [\n          {\n            functionResponse: {\n              name: m.tool.name,\n              response: {\n                name: m.tool.name,\n                content:\n                  typeof m.content === \"string\"\n                    ? m.content\n                    : JSON.stringify(m.content),\n              },\n            },\n          },\n        ],\n      };\n    default:\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      throw new Error(`Unknown message role: ${(m as any).role}`);\n  }\n};\n\nconst toolChoice = (\n  choice: Tool.Choice\n): AiAdapter.Input<Gemini.AiModel>[\"toolConfig\"] => {\n  switch (choice) {\n    case \"auto\":\n      return {\n        functionCallingConfig: {\n          mode: \"AUTO\",\n        },\n      };\n    case \"any\":\n      return {\n        functionCallingConfig: {\n          mode: \"ANY\",\n        },\n      };\n    default:\n      if (typeof choice === \"string\") {\n        return {\n          functionCallingConfig: {\n            mode: \"ANY\",\n            allowedFunctionNames: [choice],\n          },\n        };\n      }\n  }\n};\n\ntype Removed<T, Drop = \"additionalProperties\"> = T extends object\n  ? { [K in Exclude<keyof T, Drop>]: Removed<T[K], Drop> }\n  : T;\n\n/**\n * Recursively remove `additionalProperties` from Zod schema objects.\n */\nexport const recursiveGeminiZodToJsonSchema = <T>(obj: T): Removed<T> => {\n  if (obj === null || obj === undefined || typeof obj !== \"object\") {\n    return obj as Removed<T>;\n  }\n\n  if (Array.isArray(obj)) {\n    return obj.map(recursiveGeminiZodToJsonSchema) as unknown as Removed<T>;\n  }\n  const newObj: T = { ...obj }; // Create a shallow copy for the current level\n\n  for (const key in newObj) {\n    if (newObj[key] != null) {\n      newObj[key] = recursiveGeminiZodToJsonSchema(\n        newObj[key]\n      ) as T[typeof key];\n    }\n  }\n  if (newObj?.[\"additionalProperties\" as keyof typeof newObj] != null) {\n    delete newObj[\"additionalProperties\" as keyof typeof newObj];\n  }\n  return newObj as Removed<T>;\n};\n\nconst geminiZodToJsonSchema = (schemaIn: ZodSchema) => {\n  let schema = z.toJSONSchema(schemaIn, { target: \"openapi-3.0\", io: \"input\" });\n  schema = recursiveGeminiZodToJsonSchema(schema);\n  return schema;\n};\n","/**\n * Adapters for Grok I/O to transform to/from internal network messages.\n * Grok is an exotic one, it is an OpenAI-compatible API,\n * but does not support strict mode Function Calling, requiring an adapter.\n *\n * @module\n */\n\nimport type { AiAdapter, Grok, OpenAi } from \"inngest\";\nimport type { AgenticModel } from \"../model\";\nimport {\n  requestParser as openaiRequestParser,\n  responseParser as openaiResponseParser,\n} from \"./openai\";\n\n/**\n * Parse a request from internal network messages to an OpenAI input.\n */\nexport const requestParser: AgenticModel.RequestParser<Grok.AiModel> = (\n  model,\n  messages,\n  tools,\n  tool_choice = \"auto\"\n) => {\n  const request: AiAdapter.Input<Grok.AiModel> = openaiRequestParser(\n    model as unknown as OpenAi.AiModel,\n    messages,\n    tools,\n    tool_choice\n  );\n\n  // Grok does not support strict mode Function Calling, so we need to disable it\n  request.tools = (request.tools || []).map((tool) => ({\n    ...tool,\n    function: {\n      ...tool.function,\n      strict: false,\n    },\n  }));\n\n  return request;\n};\n\n/**\n * Parse a response from OpenAI output to internal network messages.\n */\nexport const responseParser: AgenticModel.ResponseParser<Grok.AiModel> =\n  openaiResponseParser as unknown as AgenticModel.ResponseParser<Grok.AiModel>;\n","/**\n * AgentKit Streaming System\n *\n * This module provides automatic event streaming capabilities for AgentKit networks and agents.\n * It defines the event schema that matches the useAgent hook expectations and provides\n * streaming context management for transparent event publishing.\n */\n\nimport { type Inngest } from \"inngest\";\nimport { type GetStepTools } from \"inngest\";\nimport { type State, type StateData } from \"./state\";\nimport { z } from \"zod\";\n\n/**\n * Base interface for all streaming events\n */\nexport interface AgentMessageChunk {\n  /** The event name (e.g., \"run.started\", \"part.created\") */\n  event: string;\n  /** Event-specific data payload */\n  data: Record<string, unknown>;\n  /** When the event occurred (Unix timestamp) */\n  timestamp: number;\n  /** Monotonic sequence number for ordering events */\n  sequenceNumber: number;\n  /** Suggested Inngest step ID for optional developer use */\n  id: string;\n}\n\n/**\n * Canonical runtime schema for AgentKit streaming events.\n * Matches the AgentMessageChunk interface above.\n */\nexport const AgentMessageChunkSchema = z.object({\n  event: z.string(),\n  data: z.record(z.string(), z.any()),\n  timestamp: z.number(),\n  sequenceNumber: z.number(),\n  id: z.string(),\n});\n\n// =============================================================================\n// RUN LIFECYCLE EVENTS\n// =============================================================================\n\nexport interface RunStartedEvent extends AgentMessageChunk {\n  event: \"run.started\";\n  data: {\n    runId: string; // Unique identifier for this run\n    parentRunId?: string; // If this is a nested run (e.g., agent within network)\n    scope: \"network\" | \"agent\"; // Level of execution\n    name: string; // Name of the network or agent\n    messageId?: string; // Optional message context\n    threadId?: string; // Thread context\n    metadata?: Record<string, unknown>; // Additional context\n  };\n}\n\nexport interface RunCompletedEvent extends AgentMessageChunk {\n  event: \"run.completed\";\n  data: {\n    runId: string;\n    scope: \"network\" | \"agent\";\n    name: string;\n    messageId?: string; // Optional message context\n    result?: unknown; // Final result from the run\n    usage?: {\n      promptTokens: number;\n      completionTokens: number;\n      totalTokens: number;\n      thinkingTokens?: number; // For models with reasoning\n    };\n  };\n}\n\nexport interface RunFailedEvent extends AgentMessageChunk {\n  event: \"run.failed\";\n  data: {\n    runId: string;\n    scope: \"network\" | \"agent\";\n    name: string;\n    messageId?: string; // Optional message context\n    error: string;\n    recoverable: boolean;\n    metadata?: Record<string, unknown>;\n  };\n}\n\nexport interface RunInterruptedEvent extends AgentMessageChunk {\n  event: \"run.interrupted\";\n  data: {\n    runId: string;\n    scope: \"network\" | \"agent\";\n    name: string;\n    reason: \"max_tokens\" | \"user_cancellation\" | \"timeout\" | \"other\";\n    metadata?: Record<string, unknown>;\n  };\n}\n\n// =============================================================================\n// STEP LIFECYCLE EVENTS\n// =============================================================================\n\nexport interface StepStartedEvent extends AgentMessageChunk {\n  event: \"step.started\";\n  data: {\n    stepId: string; // Unique identifier for this step\n    runId: string; // Which run this step belongs to\n    description?: string; // Human-readable description\n    metadata?: Record<string, unknown>;\n  };\n}\n\nexport interface StepCompletedEvent extends AgentMessageChunk {\n  event: \"step.completed\";\n  data: {\n    stepId: string;\n    runId: string;\n    result?: unknown; // Step result if applicable\n    duration?: number; // Execution time in milliseconds\n  };\n}\n\nexport interface StepFailedEvent extends AgentMessageChunk {\n  event: \"step.failed\";\n  data: {\n    stepId: string;\n    runId: string;\n    error: string;\n    recoverable: boolean;\n    retryAttempt?: number;\n  };\n}\n\n// =============================================================================\n// PART LIFECYCLE EVENTS\n// =============================================================================\n\nexport interface PartCreatedEvent extends AgentMessageChunk {\n  event: \"part.created\";\n  data: {\n    partId: string; // Unique identifier for this part\n    runId: string; // Which run this part belongs to\n    messageId: string; // Which message this part belongs to\n    type:\n      | \"text\"\n      | \"tool-call\"\n      | \"tool-output\"\n      | \"reasoning\"\n      | \"data\"\n      | \"file\"\n      | \"refusal\";\n    metadata?: {\n      toolName?: string; // For tool-call parts\n      dataType?: string; // For data parts\n      mimeType?: string; // For file parts\n      agentName?: string; // For tracking which agent created this part\n    };\n  };\n}\n\nexport interface PartCompletedEvent extends AgentMessageChunk {\n  event: \"part.completed\";\n  data: {\n    partId: string;\n    runId: string;\n    messageId: string; // Which message this part belongs to\n    type: string;\n    finalContent: unknown; // The complete, aggregated content of this part\n    metadata?: {\n      toolName?: string; // For tool-call/tool-output parts\n      dataType?: string; // For data parts\n      mimeType?: string; // For file parts\n      agentName?: string; // For tracking which agent created this part\n    };\n  };\n}\n\nexport interface PartFailedEvent extends AgentMessageChunk {\n  event: \"part.failed\";\n  data: {\n    partId: string;\n    runId: string;\n    messageId: string; // Which message this part belongs to\n    type: string;\n    error: string;\n    recoverable: boolean;\n  };\n}\n\n// =============================================================================\n// CONTENT DELTA EVENTS\n// =============================================================================\n\nexport interface TextDeltaEvent extends AgentMessageChunk {\n  event: \"text.delta\";\n  data: {\n    partId: string; // Which part this delta belongs to\n    messageId: string; // Which message this delta belongs to\n    delta: string; // The text chunk\n  };\n}\n\nexport interface ToolCallArgumentsDeltaEvent extends AgentMessageChunk {\n  event: \"tool_call.arguments.delta\";\n  data: {\n    partId: string;\n    messageId: string; // Which message this delta belongs to\n    delta: string; // JSON string chunk\n    toolName?: string; // Included on first delta\n  };\n}\n\nexport interface ToolCallOutputDeltaEvent extends AgentMessageChunk {\n  event: \"tool_call.output.delta\";\n  data: {\n    partId: string;\n    messageId: string; // Which message this delta belongs to\n    delta: string; // Incremental tool output\n  };\n}\n\nexport interface ReasoningDeltaEvent extends AgentMessageChunk {\n  event: \"reasoning.delta\";\n  data: {\n    partId: string; // Which part this delta belongs to\n    messageId: string; // Which message this delta belongs to\n    delta: string; // The reasoning/thinking content chunk\n  };\n}\n\nexport interface DataDeltaEvent extends AgentMessageChunk {\n  event: \"data.delta\";\n  data: {\n    partId: string;\n    messageId: string; // Which message this delta belongs to\n    delta: unknown; // Incremental structured data\n  };\n}\n\n// =============================================================================\n// HUMAN-IN-THE-LOOP (HITL) EVENTS\n// =============================================================================\n\nexport interface HitlRequestedEvent extends AgentMessageChunk {\n  event: \"hitl.requested\";\n  data: {\n    requestId: string;\n    runId: string; // Which run is requesting approval\n    toolCalls: Array<{\n      partId: string; // The tool-call part that needs approval\n      toolName: string;\n      toolInput: unknown;\n    }>;\n    expiresAt: string; // ISO timestamp\n    metadata?: {\n      reason?: string; // Why approval is needed\n      riskLevel?: \"low\" | \"medium\" | \"high\";\n    };\n  };\n}\n\nexport interface HitlResolvedEvent extends AgentMessageChunk {\n  event: \"hitl.resolved\";\n  data: {\n    requestId: string;\n    runId: string;\n    resolution: \"approved\" | \"denied\" | \"partial\";\n    approvedTools?: string[]; // For partial approval\n    reason?: string;\n    resolvedBy: string; // User ID who resolved\n    resolvedAt: string; // ISO timestamp\n  };\n}\n\n// =============================================================================\n// METADATA AND CONTROL EVENTS\n// =============================================================================\n\nexport interface UsageUpdatedEvent extends AgentMessageChunk {\n  event: \"usage.updated\";\n  data: {\n    runId: string;\n    usage: {\n      promptTokens: number;\n      completionTokens: number;\n      totalTokens: number;\n      thinkingTokens?: number;\n    };\n    cumulative: boolean; // Whether this is cumulative or delta\n  };\n}\n\nexport interface MetadataUpdatedEvent extends AgentMessageChunk {\n  event: \"metadata.updated\";\n  data: {\n    runId: string;\n    metadata: Record<string, unknown>;\n    type: \"model_switch\" | \"parameter_change\" | \"context_update\" | \"other\";\n  };\n}\n\nexport interface StreamEndedEvent extends AgentMessageChunk {\n  event: \"stream.ended\";\n  data: {\n    scope: \"network\" | \"agent\";\n    messageId?: string; // Optional message context\n  };\n}\n\n// Legacy/generic error event for backward compatibility\nexport interface GenericErrorEvent extends AgentMessageChunk {\n  event: \"error\";\n  data: {\n    error: string;\n    agentId?: string;\n    recoverable?: boolean;\n    messageId?: string;\n  };\n}\n\n// =============================================================================\n// SEQUENCE COUNTER FOR SHARED STREAMING CONTEXTS\n// =============================================================================\n\n/**\n * A simple sequence counter that can be shared between streaming contexts\n * to ensure events are numbered correctly across related contexts\n */\nclass SequenceCounter {\n  private value: number = 0;\n\n  getNext(): number {\n    return this.value++;\n  }\n\n  current(): number {\n    return this.value;\n  }\n}\n\n// =============================================================================\n// STREAMING CONFIGURATION AND CONTEXT\n// =============================================================================\n\n/**\n * Public-facing streaming configuration interface\n */\nexport interface StreamingConfig {\n  /** Function to publish events to the client */\n  publish: (chunk: AgentMessageChunk) => Promise<void>;\n  /** When true, emit simulated chunked deltas; otherwise emit a single delta */\n  simulateChunking?: boolean;\n}\n\n/**\n * Internal streaming context that manages state and sequence numbers\n */\nexport class StreamingContext {\n  private publish: (chunk: AgentMessageChunk) => Promise<void>;\n  private sequenceCounter: SequenceCounter;\n  private debug: boolean;\n  private simulateChunking: boolean;\n\n  public readonly runId: string;\n  public readonly parentRunId?: string;\n  public readonly messageId: string;\n  public readonly threadId?: string;\n  public readonly userId?: string;\n  public readonly scope: \"network\" | \"agent\";\n\n  constructor(config: {\n    publish: (chunk: AgentMessageChunk) => Promise<void>;\n    runId: string;\n    parentRunId?: string;\n    messageId: string;\n    threadId?: string;\n    userId?: string;\n    scope: \"network\" | \"agent\";\n    sequenceCounter?: SequenceCounter;\n    debug?: boolean;\n    simulateChunking?: boolean;\n  }) {\n    this.publish = config.publish;\n    this.runId = config.runId;\n    this.parentRunId = config.parentRunId;\n    this.messageId = config.messageId;\n    this.threadId = config.threadId;\n    this.userId = config.userId;\n    this.scope = config.scope;\n    this.sequenceCounter = config.sequenceCounter || new SequenceCounter();\n    this.debug = config.debug ?? process.env.NODE_ENV === \"development\";\n    this.simulateChunking = config.simulateChunking ?? false;\n  }\n\n  /**\n   * Create a child streaming context for agent runs within network runs\n   */\n  createChildContext(agentRunId: string): StreamingContext {\n    return new StreamingContext({\n      publish: this.publish,\n      runId: agentRunId,\n      parentRunId: this.runId,\n      messageId: this.messageId,\n      threadId: this.threadId,\n      userId: this.userId,\n      scope: \"agent\",\n      sequenceCounter: this.sequenceCounter, // Share the same counter\n      debug: this.debug, // Inherit debug setting\n      simulateChunking: this.simulateChunking,\n    });\n  }\n\n  /**\n   * Create a context with different messageId but shared sequence counter\n   */\n  createContextWithSharedSequence(config: {\n    runId: string;\n    messageId: string;\n    scope: \"network\" | \"agent\";\n  }): StreamingContext {\n    return new StreamingContext({\n      publish: this.publish,\n      runId: config.runId,\n      parentRunId: this.runId,\n      messageId: config.messageId,\n      threadId: this.threadId,\n      userId: this.userId,\n      scope: config.scope,\n      sequenceCounter: this.sequenceCounter, // Share the same counter instance\n      debug: this.debug, // Inherit debug setting\n      simulateChunking: this.simulateChunking,\n    });\n  }\n\n  /**\n   * Extract context information from network state\n   */\n  static fromNetworkState(\n    networkState: State<StateData>,\n    config: {\n      publish: (chunk: AgentMessageChunk) => Promise<void>;\n      runId: string;\n      messageId: string;\n      scope: \"network\" | \"agent\";\n      debug?: boolean;\n      simulateChunking?: boolean;\n    }\n  ): StreamingContext {\n    const debug = config.debug ?? process.env.NODE_ENV === \"development\";\n    return new StreamingContext({\n      publish: config.publish,\n      runId: config.runId,\n      messageId: config.messageId,\n      threadId: networkState.threadId,\n      userId:\n        typeof (networkState.data as { userId?: unknown }).userId === \"string\"\n          ? ((networkState.data as { userId?: unknown }).userId as string)\n          : undefined,\n      scope: config.scope,\n      debug,\n      simulateChunking: config.simulateChunking ?? false,\n    });\n  }\n\n  /**\n   * Publish an event with automatic sequence numbering.\n   * Provides a stepId in the chunk for optional Inngest step wrapping by the developer.\n   */\n  async publishEvent(\n    event: Omit<AgentMessageChunk, \"timestamp\" | \"sequenceNumber\" | \"id\">\n  ): Promise<void> {\n    // Get the next sequence number from the shared counter\n    const sequenceNumber = this.sequenceCounter.getNext();\n\n    // Generate step ID with the sequence number\n    const stepId = this.generateStreamingStepId(event, sequenceNumber);\n\n    // Automatically enrich event data with threadId and userId if they exist\n    const enrichedData: Record<string, unknown> = { ...event.data };\n    if (this.threadId) {\n      enrichedData[\"threadId\"] = this.threadId;\n    }\n    if (this.userId) {\n      enrichedData[\"userId\"] = this.userId;\n    }\n\n    const chunk: AgentMessageChunk = {\n      ...event,\n      data: enrichedData,\n      timestamp: Date.now(),\n      sequenceNumber,\n      id: stepId,\n    };\n\n    try {\n      await this.publish(chunk);\n    } catch (err) {\n      // Swallow publishing errors to avoid breaking execution; best-effort streaming\n\n      console.warn(\n        \"[Streaming] Failed to publish event; continuing execution\",\n        {\n          error: err instanceof Error ? err.message : String(err),\n          event: chunk.event,\n          sequenceNumber: chunk.sequenceNumber,\n        }\n      );\n    }\n  }\n\n  /**\n   * Generate intelligent step IDs for streaming events\n   */\n  private generateStreamingStepId(\n    event: Omit<AgentMessageChunk, \"timestamp\" | \"sequenceNumber\" | \"id\">,\n    sequenceNumber: number\n  ): string {\n    return `publish-${sequenceNumber}:${event.event}`;\n  }\n\n  /**\n   * Generate a unique part ID for this streaming context\n   * OpenAI requires tool call IDs to be  40 characters\n   */\n  generatePartId(): string {\n    // Create shorter, OpenAI-compatible ID ( 40 chars)\n    // Format: \"tool_\" + shortened messageId + timestamp suffix + random\n    const shortMessageId = this.messageId.replace(/-/g, \"\").substring(0, 8); // 8 chars\n    const shortTimestamp = Date.now().toString().slice(-8); // Last 8 digits\n    const randomSuffix = Math.random().toString(36).substr(2, 6); // 6 chars\n\n    // Format: \"tool_\" (5) + shortMessageId (8) + \"_\" (1) + shortTimestamp (8) + \"_\" (1) + randomSuffix (6) = 29 chars\n    const partId = `tool_${shortMessageId}_${shortTimestamp}_${randomSuffix}`;\n    return partId;\n  }\n\n  /**\n   * Generate a unique step ID for this streaming context\n   */\n  generateStepId(baseName: string): string {\n    return `step_${baseName}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n  }\n\n  /** Returns whether simulated chunking is enabled for this context */\n  isSimulatedChunking(): boolean {\n    return this.simulateChunking;\n  }\n}\n\n/**\n * Union type of all possible streaming events\n */\nexport type StreamingEvent =\n  | RunStartedEvent\n  | RunCompletedEvent\n  | RunFailedEvent\n  | RunInterruptedEvent\n  | StepStartedEvent\n  | StepCompletedEvent\n  | StepFailedEvent\n  | PartCreatedEvent\n  | PartCompletedEvent\n  | PartFailedEvent\n  | TextDeltaEvent\n  | ToolCallArgumentsDeltaEvent\n  | ToolCallOutputDeltaEvent\n  | ReasoningDeltaEvent\n  | DataDeltaEvent\n  | HitlRequestedEvent\n  | HitlResolvedEvent\n  | UsageUpdatedEvent\n  | MetadataUpdatedEvent\n  | StreamEndedEvent\n  | GenericErrorEvent;\n\n/**\n * Type guard to check if an event is a specific type\n */\nexport function isEventType<T extends StreamingEvent>(\n  event: AgentMessageChunk,\n  eventType: T[\"event\"]\n): event is T {\n  return event.event === eventType;\n}\n\n/**\n * Utility to generate unique IDs\n */\nexport function generateId(): string {\n  const id = `${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n  return id;\n}\n\n// =============================================================================\n// STEP WRAPPER FOR TRANSPARENT EVENT PUBLISHING (Proxy-based)\n// =============================================================================\n\n/**\n * Helper function to create a StepWrapper if streaming context is available\n */\nexport function createStepWrapper(\n  originalStep: GetStepTools<Inngest.Any> | undefined,\n  context?: StreamingContext\n): GetStepTools<Inngest.Any> | undefined {\n  if (!context || !originalStep) {\n    return originalStep;\n  }\n\n  // Use a Proxy to dynamically wrap the step tools\n  return new Proxy(originalStep, {\n    get(target, prop, receiver) {\n      // If the property is one we want to wrap (e.g., 'run'), return our wrapped version.\n      if (prop === \"run\") {\n        return async <T>(stepId: string, fn: () => Promise<T>): Promise<T> => {\n          // Delegate to the original Inngest step.run while emitting streaming events\n          const originalRun = Reflect.get(\n            target,\n            \"run\",\n            receiver\n          ) as unknown as <R>(id: string, fn: () => Promise<R>) => Promise<R>;\n\n          // Do not publish streaming step events here to avoid nested step.* within Inngest steps\n          // Rely on the actual Inngest step.run for step visibility in the console\n          return originalRun(stepId, fn);\n        };\n      }\n\n      // For any other property, just reflect it from the original step object.\n      return Reflect.get(\n        target,\n        prop,\n        receiver\n      ) as unknown as GetStepTools<Inngest.Any>[keyof GetStepTools<Inngest.Any>];\n    },\n  });\n}\n","import { type NetworkRun } from \"./network\";\nimport { type State, type StateData } from \"./state\";\nimport { type AgentResult } from \"./types\";\nimport { type GetStepTools, type Inngest } from \"inngest\";\nimport { type MaybePromise, getStepTools } from \"./util\";\n\n/**\n * History configuration for managing conversation history in agents and networks.\n *\n * Provides hooks for creating threads, loading existing conversation history,\n * and persisting new results to storage. This enables persistent conversations\n * that can span multiple runs while maintaining context.\n *\n * @example\n * ```typescript\n * const history: HistoryConfig<MyStateType> = {\n *   createThread: async ({ state, input }) => {\n *     const threadId = await db.createThread(state.userId);\n *     return { threadId };\n *   },\n *   get: async ({ threadId }) => {\n *     return await db.getMessages(threadId);\n *   },\n *   appendResults: async ({ threadId, newResults, userMessage }) => {\n *     // Save user message first (if provided)\n *     if (userMessage) {\n *       await db.saveUserMessage(threadId, userMessage);\n *     }\n *     // Then save agent results\n *     await db.saveMessages(threadId, newResults);\n *   }\n * };\n * ```\n */\nexport interface HistoryConfig<T extends StateData> {\n  /**\n   * createThread is called to create a new conversation thread if no\n   * threadId is present in the state. It should return the new threadId.\n   *\n   * This hook is called during the initialization phase before any agents run,\n   * allowing you to create a new conversation thread in your database and\n   * return its identifier.\n   *\n   * @param ctx - Context containing state, input, and execution tools\n   * @returns Promise resolving to an object with the new threadId\n   */\n  createThread?: (\n    ctx: History.CreateThreadContext<T>\n  ) => MaybePromise<{ threadId: string }>;\n\n  /**\n   * get is called to load initial conversation history.\n   * If provided, any results passed to createState will be ignored in favor\n   * of the results returned by this function.\n   *\n   * This hook is called after thread initialization but before any agents run,\n   * allowing you to hydrate the conversation state with previous messages\n   * and context from your database.\n   *\n   * @param ctx - Context containing state, threadId, and execution tools\n   * @returns Promise resolving to an array of previous AgentResults\n   */\n  get?: (ctx: History.Context<T>) => Promise<AgentResult[]>;\n\n  /**\n   * appendUserMessage is called at the beginning of a run to persist the\n   * user's message immediately. This ensures user intent is captured even\n   * if the agent run fails, enabling a \"regenerate\" workflow.\n   *\n   * @param ctx - Context containing the user message with its canonical ID\n   * @returns Promise that resolves when the message is successfully saved\n   */\n  appendUserMessage?: (\n    ctx: History.Context<T> & {\n      userMessage: {\n        id: string; // The canonical, client-generated message ID\n        content: string;\n        role: \"user\";\n        timestamp: Date;\n      };\n    }\n  ) => Promise<void>;\n\n  /**\n   * appendResults is called to save new agent results to storage after a\n   * network or agent run completes. This receives only the new results that\n   * were generated during the current run.\n   *\n   * @param ctx - Context containing state, threadId, step, and new agent results\n   * @returns Promise that resolves when results are successfully saved\n   */\n  appendResults?: (\n    ctx: History.Context<T> & {\n      newResults: AgentResult[];\n    }\n  ) => Promise<void>;\n}\n\nexport namespace History {\n  /**\n   * Context provides access to the current state and execution context\n   * when history hooks are called.\n   *\n   * This context is passed to both `get` and `appendResults` hooks,\n   * providing all necessary information for loading and saving conversation data.\n   */\n  export type Context<T extends StateData> = {\n    /** The current state containing user data and conversation context */\n    state: State<T>;\n    /** The network run instance for accessing network-level information */\n    network: NetworkRun<T>;\n    /** Inngest step tools for durable execution (when running in Inngest context) */\n    step?: GetStepTools<Inngest.Any>;\n    /** The user's input for this conversation turn */\n    input: string;\n    /** The thread identifier for this conversation (available for get/appendResults hooks) */\n    threadId?: string;\n  };\n\n  /**\n   * CreateThreadContext provides access to the current state and execution context\n   * when the createThread hook is called. Note that threadId is not included since\n   * that's what we're creating, and network is optional since createThread can be\n   * called from both network and standalone agent contexts.\n   *\n   * This context is passed to the `createThread` hook when a new conversation\n   * thread needs to be created.\n   */\n  export type CreateThreadContext<T extends StateData> = {\n    /** The current state containing user data */\n    state: State<T>;\n    /** The user's input for this conversation turn */\n    input: string;\n    /** Inngest step tools for durable execution (when running in Inngest context) */\n    step?: GetStepTools<Inngest.Any>;\n    /** The network run instance (optional - may not be available in standalone agent context) */\n    network?: NetworkRun<T>;\n  };\n\n  /**\n   * Config is an alias for HistoryConfig for consistency with other namespaces\n   */\n  export type Config<T extends StateData> = HistoryConfig<T>;\n}\n\n/**\n * Base configuration for thread operation functions.\n *\n * Contains the common parameters needed by history utility functions\n * to perform thread operations like initialization, loading, and saving.\n */\nexport type ThreadOperationConfig<T extends StateData> = {\n  /** The current state containing conversation data and user context */\n  state: State<T>;\n  /** History configuration with hooks for thread operations */\n  history?: HistoryConfig<T>;\n  /** The user's input for this conversation turn */\n  input: string;\n  /** The network run instance (optional for standalone agent contexts) */\n  network?: NetworkRun<T>;\n};\n\n/**\n * Configuration for saveThreadToStorage function - extends base config with initialResultCount.\n *\n * The initialResultCount is used to determine which results are \"new\" and should be\n * persisted, versus which results were loaded from history and should not be duplicated.\n */\nexport type SaveThreadToStorageConfig<T extends StateData> =\n  ThreadOperationConfig<T> & {\n    /** The number of results that existed before this run started (used to identify new results) */\n    initialResultCount: number;\n  };\n\n/**\n * Handles thread initialization logic - creates new threads or auto-generates threadIds.\n *\n * This function is called at the beginning of agent/network runs to ensure a valid\n * thread context exists. It will:\n * 1. Create a new thread using the `createThread` hook if no threadId exists\n * 2. Auto-generate a threadId if `history.get` is configured but no threadId was provided\n * 3. Do nothing if a threadId already exists or no history configuration is provided\n *\n * @param config - Configuration containing state, history, input, and optional network\n * @returns Promise that resolves when thread initialization is complete\n *\n * @example\n * ```typescript\n * await initializeThread({\n *   state: myState,\n *   history: myHistoryConfig,\n *   input: userInput,\n *   network: networkRun\n * });\n * console.log(myState.threadId); // Now has a valid threadId\n * ```\n */\nexport async function initializeThread<T extends StateData>(\n  config: ThreadOperationConfig<T>\n): Promise<void> {\n  const { state, history, input, network } = config;\n  if (!history) return;\n\n  const step = await getStepTools();\n\n  // If a client provided a threadId, ensure it exists in storage by calling createThread.\n  // Adapters should upsert when a threadId already exists on state.\n  if (state.threadId && history.createThread) {\n    await history.createThread({\n      state,\n      network,\n      input,\n      step,\n    });\n    // Do not re-assign the threadId here. The state's threadId is the source of truth.\n    return;\n  }\n\n  if (!state.threadId && history.createThread) {\n    // Create a new thread using the provided createThread function\n    const { threadId } = await history.createThread({\n      state,\n      network,\n      input,\n      step,\n    });\n    state.threadId = threadId;\n  } else if (!state.threadId && history.get) {\n    // Auto-generate a threadId if history.get is configured but no threadId was provided\n    state.threadId = crypto.randomUUID();\n\n    // Create a thread record in the database to ensure it exists\n    // This prevents appendResults from failing when trying to save messages to a non-existent thread\n    if (history.createThread) {\n      await history.createThread({\n        state,\n        network,\n        input,\n        step,\n      });\n    }\n  }\n}\n\n/**\n * Loads conversation history from storage if conditions are met.\n *\n * This function retrieves previous conversation messages from storage and populates\n * the state with historical context. It will only load history if:\n * 1. A history.get hook is configured\n * 2. A threadId exists in the state\n * 3. The state doesn't already have results OR messages (to avoid overwriting client-provided data)\n *\n * When either results or messages are provided to createState, this enables client-authoritative\n * mode where the client maintains conversation state and sends it with each request.\n *\n * @param config - Configuration containing state, history, input, and optional network\n * @returns Promise that resolves when history loading is complete\n *\n * @example\n * ```typescript\n * await loadThreadFromStorage({\n *   state: myState,\n *   history: myHistoryConfig,\n *   input: userInput,\n *   network: networkRun\n * });\n * console.log(myState.results); // Now contains previous conversation messages\n * ```\n */\nexport async function loadThreadFromStorage<T extends StateData>(\n  config: ThreadOperationConfig<T>\n): Promise<void> {\n  const { state, history, input, network } = config;\n  if (\n    !history?.get ||\n    !state.threadId ||\n    state.results.length > 0 ||\n    state.messages.length > 0\n  ) {\n    return;\n  }\n\n  const step = await getStepTools();\n\n  const historyResults = await history.get({\n    state,\n    network: network!,\n    input,\n    step,\n    threadId: state.threadId,\n  });\n\n  // Replace any existing results with those from history\n  state.setResults(historyResults);\n}\n\n/**\n * Saves new conversation results to storage via history.appendResults.\n *\n * This function persists only the new AgentResults that were generated during\n * the current run, excluding any historical results that were loaded via `loadThreadFromStorage`.\n * This prevents duplication of messages in storage. Additionally, it passes the user's\n * input message to enable complete conversation history persistence.\n *\n * @param config - Configuration containing state, history, input, network, and initialResultCount\n * @returns Promise that resolves when results are successfully saved\n *\n * @example\n * ```typescript\n * const initialCount = state.results.length;\n * // ... run agents that add new results ...\n * await saveThreadToStorage({\n *   state: myState,\n *   history: myHistoryConfig,\n *   input: userInput,\n *   initialResultCount: initialCount,\n *   network: networkRun\n * });\n * ```\n */\nexport async function saveThreadToStorage<T extends StateData>(\n  config: SaveThreadToStorageConfig<T>\n): Promise<void> {\n  const { state, history, initialResultCount, network, input } = config;\n  if (!history?.appendResults) return;\n\n  const step = await getStepTools();\n  const newResults = state.getResultsFrom(initialResultCount);\n\n  await history.appendResults({\n    state,\n    network: network!,\n    step,\n    newResults,\n    input,\n    threadId: state.threadId,\n  });\n}\n"],"names":["randomUUID","z","z","requestParser","_a","toolChoice","z","responseParser","e","requestParser","responseParser","z","requestParser","_model","z","toolChoice","responseParser","requestParser","responseParser","requestParser","responseParser","requestParser","responseParser","z","z","z","randomUUID","next","agent"],"mappings":"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","ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14],"debugId":null}},
    {"offset": {"line": 2259, "column": 0}, "map": {"version":3,"sources":["file:///Users/amansatyawani/Desktop/website-builder/node_modules/.pnpm/%40inngest%2Bagent-kit%400.13.2_inngest%403.45.1_%40opentelemetry%2Bcore%402.2.0_%40opentelemetry%2Bapi%401_72b4b5017e99274ceeae5e0c8735609d/node_modules/%40inngest/agent-kit/src/models.ts"],"sourcesContent":["export { anthropic, gemini, openai, grok } from \"@inngest/ai\";\n"],"names":[],"mappings":";;;AAAA,SAAS,WAAW,QAAQ,QAAQ,YAAY","ignoreList":[0],"debugId":null}}]
}