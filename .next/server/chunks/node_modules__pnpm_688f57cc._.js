module.exports = {

"[project]/node_modules/.pnpm/inngest@3.45.1_@opentelemetry+core@2.2.0_@opentelemetry+api@1.9.0__express@4.21.2_next@_c75e0c332defb7a954d9a52cadcbb8f7/node_modules/inngest/_virtual/rolldown_runtime.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
//#region rolldown:runtime
__turbopack_context__.s({
    "__export": (()=>__export),
    "__require": (()=>__require)
});
var __defProp = Object.defineProperty;
var __export = (all)=>{
    let target = {};
    for(var name in all)__defProp(target, name, {
        get: all[name],
        enumerable: true
    });
    return target;
};
var __require = /* @__PURE__ */ ((x)=>("TURBOPACK compile-time truthy", 1) ? ("TURBOPACK member replacement", __turbopack_context__.z) : ("TURBOPACK unreachable", undefined))(function(x) {
    if ("TURBOPACK compile-time truthy", 1) return ("TURBOPACK member replacement", __turbopack_context__.z).apply(this, arguments);
    "TURBOPACK unreachable";
});
;
}}),
"[project]/node_modules/.pnpm/inngest@3.45.1_@opentelemetry+core@2.2.0_@opentelemetry+api@1.9.0__express@4.21.2_next@_c75e0c332defb7a954d9a52cadcbb8f7/node_modules/inngest/version.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
//#region src/version.ts
__turbopack_context__.s({
    "version": (()=>version)
});
const version = "3.45.1";
;
 //# sourceMappingURL=version.js.map
}}),
"[project]/node_modules/.pnpm/inngest@3.45.1_@opentelemetry+core@2.2.0_@opentelemetry+api@1.9.0__express@4.21.2_next@_c75e0c332defb7a954d9a52cadcbb8f7/node_modules/inngest/helpers/consts.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "ExecutionVersion": (()=>ExecutionVersion),
    "debugPrefix": (()=>debugPrefix),
    "defaultDevServerHost": (()=>defaultDevServerHost),
    "defaultInngestApiBaseUrl": (()=>defaultInngestApiBaseUrl),
    "defaultInngestEventBaseUrl": (()=>defaultInngestEventBaseUrl),
    "defaultMaxRetries": (()=>defaultMaxRetries),
    "dummyEventKey": (()=>dummyEventKey),
    "envKeys": (()=>envKeys),
    "forwardedHeaders": (()=>forwardedHeaders),
    "headerKeys": (()=>headerKeys),
    "internalEvents": (()=>internalEvents),
    "logPrefix": (()=>logPrefix),
    "probe": (()=>probe),
    "queryKeys": (()=>queryKeys),
    "syncKind": (()=>syncKind)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$chalk$40$4$2e$1$2e$2$2f$node_modules$2f$chalk$2f$source$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/chalk@4.1.2/node_modules/chalk/source/index.js [app-route] (ecmascript)");
;
//#region src/helpers/consts.ts
/**
* Keys for accessing query parameters included in requests from Inngest to run
* functions.
*
* Used internally to create handlers using `InngestCommHandler`, but can be
* imported to be used if creating a custom handler outside of the package.
*
* @public
*/ let queryKeys = /* @__PURE__ */ function(queryKeys$1) {
    queryKeys$1["DeployId"] = "deployId";
    queryKeys$1["FnId"] = "fnId";
    queryKeys$1["Probe"] = "probe";
    queryKeys$1["StepId"] = "stepId";
    return queryKeys$1;
}({});
let probe = /* @__PURE__ */ function(probe$1) {
    probe$1["Trust"] = "trust";
    return probe$1;
}({});
let envKeys = /* @__PURE__ */ function(envKeys$1) {
    envKeys$1["InngestSigningKey"] = "INNGEST_SIGNING_KEY";
    envKeys$1["InngestSigningKeyFallback"] = "INNGEST_SIGNING_KEY_FALLBACK";
    envKeys$1["InngestEventKey"] = "INNGEST_EVENT_KEY";
    /**
	* @deprecated Removed in v3. Use {@link InngestBaseUrl} instead.
	*/ envKeys$1["InngestDevServerUrl"] = "INNGEST_DEVSERVER_URL";
    envKeys$1["InngestEnvironment"] = "INNGEST_ENV";
    envKeys$1["InngestBaseUrl"] = "INNGEST_BASE_URL";
    envKeys$1["InngestEventApiBaseUrl"] = "INNGEST_EVENT_API_BASE_URL";
    envKeys$1["InngestApiBaseUrl"] = "INNGEST_API_BASE_URL";
    envKeys$1["InngestServeHost"] = "INNGEST_SERVE_HOST";
    envKeys$1["InngestServePath"] = "INNGEST_SERVE_PATH";
    envKeys$1["InngestLogLevel"] = "INNGEST_LOG_LEVEL";
    envKeys$1["InngestStreaming"] = "INNGEST_STREAMING";
    envKeys$1["InngestDevMode"] = "INNGEST_DEV";
    envKeys$1["InngestAllowInBandSync"] = "INNGEST_ALLOW_IN_BAND_SYNC";
    envKeys$1["InngestConnectMaxWorkerConcurrency"] = "INNGEST_CONNECT_MAX_WORKER_CONCURRENCY";
    /**
	* @deprecated It's unknown what this env var was used for, but we do not
	* provide explicit support for it. Prefer using `INNGEST_ENV` instead.
	*/ envKeys$1["BranchName"] = "BRANCH_NAME";
    /**
	* The git branch of the commit the deployment was triggered by. Example:
	* `improve-about-page`.
	*
	* {@link https://vercel.com/docs/concepts/projects/environment-variables/system-environment-variables#system-environment-variables}
	*/ envKeys$1["VercelBranch"] = "VERCEL_GIT_COMMIT_REF";
    /**
	* Expected to be `"1"` if defined.
	*/ envKeys$1["IsVercel"] = "VERCEL";
    /**
	* The branch name of the current deployment. May only be accessible at build
	* time, but included here just in case.
	*
	* {@link https://developers.cloudflare.com/pages/platform/build-configuration/#environment-variables}
	*/ envKeys$1["CloudflarePagesBranch"] = "CF_PAGES_BRANCH";
    /**
	* Expected to be `"1"` if defined.
	*/ envKeys$1["IsCloudflarePages"] = "CF_PAGES";
    /**
	* The branch name of the deployment from Git to Netlify, if available.
	*
	* {@link https://docs.netlify.com/configure-builds/environment-variables/#git-metadata}
	*/ envKeys$1["NetlifyBranch"] = "BRANCH";
    /**
	* Expected to be `"true"` if defined.
	*/ envKeys$1["IsNetlify"] = "NETLIFY";
    /**
	* The Git branch for a service or deploy.
	*
	* {@link https://render.com/docs/environment-variables#all-services}
	*/ envKeys$1["RenderBranch"] = "RENDER_GIT_BRANCH";
    /**
	* Expected to be `"true"` if defined.
	*/ envKeys$1["IsRender"] = "RENDER";
    /**
	* The branch that triggered the deployment. Example: `main`
	*
	* {@link https://docs.railway.app/develop/variables#railway-provided-variables}
	*/ envKeys$1["RailwayBranch"] = "RAILWAY_GIT_BRANCH";
    /**
	* The railway environment for the deployment. Example: `production`
	*
	* {@link https://docs.railway.app/develop/variables#railway-provided-variables}
	*/ envKeys$1["RailwayEnvironment"] = "RAILWAY_ENVIRONMENT";
    envKeys$1["VercelEnvKey"] = "VERCEL_ENV";
    envKeys$1["OpenAiApiKey"] = "OPENAI_API_KEY";
    envKeys$1["GeminiApiKey"] = "GEMINI_API_KEY";
    envKeys$1["AnthropicApiKey"] = "ANTHROPIC_API_KEY";
    return envKeys$1;
}({});
/**
* Keys for accessing headers included in requests from Inngest to run
* functions.
*
* Used internally to create handlers using `InngestCommHandler`, but can be
* imported to be used if creating a custom handler outside of the package.
*
* @public
*/ let headerKeys = /* @__PURE__ */ function(headerKeys$1) {
    headerKeys$1["ContentType"] = "content-type";
    headerKeys$1["Host"] = "host";
    headerKeys$1["ForwardedFor"] = "x-forwarded-for";
    headerKeys$1["RealIp"] = "x-real-ip";
    headerKeys$1["Location"] = "location";
    headerKeys$1["ContentLength"] = "content-length";
    headerKeys$1["Signature"] = "x-inngest-signature";
    headerKeys$1["SdkVersion"] = "x-inngest-sdk";
    headerKeys$1["Environment"] = "x-inngest-env";
    headerKeys$1["Platform"] = "x-inngest-platform";
    headerKeys$1["Framework"] = "x-inngest-framework";
    headerKeys$1["NoRetry"] = "x-inngest-no-retry";
    headerKeys$1["RequestVersion"] = "x-inngest-req-version";
    headerKeys$1["RetryAfter"] = "retry-after";
    headerKeys$1["InngestServerKind"] = "x-inngest-server-kind";
    headerKeys$1["InngestExpectedServerKind"] = "x-inngest-expected-server-kind";
    headerKeys$1["InngestSyncKind"] = "x-inngest-sync-kind";
    headerKeys$1["EventIdSeed"] = "x-inngest-event-id-seed";
    headerKeys$1["TraceParent"] = "traceparent";
    headerKeys$1["TraceState"] = "tracestate";
    headerKeys$1["InngestRunId"] = "x-run-id";
    return headerKeys$1;
}({});
/**
* Headers that are forwarded from the original request when an Inngest function
* is invoked.
*/ const forwardedHeaders = [
    headerKeys.TraceParent,
    headerKeys.TraceState
];
const defaultInngestApiBaseUrl = "https://api.inngest.com/";
const defaultInngestEventBaseUrl = "https://inn.gs/";
const defaultDevServerHost = "http://localhost:8288/";
/**
* Events that Inngest may send internally that can be used to trigger
* functions.
*
* @public
*/ let internalEvents = /* @__PURE__ */ function(internalEvents$1) {
    /**
	* A function has failed after exhausting all available retries. This event
	* will contain the original event and the error that caused the failure.
	*/ internalEvents$1["FunctionFailed"] = "inngest/function.failed";
    internalEvents$1["FunctionInvoked"] = "inngest/function.invoked";
    internalEvents$1["FunctionFinished"] = "inngest/function.finished";
    internalEvents$1["FunctionCancelled"] = "inngest/function.cancelled";
    internalEvents$1["ScheduledTimer"] = "inngest/scheduled.timer";
    return internalEvents$1;
}({});
const logPrefix = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$chalk$40$4$2e$1$2e$2$2f$node_modules$2f$chalk$2f$source$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].magenta.bold("[Inngest]");
const debugPrefix = "inngest";
const dummyEventKey = "NO_EVENT_KEY_SET";
let syncKind = /* @__PURE__ */ function(syncKind$1) {
    syncKind$1["InBand"] = "in_band";
    syncKind$1["OutOfBand"] = "out_of_band";
    return syncKind$1;
}({});
/**
* The execution models the SDK is aware of.
*
* This is used in a number of places to ensure all execution versions are
* accounted for for a given operation.
*/ let ExecutionVersion = /* @__PURE__ */ function(ExecutionVersion$1) {
    /**
	* Very legacy, initial version of the executor. Uses hashed op objects and
	* `pos` to determine the order of execution and which ops to run.
	*
	* Very stubborn about determinism.
	*/ ExecutionVersion$1[ExecutionVersion$1["V0"] = 0] = "V0";
    /**
	* Uses a more flexible approach to execution and is more lenient about
	* determinism, allowing non-step async actions and non-determinism.
	*
	* Nowhere near as stubborn about determinism and so can silently migrate
	* between versions after bug fixes.
	*/ ExecutionVersion$1[ExecutionVersion$1["V1"] = 1] = "V1";
    /**
	* Identical to V1, but allows the Executor to optimize parallel calls, hugely
	* reducing traffic going to/from the SDK.
	*/ ExecutionVersion$1[ExecutionVersion$1["V2"] = 2] = "V2";
    return ExecutionVersion$1;
}({});
/**
* Default maximum number of retries for function/step executions.
*/ const defaultMaxRetries = 3;
;
 //# sourceMappingURL=consts.js.map
}}),
"[project]/node_modules/.pnpm/inngest@3.45.1_@opentelemetry+core@2.2.0_@opentelemetry+api@1.9.0__express@4.21.2_next@_c75e0c332defb7a954d9a52cadcbb8f7/node_modules/inngest/helpers/strings.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "hashEventKey": (()=>hashEventKey),
    "hashSigningKey": (()=>hashSigningKey),
    "slugify": (()=>slugify),
    "stringify": (()=>stringify$1),
    "stringifyUnknown": (()=>stringifyUnknown),
    "timeStr": (()=>timeStr)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$json$2d$stringify$2d$safe$40$5$2e$0$2e$1$2f$node_modules$2f$json$2d$stringify$2d$safe$2f$stringify$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/json-stringify-safe@5.0.1/node_modules/json-stringify-safe/stringify.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$hash$2e$js$40$1$2e$1$2e$7$2f$node_modules$2f$hash$2e$js$2f$lib$2f$hash$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$ms$40$2$2e$1$2e$3$2f$node_modules$2f$ms$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/ms@2.1.3/node_modules/ms/index.js [app-route] (ecmascript)");
;
;
;
//#region src/helpers/strings.ts
const { sha256 } = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$hash$2e$js$40$1$2e$1$2e$7$2f$node_modules$2f$hash$2e$js$2f$lib$2f$hash$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"];
/**
* Safely `JSON.stringify()` an `input`, handling circular refernences and
* removing `BigInt` values.
*/ const stringify$1 = (input)=>{
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$json$2d$stringify$2d$safe$40$5$2e$0$2e$1$2f$node_modules$2f$json$2d$stringify$2d$safe$2f$stringify$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(input, (_key, value)=>{
        if (typeof value !== "bigint") return value;
    });
};
/**
* Returns a slugified string used to generate consistent IDs.
*
* This can be used to generate a consistent ID for a function when migrating
* from v2 to v3 of the SDK.
*
* @public
*/ const slugify = (str)=>{
    const join = "-";
    return str.toLowerCase().replace(/[^a-z0-9-]+/g, join).replace(/-+/g, join).split(join).filter(Boolean).join(join);
};
const second = 1 * 1e3;
const minute = second * 60;
const hour = minute * 60;
const day = hour * 24;
/**
* A collection of periods in milliseconds and their suffixes used when creating
* time strings.
*/ const periods = [
    [
        "w",
        day * 7
    ],
    [
        "d",
        day
    ],
    [
        "h",
        hour
    ],
    [
        "m",
        minute
    ],
    [
        "s",
        second
    ]
];
/**
* Convert a given `Date`, `number`, or `ms`-compatible `string` to a
* Inngest sleep-compatible time string (e.g. `"1d"` or `"2h3010s"`).
*
* Can optionally provide a `now` date to use as the base for the calculation,
* otherwise a new date will be created on invocation.
*/ const timeStr = (input)=>{
    if (input instanceof Date) return input.toISOString();
    const milliseconds = typeof input === "string" ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$ms$40$2$2e$1$2e$3$2f$node_modules$2f$ms$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(input) : input;
    const [, timeStr$1] = periods.reduce(([num, str], [suffix, period])=>{
        const numPeriods = Math.floor(num / period);
        if (numPeriods > 0) return [
            num % period,
            `${str}${numPeriods}${suffix}`
        ];
        return [
            num,
            str
        ];
    }, [
        milliseconds,
        ""
    ]);
    return timeStr$1;
};
/**
* Given an unknown input, stringify it if it's a boolean, a number, or a
* string, else return `undefined`.
*/ const stringifyUnknown = (input)=>{
    if (typeof input === "boolean" || typeof input === "number" || typeof input === "string") return input.toString();
};
const hashEventKey = (eventKey)=>{
    return sha256().update(eventKey).digest("hex");
};
const hashSigningKey = (signingKey)=>{
    if (!signingKey) return "";
    const prefix = signingKey.match(/^signkey-[\w]+-/)?.shift() || "";
    const key = signingKey.replace(/^signkey-[\w]+-/, "");
    return `${prefix}${sha256().update(key, "hex").digest("hex")}`;
};
;
 //# sourceMappingURL=strings.js.map
}}),
"[project]/node_modules/.pnpm/inngest@3.45.1_@opentelemetry+core@2.2.0_@opentelemetry+api@1.9.0__express@4.21.2_next@_c75e0c332defb7a954d9a52cadcbb8f7/node_modules/inngest/helpers/env.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "Mode": (()=>Mode),
    "allProcessEnv": (()=>allProcessEnv),
    "devServerHost": (()=>devServerHost),
    "getEnvironmentName": (()=>getEnvironmentName),
    "getFetch": (()=>getFetch),
    "getMode": (()=>getMode),
    "getPlatformName": (()=>getPlatformName),
    "getResponse": (()=>getResponse),
    "inngestHeaders": (()=>inngestHeaders),
    "parseAsBoolean": (()=>parseAsBoolean),
    "platformSupportsStreaming": (()=>platformSupportsStreaming),
    "processEnv": (()=>processEnv)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$_virtual$2f$rolldown_runtime$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/inngest@3.45.1_@opentelemetry+core@2.2.0_@opentelemetry+api@1.9.0__express@4.21.2_next@_c75e0c332defb7a954d9a52cadcbb8f7/node_modules/inngest/_virtual/rolldown_runtime.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$version$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/inngest@3.45.1_@opentelemetry+core@2.2.0_@opentelemetry+api@1.9.0__express@4.21.2_next@_c75e0c332defb7a954d9a52cadcbb8f7/node_modules/inngest/version.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/inngest@3.45.1_@opentelemetry+core@2.2.0_@opentelemetry+api@1.9.0__express@4.21.2_next@_c75e0c332defb7a954d9a52cadcbb8f7/node_modules/inngest/helpers/consts.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$strings$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/inngest@3.45.1_@opentelemetry+core@2.2.0_@opentelemetry+api@1.9.0__express@4.21.2_next@_c75e0c332defb7a954d9a52cadcbb8f7/node_modules/inngest/helpers/strings.js [app-route] (ecmascript)");
;
;
;
;
//#region src/helpers/env.ts
/**
* devServerHost returns the dev server host by searching for the INNGEST_DEVSERVER_URL
* environment variable (plus project prefixces for eg. react, such as REACT_APP_INNGEST_DEVSERVER_URL).
*
* If not found this returns undefined, indicating that the env var has not been set.
*
* @example devServerHost()
*/ const devServerHost = (env = allProcessEnv())=>{
    const prefixes = [
        "REACT_APP_",
        "NEXT_PUBLIC_"
    ];
    return [
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["envKeys"].InngestBaseUrl,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["envKeys"].InngestDevMode
    ].flatMap((key)=>{
        return prefixes.map((prefix)=>{
            return env[prefix + key];
        });
    }).find((v)=>{
        if (!v) return;
        try {
            return Boolean(new URL(v));
        } catch  {}
    });
};
const checkFns = ((checks)=>checks)({
    equals: (actual, expected)=>actual === expected,
    "starts with": (actual, expected)=>expected ? actual?.startsWith(expected) ?? false : false,
    "is truthy": (actual)=>Boolean(actual),
    "is truthy but not": (actual, expected)=>Boolean(actual) && actual !== expected
});
const prodChecks = [
    [
        "CF_PAGES",
        "equals",
        "1"
    ],
    [
        "CONTEXT",
        "starts with",
        "prod"
    ],
    [
        "ENVIRONMENT",
        "starts with",
        "prod"
    ],
    [
        "NODE_ENV",
        "starts with",
        "prod"
    ],
    [
        "VERCEL_ENV",
        "starts with",
        "prod"
    ],
    [
        "DENO_DEPLOYMENT_ID",
        "is truthy"
    ],
    [
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["envKeys"].VercelEnvKey,
        "is truthy but not",
        "development"
    ],
    [
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["envKeys"].IsNetlify,
        "is truthy"
    ],
    [
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["envKeys"].IsRender,
        "is truthy"
    ],
    [
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["envKeys"].RailwayBranch,
        "is truthy"
    ],
    [
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["envKeys"].IsCloudflarePages,
        "is truthy"
    ]
];
var Mode = class {
    type;
    /**
	* Whether the mode was explicitly set, or inferred from other sources.
	*/ isExplicit;
    explicitDevUrl;
    env;
    constructor({ type, isExplicit, explicitDevUrl, env = allProcessEnv() }){
        this.env = env;
        this.type = type;
        this.isExplicit = isExplicit || Boolean(explicitDevUrl);
        this.explicitDevUrl = explicitDevUrl;
    }
    get isDev() {
        return this.type === "dev";
    }
    get isCloud() {
        return this.type === "cloud";
    }
    get isInferred() {
        return !this.isExplicit;
    }
    /**
	* If we are explicitly in a particular mode, retrieve the URL that we are
	* sure we should be using, not considering any environment variables or other
	* influences.
	*/ getExplicitUrl(defaultCloudUrl) {
        if (!this.isExplicit) return;
        if (this.explicitDevUrl) return this.explicitDevUrl.href;
        if (this.isCloud) return defaultCloudUrl;
        if (this.isDev) return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["defaultDevServerHost"];
    }
};
/**
* Returns the mode of the current environment, based off of either passed
* environment variables or `process.env`, or explicit settings.
*/ const getMode = ({ env = allProcessEnv(), client, explicitMode } = {})=>{
    if (explicitMode) return new Mode({
        type: explicitMode,
        isExplicit: true,
        env
    });
    if (client?.["mode"].isExplicit) return client["mode"];
    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["envKeys"].InngestDevMode in env) {
        if (typeof env[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["envKeys"].InngestDevMode] === "string") try {
            return new Mode({
                type: "dev",
                isExplicit: true,
                explicitDevUrl: new URL(env[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["envKeys"].InngestDevMode]),
                env
            });
        } catch  {}
        const envIsDev = parseAsBoolean(env[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["envKeys"].InngestDevMode]);
        if (typeof envIsDev === "boolean") return new Mode({
            type: envIsDev ? "dev" : "cloud",
            isExplicit: true,
            env
        });
    }
    return new Mode({
        type: prodChecks.some(([key, checkKey, expected])=>{
            return checkFns[checkKey]((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$strings$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["stringifyUnknown"])(env[key]), expected);
        }) ? "cloud" : "dev",
        isExplicit: false,
        env
    });
};
/**
* getEnvironmentName returns the suspected branch name for this environment by
* searching through a set of common environment variables.
*
* This could be used to determine if we're on a branch deploy or not, though it
* should be noted that we don't know if this is the default branch or not.
*/ const getEnvironmentName = (env = allProcessEnv())=>{
    /**
	* Order is important; more than one of these env vars may be set, so ensure
	* that we check the most specific, most reliable env vars first.
	*/ return env[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["envKeys"].InngestEnvironment] || env[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["envKeys"].BranchName] || env[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["envKeys"].VercelBranch] || env[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["envKeys"].NetlifyBranch] || env[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["envKeys"].CloudflarePagesBranch] || env[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["envKeys"].RenderBranch] || env[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["envKeys"].RailwayBranch];
};
const processEnv = (key)=>{
    return allProcessEnv()[key];
};
/**
* allProcessEnv returns the current process environment variables, or an empty
* object if they cannot be read, making sure we support environments other than
* Node such as Deno, too.
*
* Using this ensures we don't dangerously access `process.env` in environments
* where it may not be defined, such as Deno or the browser.
*/ const allProcessEnv = ()=>{
    try {
        if ("TURBOPACK compile-time truthy", 1) return process.env;
    } catch (_err) {}
    try {
        const env = Deno.env.toObject();
        if (env) return env;
    } catch (_err) {}
    try {
        const env = Netlify.env.toObject();
        if (env) return env;
    } catch (_err) {}
    return {};
};
/**
* Generate a standardised set of headers based on input and environment
* variables.
*
*
*/ const inngestHeaders = (opts)=>{
    const sdkVersion = `inngest-js:v${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$version$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["version"]}`;
    const headers = {
        "Content-Type": "application/json",
        "User-Agent": sdkVersion,
        [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["headerKeys"].SdkVersion]: sdkVersion
    };
    if (opts?.framework) headers[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["headerKeys"].Framework] = opts.framework;
    if (opts?.expectedServerKind) headers[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["headerKeys"].InngestExpectedServerKind] = opts.expectedServerKind;
    const env = {
        ...allProcessEnv(),
        ...opts?.env
    };
    const inngestEnv = opts?.inngestEnv || getEnvironmentName(env);
    if (inngestEnv) headers[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["headerKeys"].Environment] = inngestEnv;
    const platform = getPlatformName(env);
    if (platform) headers[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["headerKeys"].Platform] = platform;
    return {
        ...headers,
        ...opts?.client?.["headers"],
        ...opts?.extras
    };
};
/**
* A set of checks that, given an environment, will return `true` if the current
* environment is running on the platform with the given name.
*/ const platformChecks = {
    vercel: (env)=>env[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["envKeys"].IsVercel] === "1" || typeof EdgeRuntime === "string",
    netlify: (env)=>env[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["envKeys"].IsNetlify] === "true",
    "cloudflare-pages": (env)=>env[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["envKeys"].IsCloudflarePages] === "1",
    render: (env)=>env[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["envKeys"].IsRender] === "true",
    railway: (env)=>Boolean(env[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["envKeys"].RailwayEnvironment])
};
/**
* A set of checks that, given an environment, will return `true` if the current
* environment and platform supports streaming responses back to Inngest.
*
* Streaming capability is both framework and platform-based. Frameworks are
* supported in serve handlers, and platforms are checked here.
*
* As such, this record declares which platforms we explicitly support for
* streaming and is used by {@link platformSupportsStreaming}.
*/ const streamingChecks = {
    vercel: (_framework, _env)=>typeof EdgeRuntime === "string",
    "cloudflare-pages": ()=>true
};
const getPlatformName = (env)=>{
    return Object.keys(platformChecks).find((key)=>{
        return platformChecks[key](env);
    });
};
/**
* Returns `true` if we believe the current environment supports streaming
* responses back to Inngest.
*
* We run a check directly related to the platform we believe we're running on,
* usually based on environment variables.
*/ const platformSupportsStreaming = (framework, env = allProcessEnv())=>{
    return streamingChecks[getPlatformName(env)]?.(framework, env) ?? false;
};
/**
* A unique symbol used to mark a custom fetch implementation. We wrap the
* implementations to provide some extra control when handling errors.
*/ const CUSTOM_FETCH_MARKER = Symbol("Custom fetch implementation");
/**
* Given a potential fetch function, return the fetch function to use based on
* this and the environment.
*/ const getFetch = (givenFetch)=>{
    /**
	* If we've explicitly been given a fetch function, use that.
	*/ if (givenFetch) {
        if (CUSTOM_FETCH_MARKER in givenFetch) return givenFetch;
        /**
		* We wrap the given fetch function to provide some extra control when
		* handling errors.
		*/ const customFetch = async (...args)=>{
            try {
                return await givenFetch(...args);
            } catch (err) {
                /**
				* Capture warnings that are not simple fetch failures and highlight
				* them for the user.
				*
				* We also use this opportunity to log the causing error, as code higher
				* up the stack will likely abstract this.
				*/ if (!(err instanceof Error) || !err.message?.startsWith("fetch failed")) {
                    console.warn("A request failed when using a custom fetch implementation; this may be a misconfiguration. Make sure that your fetch client is correctly bound to the global scope.");
                    console.error(err);
                }
                throw err;
            }
        };
        /**
		* Mark the custom fetch implementation so that we can identify it later, in
		* addition to adding some runtime properties to it to make it seem as much
		* like the original fetch as possible.
		*/ Object.defineProperties(customFetch, {
            [CUSTOM_FETCH_MARKER]: {},
            name: {
                value: givenFetch.name
            },
            length: {
                value: givenFetch.length
            }
        });
        return customFetch;
    }
    /**
	* Browser or Node 18+
	*/ try {
        if (typeof globalThis !== "undefined" && "fetch" in globalThis) return fetch.bind(globalThis);
    } catch (_err) {}
    /**
	* Existing polyfilled fetch
	*/ if (typeof fetch !== "undefined") return fetch;
    /**
	* Environments where fetch cannot be found and must be polyfilled
	*/ return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$_virtual$2f$rolldown_runtime$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["__require"])("cross-fetch");
};
/**
* If `Response` isn't included in this environment, it's probably an earlier
* Node env that isn't already polyfilling. This function returns either the
* native `Response` or a polyfilled one.
*/ const getResponse = ()=>{
    if (typeof Response !== "undefined") return Response;
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$_virtual$2f$rolldown_runtime$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["__require"])("cross-fetch").Response;
};
/**
* Given an unknown value, try to parse it as a `boolean`. Useful for parsing
* environment variables that could be a selection of different values such as
* `"true"`, `"1"`.
*
* If the value could not be confidently parsed as a `boolean` or was seen to be
* `undefined`, this function returns `undefined`.
*/ const parseAsBoolean = (value)=>{
    if (typeof value === "boolean") return value;
    if (typeof value === "number") return Boolean(value);
    if (typeof value === "string") {
        const trimmed = value.trim().toLowerCase();
        if (trimmed === "undefined") return;
        if ([
            "true",
            "1"
        ].includes(trimmed)) return true;
        return false;
    }
};
;
 //# sourceMappingURL=env.js.map
}}),
"[project]/node_modules/.pnpm/inngest@3.45.1_@opentelemetry+core@2.2.0_@opentelemetry+api@1.9.0__express@4.21.2_next@_c75e0c332defb7a954d9a52cadcbb8f7/node_modules/inngest/components/execution/als.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
//#region src/components/execution/als.ts
/**
* A local-only symbol used as a key in global state to store the async local
* storage instance.
*/ __turbopack_context__.s({
    "getAsyncCtx": (()=>getAsyncCtx),
    "getAsyncLocalStorage": (()=>getAsyncLocalStorage)
});
const alsSymbol = Symbol.for("inngest:als");
/**
* Retrieve the async context for the current execution.
*/ const getAsyncCtx = async ()=>{
    return getAsyncLocalStorage().then((als)=>als.getStore());
};
/**
* Get a singleton instance of `AsyncLocalStorage` used to store and retrieve
* async context for the current execution.
*/ const getAsyncLocalStorage = async ()=>{
    globalThis[alsSymbol] ??= new Promise(async (resolve)=>{
        try {
            const { AsyncLocalStorage } = await __turbopack_context__.r("[externals]/node:async_hooks [external] (node:async_hooks, cjs, async loader)")(__turbopack_context__.i);
            resolve(new AsyncLocalStorage());
        } catch (_err) {
            console.warn("node:async_hooks is not supported in this runtime. Experimental async context is disabled.");
            resolve({
                getStore: ()=>void 0,
                run: (_, fn)=>fn()
            });
        }
    });
    return globalThis[alsSymbol];
};
;
 //# sourceMappingURL=als.js.map
}}),
"[project]/node_modules/.pnpm/inngest@3.45.1_@opentelemetry+core@2.2.0_@opentelemetry+api@1.9.0__express@4.21.2_next@_c75e0c332defb7a954d9a52cadcbb8f7/node_modules/inngest/types.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "AsyncResponseType": (()=>AsyncResponseType),
    "StepMode": (()=>StepMode),
    "StepOpCode": (()=>StepOpCode),
    "err": (()=>err),
    "functionConfigSchema": (()=>functionConfigSchema),
    "inBandSyncRequestBodySchema": (()=>inBandSyncRequestBodySchema),
    "incomingOpSchema": (()=>incomingOpSchema),
    "jsonErrorSchema": (()=>jsonErrorSchema),
    "logLevels": (()=>logLevels),
    "ok": (()=>ok),
    "sendEventResponseSchema": (()=>sendEventResponseSchema),
    "types_exports": (()=>types_exports)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$_virtual$2f$rolldown_runtime$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/inngest@3.45.1_@opentelemetry+core@2.2.0_@opentelemetry+api@1.9.0__express@4.21.2_next@_c75e0c332defb7a954d9a52cadcbb8f7/node_modules/inngest/_virtual/rolldown_runtime.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/zod@3.25.76/node_modules/zod/v3/external.js [app-route] (ecmascript) <export * as z>");
;
;
//#region src/types.ts
/**
* Internal types and schemas used throughout the Inngest SDK.
*
* Note that types intended to be imported and utilized in userland code will be
* exported from the main entrypoint of the SDK, `inngest`; importing types
* directly from this file may result in breaking changes in non-major bumps as
* only those exported from `inngest` are considered stable.
*
* @module
*/ var types_exports = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$_virtual$2f$rolldown_runtime$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["__export"])({
    AsyncResponseType: ()=>AsyncResponseType,
    StepMode: ()=>StepMode,
    StepOpCode: ()=>StepOpCode,
    err: ()=>err,
    functionConfigSchema: ()=>functionConfigSchema,
    inBandSyncRequestBodySchema: ()=>inBandSyncRequestBodySchema,
    incomingOpSchema: ()=>incomingOpSchema,
    jsonErrorSchema: ()=>jsonErrorSchema,
    logLevels: ()=>logLevels,
    ok: ()=>ok,
    sendEventResponseSchema: ()=>sendEventResponseSchema
});
const baseJsonErrorSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
    name: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().trim().optional(),
    error: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().trim().optional(),
    message: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().trim().optional(),
    stack: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().trim().optional()
});
const maybeJsonErrorSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].lazy(()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
        name: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().trim(),
        message: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().trim(),
        stack: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().trim().optional(),
        cause: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].union([
            maybeJsonErrorSchema,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].unknown()
        ]).optional()
    }));
const jsonErrorSchema = baseJsonErrorSchema.extend({
    cause: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].union([
        maybeJsonErrorSchema,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].unknown()
    ]).optional()
}).passthrough().catch({}).transform((val)=>{
    return {
        ...val,
        name: val.name || "Error",
        message: val.message || val.error || "Unknown error",
        stack: val.stack
    };
});
/**
* Unique codes for the different types of operation that can be sent to Inngest
* from SDK step functions.
*/ let StepOpCode = /* @__PURE__ */ function(StepOpCode$1) {
    StepOpCode$1["WaitForSignal"] = "WaitForSignal";
    StepOpCode$1["WaitForEvent"] = "WaitForEvent";
    /**
	* Legacy equivalent to `"StepRun"`. Has mixed data wrapping (e.g. `data` or
	* `data.data` depending on SDK version), so this is phased out in favour of
	* `"StepRun"`, which never wraps.
	*
	* Note that it is still used for v0 executions for backwards compatibility.
	*
	* @deprecated Only used for v0 executions; use `"StepRun"` instead.
	*/ StepOpCode$1["Step"] = "Step";
    StepOpCode$1["StepRun"] = "StepRun";
    StepOpCode$1["StepError"] = "StepError";
    StepOpCode$1["StepFailed"] = "StepFailed";
    StepOpCode$1["StepPlanned"] = "StepPlanned";
    StepOpCode$1["Sleep"] = "Sleep";
    /**
	* Used to signify that the executor has requested that a step run, but we
	* could not find that step.
	*
	* This is likely indicative that a step was renamed or removed from the
	* function.
	*/ StepOpCode$1["StepNotFound"] = "StepNotFound";
    StepOpCode$1["InvokeFunction"] = "InvokeFunction";
    StepOpCode$1["AiGateway"] = "AIGateway";
    StepOpCode$1["Gateway"] = "Gateway";
    StepOpCode$1["RunComplete"] = "RunComplete";
    return StepOpCode$1;
}({});
/**
* StepModes are used to specify how the SDK should execute a function.
*/ let StepMode = /* @__PURE__ */ function(StepMode$1) {
    /**
	* A synchronous method of execution, where steps are executed immediately and
	* their results are "checkpointed" back to Inngest in real-time.
	*/ StepMode$1["Sync"] = "sync";
    /**
	* The traditional, background method of execution, where all steps are queued
	* and executed asynchronously and always triggered by Inngest.
	*/ StepMode$1["Async"] = "async";
    return StepMode$1;
}({});
/**
* The type of response you wish to return to an API endpoint when using steps
* within it and we must transition to {@link StepMode.Async}.
*
* In most cases, this defaults to {@link AsyncResponseType.Redirect}.
*/ let AsyncResponseType = /* @__PURE__ */ function(AsyncResponseType$1) {
    /**
	* When switching to {@link StepMode.Async}, respond with a 302 redirect which
	* will end the request once the run has completed asynchronously in the
	* background.
	*/ AsyncResponseType$1["Redirect"] = "redirect";
    /**
	* When switching to {@link StepMode.Async}, respond with a token and run ID
	* which can be used to poll for the status of the run.
	*/ AsyncResponseType$1["Token"] = "token";
    return AsyncResponseType$1;
/**
	* TODO Comment
	*/ }({});
const incomingOpSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
    id: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().min(1),
    data: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].any().optional(),
    error: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].any().optional(),
    input: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].any().optional()
});
const sendEventResponseSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
    ids: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].array(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string()).default([]),
    status: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].number().default(0),
    error: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().optional()
});
/**
* A set of log levels that can be used to control the amount of logging output
* from various parts of the Inngest library.
*
* @public
*/ const logLevels = [
    "fatal",
    "error",
    "warn",
    "info",
    "debug",
    "silent"
];
/**
* This schema is used internally to share the shape of a concurrency option
* when validating config. We cannot add comments to Zod fields, so we just use
* an extra type check to ensure it matches our exported expectations.
*/ const concurrencyOptionSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].strictObject({
    limit: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].number(),
    key: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().optional(),
    scope: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].enum([
        "fn",
        "env",
        "account"
    ]).optional()
});
/**
* The schema used to represent an individual function being synced with
* Inngest.
*
* Note that this should only be used to validate the shape of a config object
* and not used for feature compatibility, such as feature X being exclusive
* with feature Y; these should be handled on the Inngest side.
*/ const functionConfigSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].strictObject({
    name: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().optional(),
    id: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
    triggers: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].array(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].union([
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].strictObject({
            event: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
            expression: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().optional()
        }),
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].strictObject({
            cron: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string()
        })
    ])),
    steps: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].record(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].strictObject({
        id: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
        name: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
        runtime: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].strictObject({
            type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].union([
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal("http"),
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal("ws")
            ]),
            url: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string()
        }),
        retries: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].strictObject({
            attempts: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].number().optional()
        }).optional()
    })),
    idempotency: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().optional(),
    batchEvents: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].strictObject({
        maxSize: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].number(),
        timeout: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
        key: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().optional(),
        if: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().optional()
    }).optional(),
    rateLimit: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].strictObject({
        key: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().optional(),
        limit: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].number(),
        period: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().transform((x)=>x)
    }).optional(),
    throttle: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].strictObject({
        key: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().optional(),
        limit: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].number(),
        period: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().transform((x)=>x),
        burst: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].number().optional()
    }).optional(),
    singleton: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].strictObject({
        key: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().optional(),
        mode: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].enum([
            "skip",
            "cancel"
        ])
    }).optional(),
    cancel: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].array(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].strictObject({
        event: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
        if: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().optional(),
        timeout: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().optional()
    })).optional(),
    debounce: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].strictObject({
        key: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().optional(),
        period: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().transform((x)=>x),
        timeout: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().transform((x)=>x).optional()
    }).optional(),
    timeouts: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].strictObject({
        start: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().transform((x)=>x).optional(),
        finish: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().transform((x)=>x).optional()
    }).optional(),
    priority: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].strictObject({
        run: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().optional()
    }).optional(),
    concurrency: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].union([
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].number(),
        concurrencyOptionSchema.transform((x)=>x),
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].array(concurrencyOptionSchema.transform((x)=>x)).min(1).max(2)
    ]).optional()
});
const ok = (data)=>{
    return {
        ok: true,
        value: data
    };
};
const err = (error)=>{
    return {
        ok: false,
        error
    };
};
const inBandSyncRequestBodySchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].strictObject({
    url: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string()
});
;
 //# sourceMappingURL=types.js.map
}}),
"[project]/node_modules/.pnpm/inngest@3.45.1_@opentelemetry+core@2.2.0_@opentelemetry+api@1.9.0__express@4.21.2_next@_c75e0c332defb7a954d9a52cadcbb8f7/node_modules/inngest/components/execution/InngestExecution.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "InngestExecution": (()=>InngestExecution),
    "InngestExecution_exports": (()=>InngestExecution_exports),
    "PREFERRED_EXECUTION_VERSION": (()=>PREFERRED_EXECUTION_VERSION)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$_virtual$2f$rolldown_runtime$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/inngest@3.45.1_@opentelemetry+core@2.2.0_@opentelemetry+api@1.9.0__express@4.21.2_next@_c75e0c332defb7a954d9a52cadcbb8f7/node_modules/inngest/_virtual/rolldown_runtime.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/inngest@3.45.1_@opentelemetry+core@2.2.0_@opentelemetry+api@1.9.0__express@4.21.2_next@_c75e0c332defb7a954d9a52cadcbb8f7/node_modules/inngest/helpers/consts.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$debug$40$4$2e$4$2e$3$2f$node_modules$2f$debug$2f$src$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/debug@4.4.3/node_modules/debug/src/index.js [app-route] (ecmascript)");
;
;
;
//#region src/components/execution/InngestExecution.ts
var InngestExecution_exports = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$_virtual$2f$rolldown_runtime$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["__export"])({
    ExecutionVersion: ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ExecutionVersion"],
    InngestExecution: ()=>InngestExecution,
    PREFERRED_EXECUTION_VERSION: ()=>PREFERRED_EXECUTION_VERSION
});
/**
* The preferred execution version that will be used by the SDK when handling
* brand new runs where the Executor is allowing us to choose.
*
* Changing this should not ever be a breaking change, as this will only change
* new runs, not existing ones.
*/ const PREFERRED_EXECUTION_VERSION = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ExecutionVersion"].V1;
var InngestExecution = class {
    debug;
    constructor(options){
        this.options = options;
        this.debug = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$debug$40$4$2e$4$2e$3$2f$node_modules$2f$debug$2f$src$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(`${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["debugPrefix"]}:${this.options.runId}`);
    }
};
;
 //# sourceMappingURL=InngestExecution.js.map
}}),
"[project]/node_modules/.pnpm/inngest@3.45.1_@opentelemetry+core@2.2.0_@opentelemetry+api@1.9.0__express@4.21.2_next@_c75e0c332defb7a954d9a52cadcbb8f7/node_modules/inngest/components/NonRetriableError.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
//#region src/components/NonRetriableError.ts
/**
* An error that, when thrown, indicates to Inngest that the function should
* cease all execution and not retry.
*
* A `message` must be provided, and an optional `cause` can be provided to
* provide more context to the error.
*
* @public
*/ __turbopack_context__.s({
    "NonRetriableError": (()=>NonRetriableError)
});
var NonRetriableError = class extends Error {
    /**
	* The underlying cause of the error, if any.
	*
	* This will be serialized and sent to Inngest.
	*/ cause;
    constructor(message, options){
        super(message);
        this.cause = options?.cause;
        this.name = "NonRetriableError";
    }
};
;
 //# sourceMappingURL=NonRetriableError.js.map
}}),
"[project]/node_modules/.pnpm/inngest@3.45.1_@opentelemetry+core@2.2.0_@opentelemetry+api@1.9.0__express@4.21.2_next@_c75e0c332defb7a954d9a52cadcbb8f7/node_modules/inngest/helpers/errors.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "ErrCode": (()=>ErrCode),
    "deserializeError": (()=>deserializeError$1),
    "errors_exports": (()=>errors_exports),
    "fixEventKeyMissingSteps": (()=>fixEventKeyMissingSteps),
    "functionStoppedRunningErr": (()=>functionStoppedRunningErr),
    "getErrorMessage": (()=>getErrorMessage),
    "minifyPrettyError": (()=>minifyPrettyError),
    "prettyError": (()=>prettyError),
    "rethrowError": (()=>rethrowError),
    "serializeError": (()=>serializeError$1)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$_virtual$2f$rolldown_runtime$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/inngest@3.45.1_@opentelemetry+core@2.2.0_@opentelemetry+api@1.9.0__express@4.21.2_next@_c75e0c332defb7a954d9a52cadcbb8f7/node_modules/inngest/_virtual/rolldown_runtime.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$components$2f$NonRetriableError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/inngest@3.45.1_@opentelemetry+core@2.2.0_@opentelemetry+api@1.9.0__express@4.21.2_next@_c75e0c332defb7a954d9a52cadcbb8f7/node_modules/inngest/components/NonRetriableError.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/zod@3.25.76/node_modules/zod/v3/external.js [app-route] (ecmascript) <export * as z>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$chalk$40$4$2e$1$2e$2$2f$node_modules$2f$chalk$2f$source$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/chalk@4.1.2/node_modules/chalk/source/index.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$json$2d$stringify$2d$safe$40$5$2e$0$2e$1$2f$node_modules$2f$json$2d$stringify$2d$safe$2f$stringify$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/json-stringify-safe@5.0.1/node_modules/json-stringify-safe/stringify.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$serialize$2d$error$2d$cjs$40$0$2e$1$2e$4$2f$node_modules$2f$serialize$2d$error$2d$cjs$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/serialize-error-cjs@0.1.4/node_modules/serialize-error-cjs/dist/index.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$strip$2d$ansi$40$5$2e$2$2e$0$2f$node_modules$2f$strip$2d$ansi$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/strip-ansi@5.2.0/node_modules/strip-ansi/index.js [app-route] (ecmascript)");
;
;
;
;
;
;
;
//#region src/helpers/errors.ts
var errors_exports = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$_virtual$2f$rolldown_runtime$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["__export"])({
    ErrCode: ()=>ErrCode,
    OutgoingResultError: ()=>OutgoingResultError,
    deserializeError: ()=>deserializeError$1,
    fixEventKeyMissingSteps: ()=>fixEventKeyMissingSteps,
    functionStoppedRunningErr: ()=>functionStoppedRunningErr,
    getErrorMessage: ()=>getErrorMessage,
    isSerializedError: ()=>isSerializedError,
    minifyPrettyError: ()=>minifyPrettyError,
    prettyError: ()=>prettyError,
    prettyErrorSplitter: ()=>prettyErrorSplitter,
    rethrowError: ()=>rethrowError,
    serializeError: ()=>serializeError$1
});
const SERIALIZED_KEY = "__serialized";
const SERIALIZED_VALUE = true;
/**
* Add first-class support for certain errors that we control, in addition to
* built-in errors such as `TypeError`.
*
* Adding these allows these non-standard errors to be correctly serialized,
* sent to Inngest, then deserialized back into the correct error type for users
* to react to correctly.
*
* Note that these errors only support `message?: string | undefined` as the
* input; more custom errors are not supported with this current strategy.
*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$serialize$2d$error$2d$cjs$40$0$2e$1$2e$4$2f$node_modules$2f$serialize$2d$error$2d$cjs$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["errorConstructors"].set("NonRetriableError", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$components$2f$NonRetriableError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NonRetriableError"]);
/**
* Serialise an error to a serialized JSON string.
*
* Errors do not serialise nicely to JSON, so we use this function to convert
* them to a serialized JSON string. Doing this is also non-trivial for some
* errors, so we use the `serialize-error` package to do it for us.
*
* See {@link https://www.npmjs.com/package/serialize-error}
*
* This function is a small wrapper around that package to also add a `type`
* property to the serialised error, so that we can distinguish between
* serialised errors and other objects.
*
* Will not reserialise existing serialised errors.
*/ const serializeError$1 = (subject, allowUnknown = false)=>{
    try {
        const existingSerializedError = isSerializedError(subject);
        if (existingSerializedError) return existingSerializedError;
        if (typeof subject === "object" && subject !== null) {
            const serializedErr = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$serialize$2d$error$2d$cjs$40$0$2e$1$2e$4$2f$node_modules$2f$serialize$2d$error$2d$cjs$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["serializeError"])(subject);
            if (!serializedErr.name && allowUnknown) return subject;
            const ret = {
                ...serializedErr,
                name: serializedErr.name || "Error",
                message: serializedErr.message || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$json$2d$stringify$2d$safe$40$5$2e$0$2e$1$2f$node_modules$2f$json$2d$stringify$2d$safe$2f$stringify$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(subject) || "Unknown error; error serialization could not find a message.",
                stack: serializedErr.stack || "",
                [SERIALIZED_KEY]: SERIALIZED_VALUE
            };
            let target = ret;
            const maxDepth = 5;
            for(let i = 0; i < maxDepth; i++){
                if (typeof target === "object" && target !== null && "cause" in target && target.cause) {
                    target = target.cause = serializeError$1(target.cause, true);
                    continue;
                }
                break;
            }
            return ret;
        }
        throw new Error("Error is not an object; strange throw value.");
    } catch  {
        if (allowUnknown) return subject;
        try {
            return {
                ...serializeError$1(new Error(typeof subject === "string" ? subject : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$json$2d$stringify$2d$safe$40$5$2e$0$2e$1$2f$node_modules$2f$json$2d$stringify$2d$safe$2f$stringify$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(subject)), false),
                stack: "",
                [SERIALIZED_KEY]: SERIALIZED_VALUE
            };
        } catch  {
            return {
                name: "Could not serialize source error",
                message: "Serializing the source error failed.",
                stack: "",
                [SERIALIZED_KEY]: SERIALIZED_VALUE
            };
        }
    }
};
/**
* Check if an object or a string is a serialised error created by
* {@link serializeError}.
*/ const isSerializedError = (value)=>{
    try {
        if (typeof value === "string") {
            const parsed = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
                [SERIALIZED_KEY]: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal(SERIALIZED_VALUE),
                name: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].enum([
                    ...Array.from(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$serialize$2d$error$2d$cjs$40$0$2e$1$2e$4$2f$node_modules$2f$serialize$2d$error$2d$cjs$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["errorConstructors"].keys())
                ]),
                message: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
                stack: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string()
            }).passthrough().safeParse(JSON.parse(value));
            if (parsed.success) return parsed.data;
        }
        if (typeof value === "object" && value !== null) {
            if (Object.hasOwn(value, SERIALIZED_KEY) && value[SERIALIZED_KEY] === SERIALIZED_VALUE) return value;
        }
    } catch  {}
};
/**
* Deserialise an error created by {@link serializeError}.
*
* Ensures we only deserialise errors that meet a minimum level of
* applicability, inclusive of error handling to ensure that badly serialized
* errors are still handled.
*/ const deserializeError$1 = (subject, allowUnknown = false)=>{
    const requiredFields = [
        "name",
        "message"
    ];
    try {
        if (!requiredFields.every((field)=>{
            return Object.hasOwn(subject, field);
        })) throw new Error();
        const deserializedErr = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$serialize$2d$error$2d$cjs$40$0$2e$1$2e$4$2f$node_modules$2f$serialize$2d$error$2d$cjs$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["deserializeError"])(subject);
        if ("cause" in deserializedErr) deserializedErr.cause = deserializeError$1(deserializedErr.cause, true);
        return deserializedErr;
    } catch  {
        if (allowUnknown) return subject;
        const err = /* @__PURE__ */ new Error("Unknown error; could not reserialize");
        /**
		* Remove the stack so that it's not misleadingly shown as the Inngest
		* internals.
		*/ err.stack = void 0;
        return err;
    }
};
let ErrCode = /* @__PURE__ */ function(ErrCode$1) {
    ErrCode$1["NESTING_STEPS"] = "NESTING_STEPS";
    /**
	* Legacy v0 execution error code for when a function has changed and no
	* longer matches its in-progress state.
	*
	* @deprecated Not for use in latest execution method.
	*/ ErrCode$1["NON_DETERMINISTIC_FUNCTION"] = "NON_DETERMINISTIC_FUNCTION";
    /**
	* Legacy v0 execution error code for when a function is found to be using
	* async actions after memoziation has occurred, which v0 doesn't support.
	*
	* @deprecated Not for use in latest execution method.
	*/ ErrCode$1["ASYNC_DETECTED_AFTER_MEMOIZATION"] = "ASYNC_DETECTED_AFTER_MEMOIZATION";
    /**
	* Legacy v0 execution error code for when a function is found to be using
	* steps after a non-step async action has occurred.
	*
	* @deprecated Not for use in latest execution method.
	*/ ErrCode$1["STEP_USED_AFTER_ASYNC"] = "STEP_USED_AFTER_ASYNC";
    ErrCode$1["AUTOMATIC_PARALLEL_INDEXING"] = "AUTOMATIC_PARALLEL_INDEXING";
    return ErrCode$1;
}({});
const prettyErrorSplitter = "=================================================";
/**
* Given an unknown `err`, mutate it to minify any pretty errors that it
* contains.
*/ const minifyPrettyError = (err)=>{
    try {
        if (!isError(err)) return err;
        if (!err.message.includes(prettyErrorSplitter)) return err;
        const sanitizedMessage = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$strip$2d$ansi$40$5$2e$2$2e$0$2f$node_modules$2f$strip$2d$ansi$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(err.message);
        const message = sanitizedMessage.split("  ")[1]?.split("\n")[0]?.trim() || err.message;
        err.message = [
            sanitizedMessage.split("\n\nCode: ")[1]?.split("\n\n")[0]?.trim() || void 0,
            message
        ].filter(Boolean).join(" - ");
        if (err.stack) {
            const stackRest = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$strip$2d$ansi$40$5$2e$2$2e$0$2f$node_modules$2f$strip$2d$ansi$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(err.stack).split(`${prettyErrorSplitter}\n`).slice(2).join("\n");
            err.stack = `${err.name}: ${err.message}\n${stackRest}`;
        }
        return err;
    } catch (_noopErr) {
        return err;
    }
};
/**
* Given an `err`, return a boolean representing whether it is in the shape of
* an `Error` or not.
*/ const isError = (err)=>{
    try {
        if (err instanceof Error) return true;
        if (typeof err !== "object" || err === null) return false;
        return Object.hasOwn(err, "name") && Object.hasOwn(err, "message");
    } catch (_noopErr) {
        return false;
    }
};
/**
* Given an `unknown` object, retrieve the `message` property from it, or fall
* back to the `fallback` string if it doesn't exist or is empty.
*/ const getErrorMessage = (err, fallback)=>{
    const { message } = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
        message: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().min(1)
    }).catch({
        message: fallback
    }).parse(err);
    return message;
};
/**
* Given a {@link PrettyError}, return a nicely-formatted string ready to log
* or throw.
*
* Useful for ensuring that errors are logged in a consistent, helpful format
* across the SDK by prompting for key pieces of information.
*/ const prettyError = ({ type = "error", whatHappened, otherwise, reassurance, toFixNow, why, consequences, stack, code })=>{
    const { icon, colorFn } = {
        error: {
            icon: "",
            colorFn: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$chalk$40$4$2e$1$2e$2$2f$node_modules$2f$chalk$2f$source$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].red
        },
        warn: {
            icon: "",
            colorFn: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$chalk$40$4$2e$1$2e$2$2f$node_modules$2f$chalk$2f$source$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].yellow
        }
    }[type];
    let header = `${icon}  ${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$chalk$40$4$2e$1$2e$2$2f$node_modules$2f$chalk$2f$source$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].bold.underline(whatHappened.trim())}`;
    if (stack) header += "\n" + [
        .../* @__PURE__ */ new Error().stack?.split("\n").slice(1).filter(Boolean) || []
    ].join("\n");
    let toFixNowStr = (Array.isArray(toFixNow) ? toFixNow.map((s)=>s.trim()).filter(Boolean).map((s, i)=>`\t${i + 1}. ${s}`).join("\n") : toFixNow?.trim()) ?? "";
    if (Array.isArray(toFixNow) && toFixNowStr) toFixNowStr = `To fix this, you can take one of the following courses of action:\n\n${toFixNowStr}`;
    let body = [
        reassurance?.trim(),
        why?.trim(),
        consequences?.trim()
    ].filter(Boolean).join(" ");
    body += body ? `\n\n${toFixNowStr}` : toFixNowStr;
    const trailer = [
        otherwise?.trim()
    ].filter(Boolean).join(" ");
    return colorFn([
        prettyErrorSplitter,
        header,
        body,
        trailer,
        code ? `Code: ${code}` : "",
        prettyErrorSplitter
    ].filter(Boolean).join("\n\n"));
};
const fixEventKeyMissingSteps = [
    "Set the `INNGEST_EVENT_KEY` environment variable",
    `Pass a key to the \`new Inngest()\` constructor using the \`eventKey\` option`,
    `Use \`inngest.setEventKey()\` at runtime`
];
/**
* An error that, when thrown, indicates internally that an outgoing operation
* contains an error.
*
* We use this because serialized `data` sent back to Inngest may differ from
* the error instance itself due to middleware.
*
* @internal
*/ var OutgoingResultError = class extends Error {
    result;
    constructor(result){
        super("OutgoingOpError");
        this.result = result;
    }
};
/**
* Create a function that will rethrow an error with a prefix added to the
* message.
*
* Useful for adding context to errors that are rethrown.
*
* @example
* ```ts
* await doSomeAction().catch(rethrowError("Failed to do some action"));
* ```
*/ const rethrowError = (prefix)=>{
    return (err)=>{
        try {
            err.message &&= `${prefix}; ${err.message}`;
        } catch (_noopErr) {} finally{
            throw err;
        }
    };
};
/**
* Legacy v0 execution error for functions that don't support mixing steps and
* regular async actions.
*/ const functionStoppedRunningErr = (code)=>{
    return prettyError({
        whatHappened: "Your function was stopped from running",
        why: "We detected a mix of asynchronous logic, some using step tooling and some not.",
        consequences: "This can cause unexpected behaviour when a function is paused and resumed and is therefore strongly discouraged; we stopped your function to ensure nothing unexpected happened!",
        stack: true,
        toFixNow: "Ensure that your function is either entirely step-based or entirely non-step-based, by either wrapping all asynchronous logic in `step.run()` calls or by removing all `step.*()` calls.",
        otherwise: "For more information on why step functions work in this manner, see https://www.inngest.com/docs/functions/multi-step#gotchas",
        code
    });
};
;
 //# sourceMappingURL=errors.js.map
}}),
"[project]/node_modules/.pnpm/inngest@3.45.1_@opentelemetry+core@2.2.0_@opentelemetry+api@1.9.0__express@4.21.2_next@_c75e0c332defb7a954d9a52cadcbb8f7/node_modules/inngest/api/schema.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "batchSchema": (()=>batchSchema),
    "errorSchema": (()=>errorSchema),
    "stepsSchemas": (()=>stepsSchemas)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/inngest@3.45.1_@opentelemetry+core@2.2.0_@opentelemetry+api@1.9.0__express@4.21.2_next@_c75e0c332defb7a954d9a52cadcbb8f7/node_modules/inngest/helpers/consts.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/inngest@3.45.1_@opentelemetry+core@2.2.0_@opentelemetry+api@1.9.0__express@4.21.2_next@_c75e0c332defb7a954d9a52cadcbb8f7/node_modules/inngest/types.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/zod@3.25.76/node_modules/zod/v3/external.js [app-route] (ecmascript) <export * as z>");
;
;
;
//#region src/api/schema.ts
const errorSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
    error: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
    status: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].number()
});
const v0StepSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].record(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].any().refine((v)=>typeof v !== "undefined", {
    message: "Values in steps must be defined"
})).optional().nullable();
const v1StepSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].record(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
    type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal("data").optional().default("data"),
    data: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].any().refine((v)=>typeof v !== "undefined", {
        message: "Data in steps must be defined"
    })
}).strict().or(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
    type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal("error").optional().default("error"),
    error: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["jsonErrorSchema"]
}).strict()).or(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
    type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal("input").optional().default("input"),
    input: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].any().refine((v)=>typeof v !== "undefined", {
        message: "If input is present it must not be `undefined`"
    })
}).strict()).or(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].any().transform((v)=>({
        type: "data",
        data: v
    })))).default({});
const v2StepSchema = v1StepSchema;
const stepsSchemas = {
    [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ExecutionVersion"].V0]: v0StepSchema,
    [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ExecutionVersion"].V1]: v1StepSchema,
    [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ExecutionVersion"].V2]: v2StepSchema
};
const batchSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].array(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].record(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].any()).transform((v)=>v));
;
 //# sourceMappingURL=schema.js.map
}}),
"[project]/node_modules/.pnpm/inngest@3.45.1_@opentelemetry+core@2.2.0_@opentelemetry+api@1.9.0__express@4.21.2_next@_c75e0c332defb7a954d9a52cadcbb8f7/node_modules/inngest/helpers/functions.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "cacheFn": (()=>cacheFn),
    "fetchAllFnData": (()=>fetchAllFnData),
    "parseFnData": (()=>parseFnData),
    "undefinedToNull": (()=>undefinedToNull),
    "waterfall": (()=>waterfall)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/inngest@3.45.1_@opentelemetry+core@2.2.0_@opentelemetry+api@1.9.0__express@4.21.2_next@_c75e0c332defb7a954d9a52cadcbb8f7/node_modules/inngest/helpers/consts.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/inngest@3.45.1_@opentelemetry+core@2.2.0_@opentelemetry+api@1.9.0__express@4.21.2_next@_c75e0c332defb7a954d9a52cadcbb8f7/node_modules/inngest/types.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$api$2f$schema$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/inngest@3.45.1_@opentelemetry+core@2.2.0_@opentelemetry+api@1.9.0__express@4.21.2_next@_c75e0c332defb7a954d9a52cadcbb8f7/node_modules/inngest/api/schema.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$components$2f$execution$2f$InngestExecution$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/inngest@3.45.1_@opentelemetry+core@2.2.0_@opentelemetry+api@1.9.0__express@4.21.2_next@_c75e0c332defb7a954d9a52cadcbb8f7/node_modules/inngest/components/execution/InngestExecution.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$errors$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/inngest@3.45.1_@opentelemetry+core@2.2.0_@opentelemetry+api@1.9.0__express@4.21.2_next@_c75e0c332defb7a954d9a52cadcbb8f7/node_modules/inngest/helpers/errors.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$ZodError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/zod@3.25.76/node_modules/zod/v3/ZodError.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/zod@3.25.76/node_modules/zod/v3/external.js [app-route] (ecmascript) <export * as z>");
;
;
;
;
;
;
//#region src/helpers/functions.ts
/**
* Wraps a function with a cache. When the returned function is run, it will
* cache the result and return it on subsequent calls.
*/ const cacheFn = (fn)=>{
    const key = "value";
    const cache = /* @__PURE__ */ new Map();
    return (...args)=>{
        if (!cache.has(key)) cache.set(key, fn(...args));
        return cache.get(key);
    };
};
/**
* Given an array of functions, return a new function that will run each
* function in series and return the result of the final function. Regardless of
* if the functions are synchronous or asynchronous, they'll be made into an
* async promise chain.
*
* If an error is thrown, the waterfall will stop and return the error.
*
* Because this needs to support both sync and async functions, it only allows
* functions that accept a single argument.
*/ const waterfall = (fns, transform)=>{
    return (...args)=>{
        return fns.reduce(async (acc, fn)=>{
            const prev = await acc;
            const output = await fn(prev);
            if (transform) return await transform(prev, output);
            if (typeof output === "undefined") return prev;
            return output;
        }, Promise.resolve(args[0]));
    };
};
/**
* Given a value `v`, return `v` if it's not undefined, otherwise return `null`.
*/ const undefinedToNull = (v)=>{
    return typeof v === "undefined" ? null : v;
};
const fnDataVersionSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
    version: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal(-1).or(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal(0)).or(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal(1)).or(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal(2)).optional().transform((v)=>{
        if (typeof v === "undefined") {
            console.debug(`No request version specified by executor; defaulting to v${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$components$2f$execution$2f$InngestExecution$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["PREFERRED_EXECUTION_VERSION"]}`);
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$components$2f$execution$2f$InngestExecution$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["PREFERRED_EXECUTION_VERSION"];
        }
        return v === -1 ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$components$2f$execution$2f$InngestExecution$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["PREFERRED_EXECUTION_VERSION"] : v;
    })
});
const parseFnData = (data)=>{
    let version;
    try {
        ({ version } = fnDataVersionSchema.parse(data));
        return ({
            [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ExecutionVersion"].V0]: ()=>({
                    version: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ExecutionVersion"].V0,
                    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
                        event: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].record(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].any()),
                        events: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].array(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].record(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].any())).default([]),
                        steps: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$api$2f$schema$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["stepsSchemas"][__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ExecutionVersion"].V0],
                        ctx: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
                            run_id: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
                            attempt: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].number().default(0),
                            stack: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
                                stack: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].array(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string()).nullable().transform((v)=>Array.isArray(v) ? v : []),
                                current: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].number()
                            }).passthrough().optional().nullable()
                        }).optional().nullable(),
                        use_api: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].boolean().default(false)
                    }).parse(data)
                }),
            [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ExecutionVersion"].V1]: ()=>({
                    version: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ExecutionVersion"].V1,
                    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
                        event: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].record(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].any()),
                        events: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].array(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].record(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].any())).default([]),
                        steps: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$api$2f$schema$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["stepsSchemas"][__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ExecutionVersion"].V1],
                        ctx: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
                            run_id: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
                            attempt: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].number().default(0),
                            max_attempts: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].number().optional(),
                            disable_immediate_execution: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].boolean().default(false),
                            use_api: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].boolean().default(false),
                            stack: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
                                stack: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].array(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string()).nullable().transform((v)=>Array.isArray(v) ? v : []),
                                current: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].number()
                            }).passthrough().optional().nullable()
                        }).optional().nullable()
                    }).parse(data)
                }),
            [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ExecutionVersion"].V2]: ()=>({
                    version: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ExecutionVersion"].V2,
                    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
                        event: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].record(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].any()),
                        events: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].array(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].record(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].any())).default([]),
                        steps: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$api$2f$schema$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["stepsSchemas"][__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ExecutionVersion"].V2],
                        ctx: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
                            run_id: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
                            attempt: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].number().default(0),
                            max_attempts: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].number().optional(),
                            disable_immediate_execution: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].boolean().default(false),
                            use_api: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].boolean().default(false),
                            stack: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
                                stack: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].array(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string()).nullable().transform((v)=>Array.isArray(v) ? v : []),
                                current: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].number()
                            }).passthrough().optional().nullable()
                        }).optional().nullable()
                    }).parse(data)
                })
        })[version]();
    } catch (err$1) {
        throw new Error(parseFailureErr(err$1));
    }
};
const fetchAllFnData = async ({ data, api, version })=>{
    const result = {
        ...data
    };
    try {
        if (result.version === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ExecutionVersion"].V0 && result.use_api || result.version === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ExecutionVersion"].V1 && result.ctx?.use_api) {
            if (!result.ctx?.run_id) return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["err"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$errors$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["prettyError"])({
                whatHappened: "failed to attempt retrieving data from API",
                consequences: "function execution can't continue",
                why: "run_id is missing from context",
                stack: true
            }));
            const [evtResp, stepResp] = await Promise.all([
                api.getRunBatch(result.ctx.run_id),
                api.getRunSteps(result.ctx.run_id, version)
            ]);
            if (evtResp.ok) result.events = evtResp.value;
            else return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["err"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$errors$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["prettyError"])({
                whatHappened: "failed to retrieve list of events",
                consequences: "function execution can't continue",
                why: evtResp.error?.error,
                stack: true
            }));
            if (stepResp.ok) result.steps = stepResp.value;
            else return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["err"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$errors$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["prettyError"])({
                whatHappened: "failed to retrieve steps for function run",
                consequences: "function execution can't continue",
                why: stepResp.error?.error,
                stack: true
            }));
        }
        const stepIds = Object.keys(result.steps || {});
        if (stepIds.length && !result.ctx?.stack?.length) result.ctx = {
            ...result.ctx,
            stack: {
                stack: stepIds,
                current: stepIds.length - 1
            }
        };
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ok"])(result);
    } catch (error) {
        console.error(error);
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["err"])(parseFailureErr(error));
    }
};
const parseFailureErr = (err$1)=>{
    let why;
    if (err$1 instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$ZodError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodError"]) why = err$1.toString();
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$errors$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["prettyError"])({
        whatHappened: "Failed to parse data from executor.",
        consequences: "Function execution can't continue.",
        toFixNow: "Make sure that your API is set up to parse incoming request bodies as JSON, like body-parser for Express (https://expressjs.com/en/resources/middleware/body-parser.html).",
        stack: true,
        why
    });
};
;
 //# sourceMappingURL=functions.js.map
}}),
"[project]/node_modules/.pnpm/inngest@3.45.1_@opentelemetry+core@2.2.0_@opentelemetry+api@1.9.0__express@4.21.2_next@_c75e0c332defb7a954d9a52cadcbb8f7/node_modules/inngest/helpers/devserver.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "devServerAvailable": (()=>devServerAvailable),
    "devServerUrl": (()=>devServerUrl)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/inngest@3.45.1_@opentelemetry+core@2.2.0_@opentelemetry+api@1.9.0__express@4.21.2_next@_c75e0c332defb7a954d9a52cadcbb8f7/node_modules/inngest/helpers/consts.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$env$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/inngest@3.45.1_@opentelemetry+core@2.2.0_@opentelemetry+api@1.9.0__express@4.21.2_next@_c75e0c332defb7a954d9a52cadcbb8f7/node_modules/inngest/helpers/env.js [app-route] (ecmascript)");
;
;
//#region src/helpers/devserver.ts
/**
* Attempts to contact the dev server, returning a boolean indicating whether or
* not it was successful.
*
* @example devServerUrl(process.env[envKeys.DevServerUrl], "/your-path")
*/ const devServerAvailable = async (host = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["defaultDevServerHost"], fetch)=>{
    try {
        await (await fetch(devServerUrl(host, "/dev").toString())).json();
        return true;
    } catch (_e) {
        return false;
    }
};
/**
* devServerUrl returns a full URL for the given path name.
*
* Because Cloudflare/V8 platforms don't allow process.env, you are expected
* to pass in the host from the dev server env key:
*
* @example devServerUrl(processEnv(envKeys.DevServerUrl), "/your-path")
* @example devServerUrl("http://localhost:8288/", "/your-path")
*/ const devServerUrl = (host = devServerHost$1(), pathname = "")=>{
    return new URL(pathname, host.includes("://") ? host : `http://${host}`);
};
/**
* devServerHost exports the development server's domain by inspecting env
* variables, or returns the default development server URL.
*
* This guarantees a specific URL as a string, as opposed to the env export
* which only returns a value of the env var is set.
*/ const devServerHost$1 = ()=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$env$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["devServerHost"])() || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["defaultDevServerHost"];
;
 //# sourceMappingURL=devserver.js.map
}}),
"[project]/node_modules/.pnpm/inngest@3.45.1_@opentelemetry+core@2.2.0_@opentelemetry+api@1.9.0__express@4.21.2_next@_c75e0c332defb7a954d9a52cadcbb8f7/node_modules/inngest/helpers/enum.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
//#region src/helpers/enum.ts
/**
* Returns the value of an enum from a string value.
*
* If the value given is not a value from the enum, `undefined` is returned.
*/ __turbopack_context__.s({
    "enumFromValue": (()=>enumFromValue)
});
const enumFromValue = (enumType, value)=>{
    if (Object.values(enumType).includes(value)) return value;
};
;
 //# sourceMappingURL=enum.js.map
}}),
"[project]/node_modules/.pnpm/inngest@3.45.1_@opentelemetry+core@2.2.0_@opentelemetry+api@1.9.0__express@4.21.2_next@_c75e0c332defb7a954d9a52cadcbb8f7/node_modules/inngest/helpers/net.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "fetchWithAuthFallback": (()=>fetchWithAuthFallback),
    "signDataWithKey": (()=>signDataWithKey)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$hash$2e$js$40$1$2e$1$2e$7$2f$node_modules$2f$hash$2e$js$2f$lib$2f$hash$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$canonicalize$40$1$2e$0$2e$8$2f$node_modules$2f$canonicalize$2f$lib$2f$canonicalize$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/canonicalize@1.0.8/node_modules/canonicalize/lib/canonicalize.js [app-route] (ecmascript)");
;
;
//#region src/helpers/net.ts
const { hmac, sha256 } = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$hash$2e$js$40$1$2e$1$2e$7$2f$node_modules$2f$hash$2e$js$2f$lib$2f$hash$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"];
/**
* Send an HTTP request with the given signing key. If the response is a 401 or
* 403, then try again with the fallback signing key
*/ async function fetchWithAuthFallback({ authToken, authTokenFallback, fetch, options, url }) {
    let res = await fetch(url, {
        ...options,
        headers: {
            ...options?.headers,
            Authorization: `Bearer ${authToken}`
        }
    });
    if ([
        401,
        403
    ].includes(res.status) && authTokenFallback) res = await fetch(url, {
        ...options,
        headers: {
            ...options?.headers,
            Authorization: `Bearer ${authTokenFallback}`
        }
    });
    return res;
}
function signDataWithKey(data, signingKey, ts) {
    const encoded = typeof data === "string" ? data : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$canonicalize$40$1$2e$0$2e$8$2f$node_modules$2f$canonicalize$2f$lib$2f$canonicalize$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(data);
    return hmac(sha256, signingKey.replace(/signkey-\w+-/, "")).update(encoded).update(ts).digest("hex");
}
;
 //# sourceMappingURL=net.js.map
}}),
"[project]/node_modules/.pnpm/inngest@3.45.1_@opentelemetry+core@2.2.0_@opentelemetry+api@1.9.0__express@4.21.2_next@_c75e0c332defb7a954d9a52cadcbb8f7/node_modules/inngest/helpers/promises.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
//#region src/helpers/promises.ts
/**
* Some environments don't allow access to the global queueMicrotask(). While we
* had assumed this was only true for those powered by earlier versions of Node
* (<14) that we don't officially support, Vercel's Edge Functions also obscure
* the function in dev, even though the platform it's based on (Cloudflare
* Workers) appropriately exposes it. Even worse, production Vercel Edge
* Functions can see the function, but it immediately blows up the function when
* used.
*
* Therefore, we can fall back to a reasonable alternative of
* `Promise.resolve().then(fn)` instead. This _may_ be slightly slower in modern
* environments, but at least we can still work in these environments.
*/ __turbopack_context__.s({
    "createDeferredPromise": (()=>createDeferredPromise),
    "createDeferredPromiseWithStack": (()=>createDeferredPromiseWithStack),
    "createTimeoutPromise": (()=>createTimeoutPromise),
    "resolveAfterPending": (()=>resolveAfterPending),
    "resolveNextTick": (()=>resolveNextTick),
    "retryWithBackoff": (()=>retryWithBackoff),
    "runAsPromise": (()=>runAsPromise)
});
const shimQueueMicrotask = (callback)=>{
    Promise.resolve().then(callback);
};
/**
* Returns a Promise that resolves after the current event loop's microtasks
* have finished, but before the next event loop tick.
*/ const resolveAfterPending = (count = 100)=>{
    /**
	* This uses a brute force implementation that will continue to enqueue
	* microtasks 10 times before resolving. This is to ensure that the microtask
	* queue is drained, even if the microtask queue is being manipulated by other
	* code.
	*
	* While this still doesn't guarantee that the microtask queue is drained,
	* it's our best bet for giving other non-controlled promises a chance to
	* resolve before we continue without resorting to falling in to the next
	* tick.
	*/ return new Promise((resolve)=>{
        let i = 0;
        const iterate = ()=>{
            shimQueueMicrotask(()=>{
                if (i++ > count) return resolve();
                iterate();
            });
        };
        iterate();
    });
};
/**
* Creates and returns Promise that can be resolved or rejected with the
* returned `resolve` and `reject` functions.
*
* Resolving or rejecting the function will return a new set of Promise control
* functions. These can be ignored if the original Promise is all that's needed.
*/ const createDeferredPromise = ()=>{
    let resolve;
    let reject;
    return {
        promise: new Promise((_resolve, _reject)=>{
            resolve = (value)=>{
                _resolve(value);
                return createDeferredPromise();
            };
            reject = (reason)=>{
                _reject(reason);
                return createDeferredPromise();
            };
        }),
        resolve,
        reject
    };
};
/**
* Creates and returns a deferred Promise that can be resolved or rejected with
* the returned `resolve` and `reject` functions.
*
* For each Promise resolved or rejected this way, this will also keep a stack
* of all unhandled Promises, resolved or rejected.
*
* Once a Promise is read, it is removed from the stack.
*/ const createDeferredPromiseWithStack = ()=>{
    const settledPromises = [];
    let rotateQueue = ()=>{};
    const results = async function*() {
        while(true){
            const next = settledPromises.shift();
            if (next) yield next;
            else await new Promise((resolve)=>{
                rotateQueue = resolve;
            });
        }
    }();
    const shimDeferredPromise = (deferred)=>{
        const originalResolve = deferred.resolve;
        const originalReject = deferred.reject;
        deferred.resolve = (value)=>{
            settledPromises.push(deferred.promise);
            rotateQueue();
            return shimDeferredPromise(originalResolve(value));
        };
        deferred.reject = (reason)=>{
            settledPromises.push(deferred.promise);
            rotateQueue();
            return shimDeferredPromise(originalReject(reason));
        };
        return deferred;
    };
    return {
        deferred: shimDeferredPromise(createDeferredPromise()),
        results
    };
};
/**
* Creates a Promise that will resolve after the given duration, along with
* methods to start, clear, and reset the timeout.
*/ const createTimeoutPromise = (duration)=>{
    const { promise, resolve } = createDeferredPromise();
    let timeout;
    let ret;
    const start = ()=>{
        if (timeout) return ret;
        timeout = setTimeout(()=>{
            resolve();
        }, duration);
        return ret;
    };
    const clear = ()=>{
        clearTimeout(timeout);
        timeout = void 0;
    };
    const reset = ()=>{
        clear();
        return start();
    };
    ret = Object.assign(promise, {
        start,
        clear,
        reset
    });
    return ret;
};
/**
* Take any function and safely promisify such that both synchronous and
* asynchronous errors are caught and returned as a rejected Promise.
*
* The passed `fn` can be undefined to support functions that may conditionally
* be defined.
*/ const runAsPromise = (fn)=>{
    return Promise.resolve().then(fn);
};
/**
* Returns a Promise that resolve after the current event loop tick.
*/ const resolveNextTick = ()=>{
    return new Promise((resolve)=>setTimeout(resolve));
};
const retryWithBackoff = async (fn, opts)=>{
    const maxAttempts = opts?.maxAttempts || 5;
    const baseDelay = opts?.baseDelay ?? 100;
    for(let attempt = 1; attempt <= maxAttempts; attempt++)try {
        return await fn();
    } catch (err) {
        if (attempt >= maxAttempts) throw err;
        const jitter = Math.random() * baseDelay;
        const delay = baseDelay * Math.pow(2, attempt - 1) + jitter;
        await new Promise((resolve)=>setTimeout(resolve, delay));
    }
    throw new Error("Max retries reached; this should be unreachable.");
};
;
 //# sourceMappingURL=promises.js.map
}}),
"[project]/node_modules/.pnpm/inngest@3.45.1_@opentelemetry+core@2.2.0_@opentelemetry+api@1.9.0__express@4.21.2_next@_c75e0c332defb7a954d9a52cadcbb8f7/node_modules/inngest/helpers/ServerTiming.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "ServerTiming": (()=>ServerTiming),
    "ServerTiming_exports": (()=>ServerTiming_exports)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$_virtual$2f$rolldown_runtime$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/inngest@3.45.1_@opentelemetry+core@2.2.0_@opentelemetry+api@1.9.0__express@4.21.2_next@_c75e0c332defb7a954d9a52cadcbb8f7/node_modules/inngest/_virtual/rolldown_runtime.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$promises$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/inngest@3.45.1_@opentelemetry+core@2.2.0_@opentelemetry+api@1.9.0__express@4.21.2_next@_c75e0c332defb7a954d9a52cadcbb8f7/node_modules/inngest/helpers/promises.js [app-route] (ecmascript)");
;
;
//#region src/helpers/ServerTiming.ts
var ServerTiming_exports = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$_virtual$2f$rolldown_runtime$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["__export"])({
    ServerTiming: ()=>ServerTiming
});
/**
* A class to manage timing functions and arbitrary periods of time before
* generating a `Server-Timing` header for use in HTTP responses.
*
* This is a very simple implementation that does not support nested timings or
* fractions of a millisecond.
*/ var ServerTiming = class {
    timings = {};
    /**
	* Start a timing. Returns a function that, when called, will stop the timing
	* and add it to the header.
	*/ start(name, description) {
        if (!this.timings[name]) this.timings[name] = {
            description: description ?? "",
            timers: []
        };
        const index = this.timings[name].timers.push({
            start: Date.now()
        }) - 1;
        return ()=>{
            const target = this.timings[name];
            if (!target) return console.warn(`Timing "${name}" does not exist`);
            const timer = target.timers[index];
            if (!timer) return console.warn(`Timer ${index} for timing "${name}" does not exist`);
            timer.end = Date.now();
        };
    }
    /**
	* Add a piece of arbitrary, untimed information to the header. Common use
	* cases would be cache misses.
	*
	* @example
	* ```
	* timer.append("cache", "miss");
	* ```
	*/ append(key, value) {
        this.timings[key] = {
            description: value,
            timers: []
        };
    }
    /**
	* Wrap a function in a timing. The timing will be stopped and added to the
	* header when the function resolves or rejects.
	*
	* The return value of the function will be returned from this function.
	*/ async wrap(name, fn, description) {
        const stop = this.start(name, description);
        try {
            return await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$promises$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["runAsPromise"])(fn);
        } finally{
            stop();
        }
    }
    /**
	* Generate the `Server-Timing` header.
	*/ getHeader() {
        return Object.entries(this.timings).reduce((acc, [name, { description, timers }])=>{
            if (!timers.some((timer)=>timer.end)) return acc;
            const dur = timers.reduce((acc$1, { start, end })=>{
                if (!start || !end) return acc$1;
                return acc$1 + (end - start);
            }, 0);
            const entry = [
                name,
                description ? `desc="${description}"` : "",
                dur ? `dur=${dur}` : ""
            ].filter(Boolean).join(";");
            return [
                ...acc,
                entry
            ];
        }, []).join(", ");
    }
};
;
 //# sourceMappingURL=ServerTiming.js.map
}}),
"[project]/node_modules/.pnpm/inngest@3.45.1_@opentelemetry+core@2.2.0_@opentelemetry+api@1.9.0__express@4.21.2_next@_c75e0c332defb7a954d9a52cadcbb8f7/node_modules/inngest/helpers/stream.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createStream": (()=>createStream)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$strings$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/inngest@3.45.1_@opentelemetry+core@2.2.0_@opentelemetry+api@1.9.0__express@4.21.2_next@_c75e0c332defb7a954d9a52cadcbb8f7/node_modules/inngest/helpers/strings.js [app-route] (ecmascript)");
;
//#region src/helpers/stream.ts
/**
* Creates a {@link ReadableStream} that sends a `value` every `interval`
* milliseconds as a heartbeat, intended to keep a stream open.
*
* Returns the `stream` itself and a `finalize` function that can be used to
* close the stream and send a final value.
*/ const createStream = (opts)=>{
    /**
	* We need to resolve this promise with both the stream and the `finalize`
	* function, but having them both instantiated synchronously is difficult, as
	* we need access to the stream's internals too.
	*
	* We create this cheeky deferred promise to grab the internal `finalize`
	* value. Be warned that simpler solutions may appear to compile, but fail at
	* runtime due to variables not being assigned; make sure to test your code!
	*/ let passFinalize;
    const finalizeP = new Promise((resolve)=>{
        passFinalize = resolve;
    });
    const interval = opts?.interval ?? 3e3;
    const value = opts?.value ?? " ";
    return new Promise(async (resolve, reject)=>{
        try {
            resolve({
                stream: new ReadableStream({
                    start (controller) {
                        const encoder = new TextEncoder();
                        const heartbeat = setInterval(()=>{
                            controller.enqueue(encoder.encode(value));
                        }, interval);
                        const finalize = (data)=>{
                            clearInterval(heartbeat);
                            Promise.resolve(data).then((resolvedData)=>{
                                controller.enqueue(encoder.encode((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$strings$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["stringify"])(resolvedData)));
                                controller.close();
                            });
                        };
                        passFinalize(finalize);
                    }
                }),
                finalize: await finalizeP
            });
        } catch (err) {
            reject(err);
        }
    });
};
;
 //# sourceMappingURL=stream.js.map
}}),
"[project]/node_modules/.pnpm/inngest@3.45.1_@opentelemetry+core@2.2.0_@opentelemetry+api@1.9.0__express@4.21.2_next@_c75e0c332defb7a954d9a52cadcbb8f7/node_modules/inngest/components/InngestMiddleware.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "InngestMiddleware": (()=>InngestMiddleware),
    "getHookStack": (()=>getHookStack)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$functions$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/inngest@3.45.1_@opentelemetry+core@2.2.0_@opentelemetry+api@1.9.0__express@4.21.2_next@_c75e0c332defb7a954d9a52cadcbb8f7/node_modules/inngest/helpers/functions.js [app-route] (ecmascript)");
;
//#region src/components/InngestMiddleware.ts
/**
* A middleware that can be registered with Inngest to hook into various
* lifecycles of the SDK and affect input and output of Inngest functionality.
*
* See {@link https://innge.st/middleware}
*
* @example
*
* ```ts
* export const inngest = new Inngest({
*   middleware: [
*     new InngestMiddleware({
*       name: "My Middleware",
*       init: () => {
*         // ...
*       }
*     })
*   ]
* });
* ```
*
* @public
*/ var InngestMiddleware = class InngestMiddleware {
    get [Symbol.toStringTag]() {
        return InngestMiddleware.Tag;
    }
    /**
	* The name of this middleware. Used primarily for debugging and logging
	* purposes.
	*/ name;
    /**
	* This function is used to initialize your middleware and register any hooks
	* you want to use. It will be called once when the SDK is initialized, and
	* should be used to store any state you want to use in other parts of your
	* middleware.
	*
	* It can be synchronous or asynchronous, in which case the client will wait
	* for it to resolve before continuing to initialize the next middleware.
	*
	* Multiple clients could be used in the same application with differing
	* middleware, so do not store state in global variables or assume that your
	* middleware will only be used once.
	*
	* Must return an object detailing the hooks you want to register.
	*/ init;
    constructor({ name, init }){
        this.name = name;
        this.init = init;
    }
};
(function(_InngestMiddleware) {
    _InngestMiddleware.Tag = "Inngest.Middleware";
})(InngestMiddleware || (InngestMiddleware = {}));
/**
* Given some middleware and an entrypoint, runs the initializer for the given
* `key` and returns functions that will pass arguments through a stack of each
* given hook in a middleware's lifecycle.
*
* Lets the middleware initialize before starting.
*/ const getHookStack = async (middleware, key, arg, transforms)=>{
    const hookDirs = hookDirections[key];
    if (!hookDirs) throw new Error(`No hook directions found for key "${String(key)}". This is likely a bug in the Inngest SDK.`);
    const hooksRegistered = await (await middleware).reduce((acc, mw)=>{
        const fn = mw[key];
        if (fn) return [
            ...acc,
            fn
        ];
        return acc;
    }, []).reduce(async (acc, fn)=>{
        return [
            ...await acc,
            await fn(arg)
        ];
    }, Promise.resolve([]));
    const ret = {};
    for (const hook of hooksRegistered){
        const hookKeys = Object.keys(hook);
        for (const key$1 of hookKeys){
            let fns = [
                hook[key$1]
            ];
            const existingWaterfall = ret[key$1];
            if (existingWaterfall) if (hookDirs[key$1] === "forward") fns = [
                existingWaterfall,
                hook[key$1]
            ];
            else fns = [
                hook[key$1],
                existingWaterfall
            ];
            const transform = transforms[key$1];
            ret[key$1] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$functions$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["waterfall"])(fns, transform);
        }
    }
    for (const k of Object.keys(ret)){
        const key$1 = k;
        ret[key$1] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$functions$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["cacheFn"])(ret[key$1]);
    }
    return ret;
};
/**
* The direction of each hook that exists in the middleware lifecycle.
* This is used to determine whether hooks found in a stack run forwards or
* backwards, creating onion-like behaviour.
*/ const hookDirections = {
    onFunctionRun: {
        transformInput: "forward",
        beforeMemoization: "forward",
        afterMemoization: "backward",
        beforeExecution: "forward",
        afterExecution: "backward",
        transformOutput: "backward",
        beforeResponse: "forward",
        finished: "forward"
    },
    onSendEvent: {
        transformInput: "forward",
        transformOutput: "backward"
    }
};
;
 //# sourceMappingURL=InngestMiddleware.js.map
}}),
"[project]/node_modules/.pnpm/inngest@3.45.1_@opentelemetry+core@2.2.0_@opentelemetry+api@1.9.0__express@4.21.2_next@_c75e0c332defb7a954d9a52cadcbb8f7/node_modules/inngest/components/RetryAfterError.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "RetryAfterError": (()=>RetryAfterError)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$ms$40$2$2e$1$2e$3$2f$node_modules$2f$ms$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/ms@2.1.3/node_modules/ms/index.js [app-route] (ecmascript)");
;
//#region src/components/RetryAfterError.ts
/**
* An error that, when thrown, indicates to Inngest that the function should be
* retried after a given amount of time.
*
* A `message` must be provided, as well as a `retryAfter` parameter, which can
* be a `number` of milliseconds, an `ms`-compatible time string, or a `Date`.
*
* An optional `cause` can be provided to provide more context to the error.
*
* @public
*/ var RetryAfterError = class extends Error {
    /**
	* The underlying cause of the error, if any.
	*
	* This will be serialized and sent to Inngest.
	*/ cause;
    /**
	* The time after which the function should be retried. Represents either a
	* number of milliseconds or a RFC3339 date.
	*/ retryAfter;
    constructor(message, retryAfter, options){
        super(message);
        if (retryAfter instanceof Date) this.retryAfter = retryAfter.toISOString();
        else {
            const seconds = `${Math.ceil((typeof retryAfter === "string" ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$ms$40$2$2e$1$2e$3$2f$node_modules$2f$ms$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(retryAfter) : retryAfter) / 1e3)}`;
            if (!isFinite(Number(seconds))) throw new Error("retryAfter must be a number of milliseconds, a ms-compatible string, or a Date");
            this.retryAfter = seconds;
        }
        this.cause = options?.cause;
    }
};
;
 //# sourceMappingURL=RetryAfterError.js.map
}}),
"[project]/node_modules/.pnpm/inngest@3.45.1_@opentelemetry+core@2.2.0_@opentelemetry+api@1.9.0__express@4.21.2_next@_c75e0c332defb7a954d9a52cadcbb8f7/node_modules/inngest/helpers/temporal.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
//#region src/helpers/temporal.ts
/**
* Asserts that the given `input` is a `Temporal.Duration` object.
*/ __turbopack_context__.s({
    "getISOString": (()=>getISOString),
    "isTemporalDuration": (()=>isTemporalDuration)
});
const isTemporalDuration = (input)=>{
    try {
        return input[Symbol.toStringTag] === "Temporal.Duration";
    } catch  {
        return false;
    }
};
/**
* Asserts that the given `input` is a `Temporal.TimeZone` object.
*/ const isTemporalInstant = (input)=>{
    try {
        return input[Symbol.toStringTag] === "Temporal.Instant";
    } catch  {
        return false;
    }
};
/**
* Asserts that the given `input` is a `Temporal.ZonedDateTime` object.
*/ const isTemporalZonedDateTime = (input)=>{
    try {
        return input[Symbol.toStringTag] === "Temporal.ZonedDateTime";
    } catch  {
        return false;
    }
};
/**
* Converts a given `Date`, `string`, `Temporal.Instant`, or
* `Temporal.ZonedDateTime` to an ISO 8601 string.
*/ const getISOString = (time)=>{
    if (typeof time === "string") return new Date(time).toISOString();
    if (time instanceof Date) return time.toISOString();
    if (isTemporalZonedDateTime(time)) return time.toInstant().toString();
    if (isTemporalInstant(time)) return time.toString();
    throw new TypeError("Invalid date input");
};
;
 //# sourceMappingURL=temporal.js.map
}}),
"[project]/node_modules/.pnpm/inngest@3.45.1_@opentelemetry+core@2.2.0_@opentelemetry+api@1.9.0__express@4.21.2_next@_c75e0c332defb7a954d9a52cadcbb8f7/node_modules/inngest/components/Fetch.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "fetch": (()=>fetch)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$components$2f$execution$2f$als$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/inngest@3.45.1_@opentelemetry+core@2.2.0_@opentelemetry+api@1.9.0__express@4.21.2_next@_c75e0c332defb7a954d9a52cadcbb8f7/node_modules/inngest/components/execution/als.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$components$2f$InngestStepTools$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/inngest@3.45.1_@opentelemetry+core@2.2.0_@opentelemetry+api@1.9.0__express@4.21.2_next@_c75e0c332defb7a954d9a52cadcbb8f7/node_modules/inngest/components/InngestStepTools.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$debug$40$4$2e$4$2e$3$2f$node_modules$2f$debug$2f$src$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/debug@4.4.3/node_modules/debug/src/index.js [app-route] (ecmascript)");
;
;
;
//#region src/components/Fetch.ts
const globalFetch = globalThis.fetch;
const debug$1 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$debug$40$4$2e$4$2e$3$2f$node_modules$2f$debug$2f$src$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])("inngest:fetch");
const createFetchShim = ()=>{
    let stepFetch;
    const fetch$1 = async (input, init)=>{
        const ctx = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$components$2f$execution$2f$als$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getAsyncCtx"])();
        if (!ctx?.execution) {
            if (!stepFetch.fallback) throw new Error("step.fetch() called outside of a function and had no fallback set");
            debug$1("step.fetch() called outside of a function; falling back to global fetch");
            return stepFetch.fallback(input, init);
        }
        if (ctx.execution.executingStep) {
            if (!stepFetch.fallback) throw new Error(`step.fetch() called inside step "${ctx.execution.executingStep.id}" and had no fallback set`);
            debug$1(`step.fetch() called inside step "${ctx.execution.executingStep.id}"; falling back to global fetch`);
            return stepFetch.fallback(input, init);
        }
        const targetUrl = new URL(input instanceof Request ? input.url : input.toString());
        debug$1("step.fetch() shimming request to", targetUrl.hostname);
        const jsonRes = await ctx.execution.ctx.step[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$components$2f$InngestStepTools$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["gatewaySymbol"]](`step.fetch: ${targetUrl.hostname}`, input, init);
        return new Response(jsonRes.body, {
            headers: jsonRes.headers,
            status: jsonRes.status
        });
    };
    const optionsRef = {
        fallback: globalFetch
    };
    const extras = {
        config: (options)=>{
            Object.assign(optionsRef, options);
            Object.assign(stepFetch, optionsRef);
            return stepFetch;
        },
        ...optionsRef
    };
    stepFetch = Object.assign(fetch$1, extras);
    return stepFetch;
};
/**
* `fetch` is a Fetch API-compatible function that can be used to make any HTTP
* code durable if it's called within an Inngest function.
*
* It will gracefully fall back to the global `fetch` if called outside of this
* context, and a custom fallback can be set using the `config` method.
*
* @example Basic usage
* ```ts
* import { fetch } from "inngest";
*
* const api = new MyProductApi({ fetch });
* ```
*
* @example Setting a custom fallback
* ```ts
* import { fetch } from "inngest";
*
* const api = new MyProductApi({
*            fetch: fetch.config({ fallback: myCustomFetch }),
* });
* ```
*
* @example Do not allow fallback
* ```ts
* import { fetch } from "inngest";
*
* const api = new MyProductApi({
*            fetch: fetch.config({ fallback: undefined }),
* });
* ```
*/ const fetch = createFetchShim();
;
 //# sourceMappingURL=Fetch.js.map
}}),
"[project]/node_modules/.pnpm/inngest@3.45.1_@opentelemetry+core@2.2.0_@opentelemetry+api@1.9.0__express@4.21.2_next@_c75e0c332defb7a954d9a52cadcbb8f7/node_modules/inngest/components/InngestFunctionReference.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
//#region src/components/InngestFunctionReference.ts
/**
* A reference to an `InngestFunction` that can be used to represent both local
* and remote functions without pulling in the full function definition (i.e.
* dependencies).
*
* These references can be invoked in the same manner as a regular
* `InngestFunction`.
*
* To create a reference function, use the {@link referenceFunction} helper.
*
* @public
*/ __turbopack_context__.s({
    "InngestFunctionReference": (()=>InngestFunctionReference),
    "referenceFunction": (()=>referenceFunction)
});
var InngestFunctionReference = class InngestFunctionReference {
    get [Symbol.toStringTag]() {
        return InngestFunctionReference.Tag;
    }
    constructor(opts){
        this.opts = opts;
    }
};
/**
* Create a reference to an `InngestFunction` that can be used to represent both
* local and remote functions without pulling in the full function definition
* (i.e. dependencies).
*
* These references can be invoked in the same manner as a regular
* `InngestFunction`.
*
* @public
*/ const referenceFunction = ({ functionId, appId })=>{
    return new InngestFunctionReference({
        functionId,
        appId
    });
};
(function(_InngestFunctionReference) {
    _InngestFunctionReference.Tag = "Inngest.FunctionReference";
})(InngestFunctionReference || (InngestFunctionReference = {}));
;
 //# sourceMappingURL=InngestFunctionReference.js.map
}}),
"[project]/node_modules/.pnpm/inngest@3.45.1_@opentelemetry+core@2.2.0_@opentelemetry+api@1.9.0__express@4.21.2_next@_c75e0c332defb7a954d9a52cadcbb8f7/node_modules/inngest/components/InngestStepTools.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "STEP_INDEXING_SUFFIX": (()=>STEP_INDEXING_SUFFIX),
    "createStepTools": (()=>createStepTools),
    "gatewaySymbol": (()=>gatewaySymbol),
    "getStepOptions": (()=>getStepOptions),
    "invokePayloadSchema": (()=>invokePayloadSchema),
    "step": (()=>step)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$components$2f$execution$2f$als$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/inngest@3.45.1_@opentelemetry+core@2.2.0_@opentelemetry+api@1.9.0__express@4.21.2_next@_c75e0c332defb7a954d9a52cadcbb8f7/node_modules/inngest/components/execution/als.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/inngest@3.45.1_@opentelemetry+core@2.2.0_@opentelemetry+api@1.9.0__express@4.21.2_next@_c75e0c332defb7a954d9a52cadcbb8f7/node_modules/inngest/helpers/consts.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/inngest@3.45.1_@opentelemetry+core@2.2.0_@opentelemetry+api@1.9.0__express@4.21.2_next@_c75e0c332defb7a954d9a52cadcbb8f7/node_modules/inngest/types.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$strings$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/inngest@3.45.1_@opentelemetry+core@2.2.0_@opentelemetry+api@1.9.0__express@4.21.2_next@_c75e0c332defb7a954d9a52cadcbb8f7/node_modules/inngest/helpers/strings.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$temporal$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/inngest@3.45.1_@opentelemetry+core@2.2.0_@opentelemetry+api@1.9.0__express@4.21.2_next@_c75e0c332defb7a954d9a52cadcbb8f7/node_modules/inngest/helpers/temporal.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$components$2f$Fetch$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/inngest@3.45.1_@opentelemetry+core@2.2.0_@opentelemetry+api@1.9.0__express@4.21.2_next@_c75e0c332defb7a954d9a52cadcbb8f7/node_modules/inngest/components/Fetch.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$components$2f$InngestFunction$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/inngest@3.45.1_@opentelemetry+core@2.2.0_@opentelemetry+api@1.9.0__express@4.21.2_next@_c75e0c332defb7a954d9a52cadcbb8f7/node_modules/inngest/components/InngestFunction.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$components$2f$InngestFunctionReference$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/inngest@3.45.1_@opentelemetry+core@2.2.0_@opentelemetry+api@1.9.0__express@4.21.2_next@_c75e0c332defb7a954d9a52cadcbb8f7/node_modules/inngest/components/InngestFunctionReference.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/zod@3.25.76/node_modules/zod/v3/external.js [app-route] (ecmascript) <export * as z>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$inngest$2b$ai$40$0$2e$1$2e$7$2f$node_modules$2f40$inngest$2f$ai$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@inngest+ai@0.1.7/node_modules/@inngest/ai/dist/index.js [app-route] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
//#region src/components/InngestStepTools.ts
const getStepOptions = (options)=>{
    if (typeof options === "string") return {
        id: options
    };
    return options;
};
/**
* Suffix used to namespace steps that are automatically indexed.
*/ const STEP_INDEXING_SUFFIX = ":";
/**
* Create a new set of step function tools ready to be used in a step function.
* This function should be run and a fresh set of tools provided every time a
* function is run.
*
* An op stack (function state) is passed in as well as some mutable properties
* that the tools can use to submit a new op.
*/ const createStepTools = (client, execution, stepHandler)=>{
    /**
	* A local helper used to create tools that can be used to submit an op.
	*
	* When using this function, a generic type should be provided which is the
	* function signature exposed to the user.
	*/ const createTool = (matchOp, opts)=>{
        return async (...args)=>{
            return stepHandler({
                args,
                matchOp,
                opts
            });
        };
    };
    /**
	* Create a new step run tool that can be used to run a step function using
	* `step.run()` as a shim.
	*/ const createStepRun = (type)=>{
        return createTool(({ id, name }, _fn, ...input)=>{
            const opts = {
                ...input.length ? {
                    input
                } : {},
                ...type ? {
                    type
                } : {}
            };
            return {
                id,
                mode: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["StepMode"].Sync,
                op: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["StepOpCode"].StepPlanned,
                name: id,
                displayName: name ?? id,
                ...Object.keys(opts).length ? {
                    opts
                } : {},
                userland: {
                    id
                }
            };
        }, {
            fn: (_, fn, ...input)=>fn(...input)
        });
    };
    /**
	* Define the set of tools the user has access to for their step functions.
	*
	* Each key is the function name and is expected to run `createTool` and pass
	* a generic type for that function as it will appear in the user's code.
	*/ const tools = {
        sendEvent: createTool(({ id, name })=>{
            return {
                id,
                mode: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["StepMode"].Sync,
                op: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["StepOpCode"].StepPlanned,
                name: "sendEvent",
                displayName: name ?? id,
                opts: {
                    type: "step.sendEvent"
                },
                userland: {
                    id
                }
            };
        }, {
            fn: (_idOrOptions, payload)=>{
                return client["_send"]({
                    payload,
                    headers: execution["options"]["headers"]
                });
            }
        }),
        waitForSignal: createTool(({ id, name }, opts)=>{
            return {
                id,
                mode: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["StepMode"].Async,
                op: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["StepOpCode"].WaitForSignal,
                name: opts.signal,
                displayName: name ?? id,
                opts: {
                    signal: opts.signal,
                    timeout: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$strings$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["timeStr"])(opts.timeout),
                    conflict: opts.onConflict
                },
                userland: {
                    id
                }
            };
        }),
        sendSignal: createTool(({ id, name }, opts)=>{
            return {
                id,
                mode: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["StepMode"].Sync,
                op: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["StepOpCode"].StepPlanned,
                name: "sendSignal",
                displayName: name ?? id,
                opts: {
                    type: "step.sendSignal",
                    signal: opts.signal
                },
                userland: {
                    id
                }
            };
        }, {
            fn: (_idOrOptions, opts)=>{
                return client["_sendSignal"]({
                    signal: opts.signal,
                    data: opts.data,
                    headers: execution["options"]["headers"]
                });
            }
        }),
        waitForEvent: createTool(({ id, name }, opts)=>{
            const matchOpts = {
                timeout: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$strings$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["timeStr"])(typeof opts === "string" ? opts : opts.timeout)
            };
            if (typeof opts !== "string") {
                if (opts?.match) matchOpts.if = `event.${opts.match} == async.${opts.match}`;
                else if (opts?.if) matchOpts.if = opts.if;
            }
            return {
                id,
                mode: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["StepMode"].Async,
                op: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["StepOpCode"].WaitForEvent,
                name: opts.event,
                opts: matchOpts,
                displayName: name ?? id,
                userland: {
                    id
                }
            };
        }),
        run: createStepRun(),
        ai: {
            infer: createTool(({ id, name }, options)=>{
                const { model, body, ...rest } = options;
                const modelCopy = {
                    ...model
                };
                options.model.onCall?.(modelCopy, options.body);
                return {
                    id,
                    mode: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["StepMode"].Async,
                    op: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["StepOpCode"].AiGateway,
                    displayName: name ?? id,
                    opts: {
                        type: "step.ai.infer",
                        url: modelCopy.url,
                        headers: modelCopy.headers,
                        auth_key: modelCopy.authKey,
                        format: modelCopy.format,
                        body,
                        ...rest
                    },
                    userland: {
                        id
                    }
                };
            }),
            wrap: createStepRun("step.ai.wrap"),
            models: {
                ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$inngest$2b$ai$40$0$2e$1$2e$7$2f$node_modules$2f40$inngest$2f$ai$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["models"]
            }
        },
        sleep: createTool(({ id, name }, time)=>{
            /**
			* The presence of this operation in the returned stack indicates that the
			* sleep is over and we should continue execution.
			*/ const msTimeStr = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$strings$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["timeStr"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$temporal$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isTemporalDuration"])(time) ? time.total({
                unit: "milliseconds"
            }) : time);
            return {
                id,
                mode: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["StepMode"].Async,
                op: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["StepOpCode"].Sleep,
                name: msTimeStr,
                displayName: name ?? id,
                userland: {
                    id
                }
            };
        }),
        sleepUntil: createTool(({ id, name }, time)=>{
            try {
                const iso = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$temporal$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getISOString"])(time);
                /**
				* The presence of this operation in the returned stack indicates that the
				* sleep is over and we should continue execution.
				*/ return {
                    id,
                    mode: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["StepMode"].Async,
                    op: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["StepOpCode"].Sleep,
                    name: iso,
                    displayName: name ?? id,
                    userland: {
                        id
                    }
                };
            } catch (err) {
                /**
				* If we're here, it's because the date is invalid. We'll throw a custom
				* error here to standardise this response.
				*/ console.warn("Invalid `Date`, date string, `Temporal.Instant`, or `Temporal.ZonedDateTime` passed to sleepUntil;", err);
                throw new Error(`Invalid \`Date\`, date string, \`Temporal.Instant\`, or \`Temporal.ZonedDateTime\` passed to sleepUntil: ${time}`);
            }
        }),
        invoke: createTool(({ id, name }, invokeOpts)=>{
            const optsSchema = invokePayloadSchema.extend({
                timeout: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].union([
                    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].number(),
                    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
                    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].date()
                ]).optional()
            });
            const parsedFnOpts = optsSchema.extend({
                _type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal("fullId").optional().default("fullId"),
                function: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().min(1)
            }).or(optsSchema.extend({
                _type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal("fnInstance").optional().default("fnInstance"),
                function: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].instanceof(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$components$2f$InngestFunction$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["InngestFunction"])
            })).or(optsSchema.extend({
                _type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal("refInstance").optional().default("refInstance"),
                function: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].instanceof(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$components$2f$InngestFunctionReference$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["InngestFunctionReference"])
            })).safeParse(invokeOpts);
            if (!parsedFnOpts.success) throw new Error(`Invalid invocation options passed to invoke; must include either a function or functionId.`);
            const { _type, function: fn, data, user, v, timeout } = parsedFnOpts.data;
            const opts = {
                payload: {
                    data,
                    user,
                    v
                },
                function_id: "",
                timeout: typeof timeout === "undefined" ? void 0 : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$strings$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["timeStr"])(timeout)
            };
            switch(_type){
                case "fnInstance":
                    opts.function_id = fn.id(fn["client"].id);
                    break;
                case "fullId":
                    console.warn(`${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["logPrefix"]} Invoking function with \`function: string\` is deprecated and will be removed in v4.0.0; use an imported function or \`referenceFunction()\` instead. See https://innge.st/ts-referencing-functions`);
                    opts.function_id = fn;
                    break;
                case "refInstance":
                    opts.function_id = [
                        fn.opts.appId || client.id,
                        fn.opts.functionId
                    ].filter(Boolean).join("-");
                    break;
            }
            return {
                id,
                mode: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["StepMode"].Async,
                op: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["StepOpCode"].InvokeFunction,
                displayName: name ?? id,
                opts,
                userland: {
                    id
                }
            };
        }),
        fetch: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$components$2f$Fetch$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["fetch"]
    };
    tools[gatewaySymbol] = createTool(({ id, name }, input, init)=>{
        const url = input instanceof Request ? input.url : input.toString();
        const headers = {};
        if (input instanceof Request) input.headers.forEach((value, key)=>{
            headers[key] = value;
        });
        else if (init?.headers) new Headers(init.headers).forEach((value, key)=>{
            headers[key] = value;
        });
        return {
            id,
            mode: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["StepMode"].Async,
            op: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["StepOpCode"].Gateway,
            displayName: name ?? id,
            opts: {
                url,
                method: init?.method ?? "GET",
                headers,
                body: init?.body
            },
            userland: {
                id
            }
        };
    });
    return tools;
};
const gatewaySymbol = Symbol.for("inngest.step.gateway");
/**
* A generic set of step tools that can be used without typing information about
* the client used to create them.
*
* These tools use AsyncLocalStorage to track the context in which they are
* used, and will throw an error if used outside of an Inngest context.
*
* The intention of these high-level tools is to allow usage of Inngest step
* tools within API endpoints, though they can still be used within regular
* Inngest functions as well.
*/ const step = {
    fetch: null,
    ai: {
        infer: (...args)=>getDeferredStepTooling().then((tools)=>tools.ai.infer(...args)),
        wrap: (...args)=>getDeferredStepTooling().then((tools)=>tools.ai.wrap(...args)),
        models: {
            ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$inngest$2b$ai$40$0$2e$1$2e$7$2f$node_modules$2f40$inngest$2f$ai$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["models"]
        }
    },
    invoke: (...args)=>getDeferredStepTooling().then((tools)=>tools.invoke(...args)),
    run: (...args)=>getDeferredStepTooling().then((tools)=>tools.run(...args)),
    sendEvent: (...args)=>getDeferredStepTooling().then((tools)=>tools.sendEvent(...args)),
    sendSignal: (...args)=>getDeferredStepTooling().then((tools)=>tools.sendSignal(...args)),
    sleep: (...args)=>getDeferredStepTooling().then((tools)=>tools.sleep(...args)),
    sleepUntil: (...args)=>getDeferredStepTooling().then((tools)=>tools.sleepUntil(...args)),
    waitForEvent: (...args)=>getDeferredStepTooling().then((tools)=>tools.waitForEvent(...args)),
    waitForSignal: (...args)=>getDeferredStepTooling().then((tools)=>tools.waitForSignal(...args))
};
/**
* An internal function used to retrieve or create step tooling for the current
* execution context.
*
* Note that this requires an existing context to create the step tooling;
* something must declare the Inngest execution context before this can be used.
*/ const getDeferredStepTooling = async ()=>{
    const ctx = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$components$2f$execution$2f$als$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getAsyncCtx"])();
    if (!ctx) throw new Error("`step` tools can only be used within Inngest function executions; no context was found");
    if (!ctx.app) throw new Error("`step` tools can only be used within Inngest function executions; no Inngest client was found in the execution context");
    if (!ctx.execution) throw new Error("`step` tools can only be used within Inngest function executions; no execution context was found");
    return ctx.execution.ctx.step;
};
/**
* The event payload portion of the options for `step.invoke()`. This does not
* include non-payload options like `timeout` or the function to invoke.
*/ const invokePayloadSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
    data: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].record(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].any()).optional(),
    user: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].record(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].any()).optional(),
    v: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().optional()
});
;
 //# sourceMappingURL=InngestStepTools.js.map
}}),
"[project]/node_modules/.pnpm/inngest@3.45.1_@opentelemetry+core@2.2.0_@opentelemetry+api@1.9.0__express@4.21.2_next@_c75e0c332defb7a954d9a52cadcbb8f7/node_modules/inngest/components/execution/v0.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createV0InngestExecution": (()=>createV0InngestExecution),
    "v0_exports": (()=>v0_exports)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$_virtual$2f$rolldown_runtime$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/inngest@3.45.1_@opentelemetry+core@2.2.0_@opentelemetry+api@1.9.0__express@4.21.2_next@_c75e0c332defb7a954d9a52cadcbb8f7/node_modules/inngest/_virtual/rolldown_runtime.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/inngest@3.45.1_@opentelemetry+core@2.2.0_@opentelemetry+api@1.9.0__express@4.21.2_next@_c75e0c332defb7a954d9a52cadcbb8f7/node_modules/inngest/helpers/consts.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/inngest@3.45.1_@opentelemetry+core@2.2.0_@opentelemetry+api@1.9.0__express@4.21.2_next@_c75e0c332defb7a954d9a52cadcbb8f7/node_modules/inngest/types.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$components$2f$execution$2f$InngestExecution$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/inngest@3.45.1_@opentelemetry+core@2.2.0_@opentelemetry+api@1.9.0__express@4.21.2_next@_c75e0c332defb7a954d9a52cadcbb8f7/node_modules/inngest/components/execution/InngestExecution.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$components$2f$NonRetriableError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/inngest@3.45.1_@opentelemetry+core@2.2.0_@opentelemetry+api@1.9.0__express@4.21.2_next@_c75e0c332defb7a954d9a52cadcbb8f7/node_modules/inngest/components/NonRetriableError.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$errors$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/inngest@3.45.1_@opentelemetry+core@2.2.0_@opentelemetry+api@1.9.0__express@4.21.2_next@_c75e0c332defb7a954d9a52cadcbb8f7/node_modules/inngest/helpers/errors.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$functions$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/inngest@3.45.1_@opentelemetry+core@2.2.0_@opentelemetry+api@1.9.0__express@4.21.2_next@_c75e0c332defb7a954d9a52cadcbb8f7/node_modules/inngest/helpers/functions.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$components$2f$InngestMiddleware$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/inngest@3.45.1_@opentelemetry+core@2.2.0_@opentelemetry+api@1.9.0__express@4.21.2_next@_c75e0c332defb7a954d9a52cadcbb8f7/node_modules/inngest/components/InngestMiddleware.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$promises$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/inngest@3.45.1_@opentelemetry+core@2.2.0_@opentelemetry+api@1.9.0__express@4.21.2_next@_c75e0c332defb7a954d9a52cadcbb8f7/node_modules/inngest/helpers/promises.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$components$2f$RetryAfterError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/inngest@3.45.1_@opentelemetry+core@2.2.0_@opentelemetry+api@1.9.0__express@4.21.2_next@_c75e0c332defb7a954d9a52cadcbb8f7/node_modules/inngest/components/RetryAfterError.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$components$2f$InngestStepTools$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/inngest@3.45.1_@opentelemetry+core@2.2.0_@opentelemetry+api@1.9.0__express@4.21.2_next@_c75e0c332defb7a954d9a52cadcbb8f7/node_modules/inngest/components/InngestStepTools.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/zod@3.25.76/node_modules/zod/v3/external.js [app-route] (ecmascript) <export * as z>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$hash$2e$js$40$1$2e$1$2e$7$2f$node_modules$2f$hash$2e$js$2f$lib$2f$hash$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$canonicalize$40$1$2e$0$2e$8$2f$node_modules$2f$canonicalize$2f$lib$2f$canonicalize$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/canonicalize@1.0.8/node_modules/canonicalize/lib/canonicalize.js [app-route] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
;
;
;
;
//#region src/components/execution/v0.ts
var v0_exports = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$_virtual$2f$rolldown_runtime$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["__export"])({
    V0InngestExecution: ()=>V0InngestExecution,
    _internals: ()=>_internals,
    createV0InngestExecution: ()=>createV0InngestExecution
});
const { sha1 } = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$hash$2e$js$40$1$2e$1$2e$7$2f$node_modules$2f$hash$2e$js$2f$lib$2f$hash$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"];
const createV0InngestExecution = (options)=>{
    return new V0InngestExecution(options);
};
var V0InngestExecution = class extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$components$2f$execution$2f$InngestExecution$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["InngestExecution"] {
    version = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ExecutionVersion"].V0;
    state;
    execution;
    userFnToRun;
    fnArg;
    constructor(options){
        super(options);
        this.userFnToRun = this.getUserFnToRun();
        this.state = this.createExecutionState();
        this.fnArg = this.createFnArg();
    }
    start() {
        this.debug("starting V0 execution");
        return this.execution ??= this._start().then((result)=>{
            this.debug("result:", result);
            return result;
        });
    }
    async _start() {
        this.state.hooks = await this.initializeMiddleware();
        try {
            await this.transformInput();
            await this.state.hooks.beforeMemoization?.();
            if (this.state.opStack.length === 0 && !this.options.requestedRunStep) {
                await this.state.hooks.afterMemoization?.();
                await this.state.hooks.beforeExecution?.();
            }
            const userFnPromise = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$promises$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["runAsPromise"])(()=>this.userFnToRun(this.fnArg));
            let pos = -1;
            do {
                if (pos >= 0) {
                    if (!this.options.requestedRunStep && pos === this.state.opStack.length - 1) {
                        await this.state.hooks.afterMemoization?.();
                        await this.state.hooks.beforeExecution?.();
                    }
                    this.state.tickOps = {};
                    const incomingOp = this.state.opStack[pos];
                    this.state.currentOp = this.state.allFoundOps[incomingOp.id];
                    if (!this.state.currentOp) /**
					* We're trying to resume the function, but we can't find where to go.
					*
					* This means that either the function has changed or there are async
					* actions in-between steps that we haven't noticed in previous
					* executions.
					*
					* Whichever the case, this is bad and we can't continue in this
					* undefined state.
					*/ throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$components$2f$NonRetriableError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NonRetriableError"]((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$errors$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["prettyError"])({
                        whatHappened: " Your function was stopped from running",
                        why: "We couldn't resume your function's state because it may have changed since the run started or there are async actions in-between steps that we haven't noticed in previous executions.",
                        consequences: "Continuing to run the function may result in unexpected behaviour, so we've stopped your function to ensure nothing unexpected happened!",
                        toFixNow: "Ensure that your function is either entirely step-based or entirely non-step-based, by either wrapping all asynchronous logic in `step.run()` calls or by removing all `step.*()` calls.",
                        otherwise: "For more information on why step functions work in this manner, see https://www.inngest.com/docs/functions/multi-step#gotchas",
                        stack: true,
                        code: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$errors$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ErrCode"].NON_DETERMINISTIC_FUNCTION
                    }));
                    this.state.currentOp.fulfilled = true;
                    if (typeof incomingOp.data !== "undefined") this.state.currentOp.resolve(incomingOp.data);
                    else this.state.currentOp.reject(incomingOp.error);
                }
                await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$promises$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["resolveAfterPending"])();
                this.state.reset();
                pos++;
            }while (pos < this.state.opStack.length)
            await this.state.hooks.afterMemoization?.();
            const discoveredOps = Object.values(this.state.tickOps).map(tickOpToOutgoing);
            const runStep = this.options.requestedRunStep || this.getEarlyExecRunStep(discoveredOps);
            if (runStep) {
                const userFnOp = this.state.allFoundOps[runStep];
                const stepToRun = userFnOp?.fn;
                if (!stepToRun) throw new Error(`Bad stack; executor requesting to run unknown step "${runStep}"`);
                const outgoingUserFnOp = {
                    ...tickOpToOutgoing(userFnOp),
                    op: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["StepOpCode"].Step
                };
                await this.state.hooks.beforeExecution?.();
                this.state.executingStep = true;
                const { type: _type, ...rest } = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$promises$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["runAsPromise"])(stepToRun).finally(()=>{
                    this.state.executingStep = false;
                }).catch(async (error)=>{
                    return await this.transformOutput({
                        error
                    }, outgoingUserFnOp);
                }).then(async (data)=>{
                    await this.state.hooks?.afterExecution?.();
                    return await this.transformOutput({
                        data
                    }, outgoingUserFnOp);
                });
                return {
                    type: "step-ran",
                    ctx: this.fnArg,
                    ops: this.ops,
                    step: {
                        ...outgoingUserFnOp,
                        ...rest
                    }
                };
            }
            if (!discoveredOps.length) {
                const fnRet = await Promise.race([
                    userFnPromise.then((data)=>({
                            type: "complete",
                            data
                        })),
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$promises$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["resolveNextTick"])().then(()=>({
                            type: "incomplete"
                        }))
                ]);
                if (fnRet.type === "complete") {
                    await this.state.hooks.afterExecution?.();
                    if (Object.values(this.state.allFoundOps).every((op)=>{
                        return op.fulfilled;
                    })) return await this.transformOutput({
                        data: fnRet.data
                    });
                } else if (!this.state.hasUsedTools) {
                    this.state.nonStepFnDetected = true;
                    const data = await userFnPromise;
                    await this.state.hooks.afterExecution?.();
                    return await this.transformOutput({
                        data
                    });
                } else if (!Object.values(this.state.allFoundOps).some((op)=>{
                    return op.fulfilled === false;
                })) throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$components$2f$NonRetriableError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NonRetriableError"]((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$errors$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["functionStoppedRunningErr"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$errors$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ErrCode"].ASYNC_DETECTED_AFTER_MEMOIZATION));
            }
            await this.state.hooks.afterExecution?.();
            return {
                type: "steps-found",
                ctx: this.fnArg,
                ops: this.ops,
                steps: discoveredOps
            };
        } catch (error) {
            return await this.transformOutput({
                error
            });
        } finally{
            await this.state.hooks.beforeResponse?.();
        }
    }
    async initializeMiddleware() {
        const ctx = this.options.data;
        return await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$components$2f$InngestMiddleware$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getHookStack"])(this.options.fn["middleware"], "onFunctionRun", {
            ctx,
            fn: this.options.fn,
            steps: Object.values(this.options.stepState),
            reqArgs: this.options.reqArgs
        }, {
            transformInput: (prev, output)=>{
                return {
                    ctx: {
                        ...prev.ctx,
                        ...output?.ctx
                    },
                    fn: this.options.fn,
                    steps: prev.steps.map((step, i)=>({
                            ...step,
                            ...output?.steps?.[i]
                        })),
                    reqArgs: prev.reqArgs
                };
            },
            transformOutput: (prev, output)=>{
                return {
                    result: {
                        ...prev.result,
                        ...output?.result
                    },
                    step: prev.step
                };
            }
        });
    }
    createExecutionState() {
        const state = {
            allFoundOps: {},
            tickOps: {},
            tickOpHashes: {},
            currentOp: void 0,
            hasUsedTools: false,
            reset: ()=>{
                state.tickOpHashes = {};
                state.allFoundOps = {
                    ...state.allFoundOps,
                    ...state.tickOps
                };
            },
            nonStepFnDetected: false,
            executingStep: false,
            opStack: this.options.stepCompletionOrder.reduce((acc, stepId)=>{
                const stepState = this.options.stepState[stepId];
                if (!stepState) return acc;
                return [
                    ...acc,
                    stepState
                ];
            }, [])
        };
        return state;
    }
    get ops() {
        return Object.fromEntries(Object.entries(this.state.allFoundOps).map(([id, op])=>[
                id,
                {
                    id: op.id,
                    rawArgs: op.rawArgs,
                    data: op.data,
                    error: op.error,
                    fulfilled: op.fulfilled,
                    seen: true
                }
            ]));
    }
    getUserFnToRun() {
        if (!this.options.isFailureHandler) return this.options.fn["fn"];
        if (!this.options.fn["onFailureFn"]) /**
		* Somehow, we've ended up detecting that this is a failure handler but
		* doesn't have an `onFailure` function. This should never happen.
		*/ throw new Error("Cannot find function `onFailure` handler");
        return this.options.fn["onFailureFn"];
    }
    createFnArg() {
        this.state.tickOps = this.state.allFoundOps;
        /**
		* Create a unique hash of an operation using only a subset of the operation's
		* properties; will never use `data` and will guarantee the order of the
		* object so we don't rely on individual tools for that.
		*
		* If the operation already contains an ID, the current ID will be used
		* instead, so that users can provide their own IDs.
		*/ const hashOp = (op)=>{
            /**
			* It's difficult for v0 to understand whether or not an op has
			* historically contained a custom ID, as all step usage now require them.
			*
			* For this reason, we make the assumption that steps in v0 do not have a
			* custom ID and generate one for them as we would in all recommendations
			* and examples.
			*/ const obj = {
                parent: this.state.currentOp?.id ?? null,
                op: op.op,
                name: op.name,
                opts: op.op === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["StepOpCode"].StepPlanned ? null : op.opts ?? null
            };
            const collisionHash = _internals.hashData(obj);
            const pos = this.state.tickOpHashes[collisionHash] = (this.state.tickOpHashes[collisionHash] ?? -1) + 1;
            return {
                ...op,
                id: _internals.hashData({
                    pos,
                    ...obj
                })
            };
        };
        const stepHandler = ({ args, matchOp, opts })=>{
            if (this.state.nonStepFnDetected) throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$components$2f$NonRetriableError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NonRetriableError"]((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$errors$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["functionStoppedRunningErr"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$errors$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ErrCode"].STEP_USED_AFTER_ASYNC));
            if (this.state.executingStep) throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$components$2f$NonRetriableError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NonRetriableError"]((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$errors$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["prettyError"])({
                whatHappened: "Your function was stopped from running",
                why: "We detected that you have nested `step.*` tooling.",
                consequences: "Nesting `step.*` tooling is not supported.",
                stack: true,
                toFixNow: "Make sure you're not using `step.*` tooling inside of other `step.*` tooling. If you need to compose steps together, you can create a new async function and call it from within your step function, or use promise chaining.",
                otherwise: "For more information on step functions with Inngest, see https://www.inngest.com/docs/functions/multi-step",
                code: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$errors$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ErrCode"].NESTING_STEPS
            }));
            this.state.hasUsedTools = true;
            const opId = hashOp(matchOp((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$components$2f$InngestStepTools$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getStepOptions"])(args[0]), ...args.slice(1)));
            return new Promise((resolve, reject)=>{
                this.state.tickOps[opId.id] = {
                    ...opId,
                    ...opts?.fn ? {
                        fn: ()=>opts.fn?.(...args)
                    } : {},
                    rawArgs: args,
                    resolve,
                    reject,
                    fulfilled: false
                };
            });
        };
        const step = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$components$2f$InngestStepTools$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createStepTools"])(this.options.client, this, stepHandler);
        let fnArg = {
            ...this.options.data,
            step
        };
        if (this.options.isFailureHandler) {
            const eventData = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
                error: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["jsonErrorSchema"]
            }).parse(fnArg.event?.data);
            fnArg = {
                ...fnArg,
                error: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$errors$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["deserializeError"])(eventData.error)
            };
        }
        return this.options.transformCtx?.(fnArg) ?? fnArg;
    }
    /**
	* Using middleware, transform input before running.
	*/ async transformInput() {
        const inputMutations = await this.state.hooks?.transformInput?.({
            ctx: {
                ...this.fnArg
            },
            steps: Object.values(this.options.stepState),
            fn: this.options.fn,
            reqArgs: this.options.reqArgs
        });
        if (inputMutations?.ctx) this.fnArg = inputMutations.ctx;
        if (inputMutations?.steps) this.state.opStack = [
            ...inputMutations.steps
        ];
    }
    getEarlyExecRunStep(ops) {
        if (ops.length !== 1) return;
        const op = ops[0];
        if (op && op.op === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["StepOpCode"].StepPlanned) return op.id;
    }
    /**
	* Using middleware, transform output before returning.
	*/ async transformOutput(dataOrError, step) {
        const output = {
            ...dataOrError
        };
        if (typeof output.error !== "undefined") output.data = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$errors$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["serializeError"])(output.error);
        const transformedOutput = await this.state.hooks?.transformOutput?.({
            result: {
                ...output
            },
            step
        });
        const { data, error } = {
            ...output,
            ...transformedOutput?.result
        };
        if (!step) await this.state.hooks?.finished?.({
            result: {
                ...typeof error !== "undefined" ? {
                    error
                } : {
                    data
                }
            }
        });
        if (typeof error !== "undefined") {
            /**
			* Ensure we give middleware the chance to decide on retriable behaviour
			* by looking at the error returned from output transformation.
			*/ let retriable = !(error instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$components$2f$NonRetriableError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NonRetriableError"]);
            if (retriable && error instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$components$2f$RetryAfterError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["RetryAfterError"]) retriable = error.retryAfter;
            const serializedError = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$errors$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["serializeError"])(error);
            return {
                type: "function-rejected",
                ctx: this.fnArg,
                ops: this.ops,
                error: serializedError,
                retriable
            };
        }
        return {
            type: "function-resolved",
            ctx: this.fnArg,
            ops: this.ops,
            data: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$functions$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["undefinedToNull"])(data)
        };
    }
};
const tickOpToOutgoing = (op)=>{
    return {
        op: op.op,
        id: op.id,
        name: op.name,
        opts: op.opts
    };
};
const hashData = (op)=>{
    return sha1().update((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$canonicalize$40$1$2e$0$2e$8$2f$node_modules$2f$canonicalize$2f$lib$2f$canonicalize$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(op)).digest("hex");
};
/**
* Exported for testing.
*/ const _internals = {
    hashData
};
;
 //# sourceMappingURL=v0.js.map
}}),
"[project]/node_modules/.pnpm/inngest@3.45.1_@opentelemetry+core@2.2.0_@opentelemetry+api@1.9.0__express@4.21.2_next@_c75e0c332defb7a954d9a52cadcbb8f7/node_modules/inngest/components/execution/otel/access.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
//#region src/components/execution/otel/access.ts
/**
* A map of Inngest clients to their OTel span processors. This is used to
* ensure that we only create one span processor per client, and that we can
* access the span processor from the client without exposing the OTel
* libraries to the user.
*/ __turbopack_context__.s({
    "clientProcessorMap": (()=>clientProcessorMap)
});
const clientProcessorMap = /* @__PURE__ */ new WeakMap();
;
 //# sourceMappingURL=access.js.map
}}),
"[project]/node_modules/.pnpm/inngest@3.45.1_@opentelemetry+core@2.2.0_@opentelemetry+api@1.9.0__express@4.21.2_next@_c75e0c332defb7a954d9a52cadcbb8f7/node_modules/inngest/components/StepError.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "StepError": (()=>StepError)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/inngest@3.45.1_@opentelemetry+core@2.2.0_@opentelemetry+api@1.9.0__express@4.21.2_next@_c75e0c332defb7a954d9a52cadcbb8f7/node_modules/inngest/types.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$errors$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/inngest@3.45.1_@opentelemetry+core@2.2.0_@opentelemetry+api@1.9.0__express@4.21.2_next@_c75e0c332defb7a954d9a52cadcbb8f7/node_modules/inngest/helpers/errors.js [app-route] (ecmascript)");
;
;
//#region src/components/StepError.ts
/**
* An error that represents a step exhausting all retries and failing. This is
* thrown by an Inngest step if it fails.
*
* It's synonymous with an `Error`, with the addition of the `stepId` that
* failed.
*
* @public
*/ var StepError = class extends Error {
    cause;
    constructor(stepId, err){
        const parsedErr = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["jsonErrorSchema"].parse(err);
        super(parsedErr.message);
        this.stepId = stepId;
        this.name = parsedErr.name;
        this.stepId = stepId;
        this.stack = parsedErr.stack ?? void 0;
        this.cause = parsedErr.cause ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$errors$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["deserializeError"])(parsedErr.cause, true) : void 0;
    }
};
;
 //# sourceMappingURL=StepError.js.map
}}),
"[project]/node_modules/.pnpm/inngest@3.45.1_@opentelemetry+core@2.2.0_@opentelemetry+api@1.9.0__express@4.21.2_next@_c75e0c332defb7a954d9a52cadcbb8f7/node_modules/inngest/components/execution/v2.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createV2InngestExecution": (()=>createV2InngestExecution),
    "v2_exports": (()=>v2_exports)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$_virtual$2f$rolldown_runtime$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/inngest@3.45.1_@opentelemetry+core@2.2.0_@opentelemetry+api@1.9.0__express@4.21.2_next@_c75e0c332defb7a954d9a52cadcbb8f7/node_modules/inngest/_virtual/rolldown_runtime.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$components$2f$execution$2f$als$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/inngest@3.45.1_@opentelemetry+core@2.2.0_@opentelemetry+api@1.9.0__express@4.21.2_next@_c75e0c332defb7a954d9a52cadcbb8f7/node_modules/inngest/components/execution/als.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$version$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/inngest@3.45.1_@opentelemetry+core@2.2.0_@opentelemetry+api@1.9.0__express@4.21.2_next@_c75e0c332defb7a954d9a52cadcbb8f7/node_modules/inngest/version.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/inngest@3.45.1_@opentelemetry+core@2.2.0_@opentelemetry+api@1.9.0__express@4.21.2_next@_c75e0c332defb7a954d9a52cadcbb8f7/node_modules/inngest/helpers/consts.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/inngest@3.45.1_@opentelemetry+core@2.2.0_@opentelemetry+api@1.9.0__express@4.21.2_next@_c75e0c332defb7a954d9a52cadcbb8f7/node_modules/inngest/types.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$components$2f$execution$2f$InngestExecution$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/inngest@3.45.1_@opentelemetry+core@2.2.0_@opentelemetry+api@1.9.0__express@4.21.2_next@_c75e0c332defb7a954d9a52cadcbb8f7/node_modules/inngest/components/execution/InngestExecution.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$components$2f$NonRetriableError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/inngest@3.45.1_@opentelemetry+core@2.2.0_@opentelemetry+api@1.9.0__express@4.21.2_next@_c75e0c332defb7a954d9a52cadcbb8f7/node_modules/inngest/components/NonRetriableError.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$errors$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/inngest@3.45.1_@opentelemetry+core@2.2.0_@opentelemetry+api@1.9.0__express@4.21.2_next@_c75e0c332defb7a954d9a52cadcbb8f7/node_modules/inngest/helpers/errors.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$functions$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/inngest@3.45.1_@opentelemetry+core@2.2.0_@opentelemetry+api@1.9.0__express@4.21.2_next@_c75e0c332defb7a954d9a52cadcbb8f7/node_modules/inngest/helpers/functions.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$components$2f$InngestMiddleware$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/inngest@3.45.1_@opentelemetry+core@2.2.0_@opentelemetry+api@1.9.0__express@4.21.2_next@_c75e0c332defb7a954d9a52cadcbb8f7/node_modules/inngest/components/InngestMiddleware.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$components$2f$execution$2f$otel$2f$access$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/inngest@3.45.1_@opentelemetry+core@2.2.0_@opentelemetry+api@1.9.0__express@4.21.2_next@_c75e0c332defb7a954d9a52cadcbb8f7/node_modules/inngest/components/execution/otel/access.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$promises$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/inngest@3.45.1_@opentelemetry+core@2.2.0_@opentelemetry+api@1.9.0__express@4.21.2_next@_c75e0c332defb7a954d9a52cadcbb8f7/node_modules/inngest/helpers/promises.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$components$2f$RetryAfterError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/inngest@3.45.1_@opentelemetry+core@2.2.0_@opentelemetry+api@1.9.0__express@4.21.2_next@_c75e0c332defb7a954d9a52cadcbb8f7/node_modules/inngest/components/RetryAfterError.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$components$2f$StepError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/inngest@3.45.1_@opentelemetry+core@2.2.0_@opentelemetry+api@1.9.0__express@4.21.2_next@_c75e0c332defb7a954d9a52cadcbb8f7/node_modules/inngest/components/StepError.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$components$2f$InngestStepTools$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/inngest@3.45.1_@opentelemetry+core@2.2.0_@opentelemetry+api@1.9.0__express@4.21.2_next@_c75e0c332defb7a954d9a52cadcbb8f7/node_modules/inngest/components/InngestStepTools.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/zod@3.25.76/node_modules/zod/v3/external.js [app-route] (ecmascript) <export * as z>");
var __TURBOPACK__imported__module__$5b$externals$5d2f$next$2f$dist$2f$compiled$2f40$opentelemetry$2f$api__$5b$external$5d$__$28$next$2f$dist$2f$compiled$2f40$opentelemetry$2f$api$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/next/dist/compiled/@opentelemetry/api [external] (next/dist/compiled/@opentelemetry/api, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$hash$2e$js$40$1$2e$1$2e$7$2f$node_modules$2f$hash$2e$js$2f$lib$2f$hash$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash.js [app-route] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
//#region src/components/execution/v2.ts
var v2_exports = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$_virtual$2f$rolldown_runtime$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["__export"])({
    _internals: ()=>_internals,
    createV2InngestExecution: ()=>createV2InngestExecution
});
const { sha1 } = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$hash$2e$js$40$1$2e$1$2e$7$2f$node_modules$2f$hash$2e$js$2f$lib$2f$hash$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"];
const createV2InngestExecution = (options)=>{
    return new V2InngestExecution(options);
};
var V2InngestExecution = class extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$components$2f$execution$2f$InngestExecution$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["InngestExecution"] {
    version = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ExecutionVersion"].V2;
    state;
    fnArg;
    checkpointHandlers;
    timeoutDuration = 1e3 * 10;
    execution;
    userFnToRun;
    /**
	* If we're supposed to run a particular step via `requestedRunStep`, this
	* will be a `Promise` that resolves after no steps have been found for
	* `timeoutDuration` milliseconds.
	*
	* If we're not supposed to run a particular step, this will be `undefined`.
	*/ timeout;
    constructor(options){
        super(options);
        this.userFnToRun = this.getUserFnToRun();
        this.state = this.createExecutionState();
        this.fnArg = this.createFnArg();
        this.checkpointHandlers = this.createCheckpointHandlers();
        this.initializeTimer(this.state);
        this.debug("created new V2 execution for run;", this.options.requestedRunStep ? `wanting to run step "${this.options.requestedRunStep}"` : "discovering steps");
        this.debug("existing state keys:", Object.keys(this.state.stepState));
    }
    /**
	* Idempotently start the execution of the user's function.
	*/ start() {
        if (!this.execution) {
            this.debug("starting V2 execution");
            const tracer = __TURBOPACK__imported__module__$5b$externals$5d2f$next$2f$dist$2f$compiled$2f40$opentelemetry$2f$api__$5b$external$5d$__$28$next$2f$dist$2f$compiled$2f40$opentelemetry$2f$api$2c$__cjs$29$__["trace"].getTracer("inngest", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$version$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["version"]);
            this.execution = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$components$2f$execution$2f$als$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getAsyncLocalStorage"])().then((als)=>{
                return als.run({
                    app: this.options.client,
                    execution: {
                        ctx: this.fnArg,
                        instance: this
                    }
                }, async ()=>{
                    return tracer.startActiveSpan("inngest.execution", (span)=>{
                        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$components$2f$execution$2f$otel$2f$access$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["clientProcessorMap"].get(this.options.client)?.declareStartingSpan({
                            span,
                            runId: this.options.runId,
                            traceparent: this.options.headers[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["headerKeys"].TraceParent],
                            tracestate: this.options.headers[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["headerKeys"].TraceState]
                        });
                        return this._start().then((result)=>{
                            this.debug("result:", result);
                            return result;
                        }).finally(()=>{
                            span.end();
                        });
                    });
                });
            });
        }
        return this.execution;
    }
    /**
	* Starts execution of the user's function and the core loop.
	*/ async _start() {
        try {
            const allCheckpointHandler = this.getCheckpointHandler("");
            this.state.hooks = await this.initializeMiddleware();
            await this.startExecution();
            for await (const checkpoint of this.state.loop){
                await allCheckpointHandler(checkpoint);
                const result = await this.getCheckpointHandler(checkpoint.type)(checkpoint);
                if (result) return result;
            }
        } catch (error) {
            return await this.transformOutput({
                error
            });
        } finally{
            this.state.loop.return();
            await this.state.hooks?.beforeResponse?.();
        }
        /**
		* If we're here, the generator somehow finished without returning a value.
		* This should never happen.
		*/ throw new Error("Core loop finished without returning a value");
    }
    /**
	* Creates a handler for every checkpoint type, defining what to do when we
	* reach that checkpoint in the core loop.
	*/ createCheckpointHandlers() {
        return {
            "": (checkpoint)=>{
                this.debug("checkpoint:", checkpoint);
            },
            "function-resolved": async (checkpoint)=>{
                return await this.transformOutput({
                    data: checkpoint.data
                });
            },
            "function-rejected": async (checkpoint)=>{
                return await this.transformOutput({
                    error: checkpoint.error
                });
            },
            "steps-found": async ({ steps })=>{
                const stepResult = await this.tryExecuteStep(steps);
                if (stepResult) {
                    const transformResult = await this.transformOutput(stepResult);
                    /**
					* Transforming output will always return either function rejection or
					* resolution. In most cases, this can be immediately returned, but in
					* this particular case we want to handle it differently.
					*/ if (transformResult.type === "function-resolved") return {
                        type: "step-ran",
                        ctx: transformResult.ctx,
                        ops: transformResult.ops,
                        step: _internals.hashOp({
                            ...stepResult,
                            data: transformResult.data
                        })
                    };
                    else if (transformResult.type === "function-rejected") {
                        const stepForResponse = _internals.hashOp({
                            ...stepResult,
                            error: transformResult.error
                        });
                        if (stepResult.op === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["StepOpCode"].StepFailed) {
                            const ser = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$errors$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["serializeError"])(transformResult.error);
                            stepForResponse.data = {
                                __serialized: true,
                                name: ser.name,
                                message: ser.message,
                                stack: ""
                            };
                        }
                        return {
                            type: "step-ran",
                            ctx: transformResult.ctx,
                            ops: transformResult.ops,
                            retriable: transformResult.retriable,
                            step: stepForResponse
                        };
                    }
                    return transformResult;
                }
                const newSteps = await this.filterNewSteps(Array.from(this.state.steps.values()));
                if (newSteps) return {
                    type: "steps-found",
                    ctx: this.fnArg,
                    ops: this.ops,
                    steps: newSteps
                };
            },
            "step-not-found": ({ step })=>{
                return {
                    type: "step-not-found",
                    ctx: this.fnArg,
                    ops: this.ops,
                    step
                };
            }
        };
    }
    getCheckpointHandler(type) {
        return this.checkpointHandlers[type];
    }
    async tryExecuteStep(steps) {
        const hashedStepIdToRun = this.options.requestedRunStep || this.getEarlyExecRunStep(steps);
        if (!hashedStepIdToRun) return;
        const step = steps.find((step$1)=>step$1.hashedId === hashedStepIdToRun && step$1.fn);
        if (step) return await this.executeStep(step);
        this.timeout?.reset();
    }
    /**
	* Given a list of outgoing ops, decide if we can execute an op early and
	* return the ID of the step to execute if we can.
	*/ getEarlyExecRunStep(steps) {
        /**
		* We may have been disabled due to parallelism, in which case we can't
		* immediately execute unless explicitly requested.
		*/ if (this.options.disableImmediateExecution) return;
        const unfulfilledSteps = steps.filter((step)=>!step.fulfilled);
        if (unfulfilledSteps.length !== 1) return;
        const op = unfulfilledSteps[0];
        if (op && op.op === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["StepOpCode"].StepPlanned) return op.hashedId;
    }
    async filterNewSteps(foundSteps) {
        if (this.options.requestedRunStep) return;
        /**
		* Gather any steps that aren't memoized and report them.
		*/ const newSteps = foundSteps.filter((step)=>!step.fulfilled);
        if (!newSteps.length) return;
        /**
		* Warn if we've found new steps but haven't yet seen all previous
		* steps. This may indicate that step presence isn't determinate.
		*/ let knownSteps = 0;
        for (const step of foundSteps)if (step.fulfilled) knownSteps++;
        if (!(this.state.stepsToFulfill === knownSteps)) console.warn((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$errors$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["prettyError"])({
            type: "warn",
            whatHappened: "Function may be indeterminate",
            why: "We found new steps before seeing all previous steps, which may indicate that the function is non-deterministic.",
            consequences: "This may cause unexpected behaviour as Inngest executes your function.",
            reassurance: "This is expected if a function is updated in the middle of a run, but may indicate a bug if not."
        }));
        /**
		* We're finishing up; let's trigger the last of the hooks.
		*/ await this.state.hooks?.afterMemoization?.();
        await this.state.hooks?.beforeExecution?.();
        await this.state.hooks?.afterExecution?.();
        const stepList = newSteps.map((step)=>({
                displayName: step.displayName,
                op: step.op,
                id: step.hashedId,
                name: step.name,
                opts: step.opts,
                userland: step.userland
            }));
        /**
		* We also run `onSendEvent` middleware hooks against `step.invoke()` steps
		* to ensure that their `data` is transformed correctly.
		*/ return await this.transformNewSteps(stepList);
    }
    /**
	* Using middleware, transform any newly-found steps before returning them to
	* an Inngest Server.
	*/ async transformNewSteps(steps) {
        return Promise.all(steps.map(async (step)=>{
            if (step.op !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["StepOpCode"].InvokeFunction) return step;
            /**
			* For each event being sent, create a new `onSendEvent` hook stack to
			* process it. We do this as middleware hooks are intended to run once
			* during each lifecycle (onFunctionRun or onSendEvent) and here, a hook
			* is run for every single event.
			*
			* This is done because a developer can use this hook to filter out
			* events entirely; if we batch all of the events together, we can't
			* tell which ones were filtered out if we're processing >1 invocation
			* here.
			*/ const transformedPayload = await (await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$components$2f$InngestMiddleware$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getHookStack"])(this.options.fn["middleware"], "onSendEvent", void 0, {
                transformInput: (prev, output)=>{
                    return {
                        ...prev,
                        ...output
                    };
                },
                transformOutput: (prev, output)=>{
                    return {
                        result: {
                            ...prev.result,
                            ...output?.result
                        }
                    };
                }
            })).transformInput?.({
                payloads: [
                    {
                        ...step.opts?.payload ?? {},
                        name: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["internalEvents"].FunctionInvoked
                    }
                ]
            });
            const newPayload = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$components$2f$InngestStepTools$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["invokePayloadSchema"].parse(transformedPayload?.payloads?.[0] ?? {});
            return {
                ...step,
                opts: {
                    ...step.opts,
                    payload: {
                        ...step.opts?.payload ?? {},
                        ...newPayload
                    }
                }
            };
        }));
    }
    async executeStep({ id, name, opts, fn, displayName, userland }) {
        this.timeout?.clear();
        await this.state.hooks?.afterMemoization?.();
        await this.state.hooks?.beforeExecution?.();
        const outgoingOp = {
            id,
            op: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["StepOpCode"].StepRun,
            name,
            opts,
            displayName,
            userland
        };
        this.state.executingStep = outgoingOp;
        const store = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$components$2f$execution$2f$als$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getAsyncCtx"])();
        if (store?.execution) store.execution.executingStep = {
            id,
            name: displayName
        };
        this.debug(`executing step "${id}"`);
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$promises$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["runAsPromise"])(fn).finally(async ()=>{
            if (store?.execution) delete store.execution.executingStep;
            await this.state.hooks?.afterExecution?.();
        }).then((data)=>{
            return {
                ...outgoingOp,
                data
            };
        }).catch((error)=>{
            let errorIsRetriable = true;
            if (error instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$components$2f$NonRetriableError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NonRetriableError"]) errorIsRetriable = false;
            else if (this.fnArg.maxAttempts && this.fnArg?.maxAttempts - 1 === this.fnArg.attempt) errorIsRetriable = false;
            if (errorIsRetriable) return {
                ...outgoingOp,
                op: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["StepOpCode"].StepError,
                error
            };
            else return {
                ...outgoingOp,
                op: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["StepOpCode"].StepFailed,
                error
            };
        });
    }
    /**
	* Starts execution of the user's function, including triggering checkpoints
	* and middleware hooks where appropriate.
	*/ async startExecution() {
        /**
		* Mutate input as neccessary based on middleware.
		*/ await this.transformInput();
        /**
		* Start the timer to time out the run if needed.
		*/ this.timeout?.start();
        await this.state.hooks?.beforeMemoization?.();
        /**
		* If we had no state to begin with, immediately end the memoization phase.
		*/ if (this.state.allStateUsed()) {
            await this.state.hooks?.afterMemoization?.();
            await this.state.hooks?.beforeExecution?.();
        }
        /**
		* Trigger the user's function.
		*/ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$promises$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["runAsPromise"])(()=>this.userFnToRun(this.fnArg)).finally(async ()=>{
            await this.state.hooks?.afterMemoization?.();
            await this.state.hooks?.beforeExecution?.();
            await this.state.hooks?.afterExecution?.();
        }).then((data)=>{
            this.state.setCheckpoint({
                type: "function-resolved",
                data
            });
        }).catch((error)=>{
            this.state.setCheckpoint({
                type: "function-rejected",
                error
            });
        });
    }
    /**
	* Using middleware, transform input before running.
	*/ async transformInput() {
        const inputMutations = await this.state.hooks?.transformInput?.({
            ctx: {
                ...this.fnArg
            },
            steps: Object.values(this.state.stepState),
            fn: this.options.fn,
            reqArgs: this.options.reqArgs
        });
        if (inputMutations?.ctx) this.fnArg = inputMutations.ctx;
        if (inputMutations?.steps) this.state.stepState = Object.fromEntries(inputMutations.steps.map((step)=>[
                step.id,
                step
            ]));
    }
    /**
	* Using middleware, transform output before returning.
	*/ async transformOutput(dataOrError) {
        const output = {
            ...dataOrError
        };
        const isStepExecution = Boolean(this.state.executingStep);
        const transformedOutput = await this.state.hooks?.transformOutput?.({
            result: {
                ...output
            },
            step: this.state.executingStep
        });
        const { data, error } = {
            ...output,
            ...transformedOutput?.result
        };
        if (!isStepExecution) await this.state.hooks?.finished?.({
            result: {
                ...typeof error !== "undefined" ? {
                    error
                } : {
                    data
                }
            }
        });
        if (typeof error !== "undefined") {
            /**
			* Ensure we give middleware the chance to decide on retriable behaviour
			* by looking at the error returned from output transformation.
			*/ let retriable = !(error instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$components$2f$NonRetriableError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NonRetriableError"] || error instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$components$2f$StepError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["StepError"] && error === this.state.recentlyRejectedStepError);
            if (retriable && error instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$components$2f$RetryAfterError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["RetryAfterError"]) retriable = error.retryAfter;
            const serializedError = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$errors$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["minifyPrettyError"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$errors$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["serializeError"])(error));
            return {
                type: "function-rejected",
                ctx: this.fnArg,
                ops: this.ops,
                error: serializedError,
                retriable
            };
        }
        return {
            type: "function-resolved",
            ctx: this.fnArg,
            ops: this.ops,
            data: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$functions$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["undefinedToNull"])(data)
        };
    }
    createExecutionState() {
        const d = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$promises$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createDeferredPromiseWithStack"])();
        let checkpointResolve = d.deferred.resolve;
        const checkpointResults = d.results;
        const loop = async function*(cleanUp) {
            try {
                while(true){
                    const res = (await checkpointResults.next()).value;
                    if (res) yield res;
                }
            } finally{
                cleanUp?.();
            }
        }(()=>{
            this.timeout?.clear();
            checkpointResults.return();
        });
        const stepsToFulfill = Object.keys(this.options.stepState).length;
        return {
            stepState: this.options.stepState,
            stepsToFulfill,
            steps: /* @__PURE__ */ new Map(),
            loop,
            hasSteps: Boolean(stepsToFulfill),
            stepCompletionOrder: [
                ...this.options.stepCompletionOrder
            ],
            remainingStepsToBeSeen: new Set(this.options.stepCompletionOrder),
            setCheckpoint: (checkpoint)=>{
                ({ resolve: checkpointResolve } = checkpointResolve(checkpoint));
            },
            allStateUsed: ()=>{
                return this.state.remainingStepsToBeSeen.size === 0;
            }
        };
    }
    get ops() {
        return Object.fromEntries(this.state.steps);
    }
    createFnArg() {
        const step = this.createStepTools();
        let fnArg = {
            ...this.options.data,
            step
        };
        /**
		* Handle use of the `onFailure` option by deserializing the error.
		*/ if (this.options.isFailureHandler) {
            const eventData = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
                error: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["jsonErrorSchema"]
            }).parse(fnArg.event?.data);
            fnArg = {
                ...fnArg,
                error: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$errors$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["deserializeError"])(eventData.error)
            };
        }
        return this.options.transformCtx?.(fnArg) ?? fnArg;
    }
    createStepTools() {
        /**
		* A list of steps that have been found and are being rolled up before being
		* reported to the core loop.
		*/ const foundStepsToReport = /* @__PURE__ */ new Map();
        /**
		* A map of the subset of found steps to report that have not yet been
		* handled. Used for fast access to steps that need to be handled in order.
		*/ const unhandledFoundStepsToReport = /* @__PURE__ */ new Map();
        /**
		* A map of the latest sequential step indexes found for each step ID. Used
		* to ensure that we don't index steps in parallel.
		*
		* Note that these must be sequential; if we've seen or assigned `a:1`,
		* `a:2` and `a:4`, the latest sequential step index is `2`.
		*
		*/ const expectedNextStepIndexes = /* @__PURE__ */ new Map();
        /**
		* A promise that's used to ensure that step reporting cannot be run more than
		* once in a given asynchronous time span.
		*/ let foundStepsReportPromise;
        /**
		* A promise that's used to represent middleware hooks running before
		* execution.
		*/ let beforeExecHooksPromise;
        /**
		* A helper used to report steps to the core loop. Used after adding an item
		* to `foundStepsToReport`.
		*/ const reportNextTick = ()=>{
            if (foundStepsReportPromise) return;
            foundStepsReportPromise = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$promises$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["resolveNextTick"])().then(()=>beforeExecHooksPromise).then(()=>{
                foundStepsReportPromise = void 0;
                for (const [hashedId, step] of unhandledFoundStepsToReport)if (step.handle()) {
                    unhandledFoundStepsToReport.delete(hashedId);
                    if (step.fulfilled) foundStepsToReport.delete(step.id);
                }
                if (foundStepsToReport.size) {
                    const steps = [
                        ...foundStepsToReport.values()
                    ];
                    foundStepsToReport.clear();
                    this.state.setCheckpoint({
                        type: "steps-found",
                        steps
                    });
                    return;
                }
            });
        };
        /**
		* A helper used to push a step to the list of steps to report.
		*/ const pushStepToReport = (step)=>{
            foundStepsToReport.set(step.id, step);
            unhandledFoundStepsToReport.set(step.hashedId, step);
            reportNextTick();
        };
        const stepHandler = async ({ args, matchOp, opts })=>{
            await beforeExecHooksPromise;
            const opId = matchOp((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$components$2f$InngestStepTools$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getStepOptions"])(args[0]), ...args.slice(1));
            if (this.state.executingStep) /**
			* If a step is found after asynchronous actions during another step's
			* execution, everything is fine. The problem here is if we've found
			* that a step nested inside another a step, which is something we don't
			* support at the time of writing.
			*
			* In this case, we could use something like Async Hooks to understand
			* how the step is being triggered, though this isn't available in all
			* environments.
			*
			* Therefore, we'll only show a warning here to indicate that this is
			* potentially an issue.
			*/ console.warn((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$errors$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["prettyError"])({
                whatHappened: `We detected that you have nested \`step.*\` tooling in \`${opId.displayName ?? opId.id}\``,
                consequences: "Nesting `step.*` tooling is not supported.",
                type: "warn",
                reassurance: "It's possible to see this warning if steps are separated by regular asynchronous calls, which is fine.",
                stack: true,
                toFixNow: "Make sure you're not using `step.*` tooling inside of other `step.*` tooling. If you need to compose steps together, you can create a new async function and call it from within your step function, or use promise chaining.",
                code: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$errors$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ErrCode"].NESTING_STEPS
            }));
            if (this.state.steps.has(opId.id)) {
                const originalId = opId.id;
                const expectedNextIndex = expectedNextStepIndexes.get(originalId) ?? 1;
                for(let i = expectedNextIndex;; i++){
                    const newId = originalId + __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$components$2f$InngestStepTools$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["STEP_INDEXING_SUFFIX"] + i;
                    if (!this.state.steps.has(newId)) {
                        expectedNextStepIndexes.set(originalId, i + 1);
                        opId.id = newId;
                        opId.userland.index = i;
                        break;
                    }
                }
            }
            const { promise, resolve, reject } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$promises$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createDeferredPromise"])();
            const hashedId = _internals.hashId(opId.id);
            const stepState = this.state.stepState[hashedId];
            let isFulfilled = false;
            if (stepState) {
                stepState.seen = true;
                this.state.remainingStepsToBeSeen.delete(hashedId);
                if (typeof stepState.input === "undefined") isFulfilled = true;
            }
            let extraOpts;
            let fnArgs = [
                ...args
            ];
            if (typeof stepState?.input !== "undefined" && Array.isArray(stepState.input)) switch(opId.op){
                case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["StepOpCode"].StepPlanned:
                    fnArgs = [
                        ...args.slice(0, 2),
                        ...stepState.input
                    ];
                    extraOpts = {
                        input: [
                            ...stepState.input
                        ]
                    };
                    break;
                case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["StepOpCode"].AiGateway:
                    extraOpts = {
                        body: {
                            ...typeof opId.opts?.body === "object" ? {
                                ...opId.opts.body
                            } : {},
                            ...stepState.input[0]
                        }
                    };
                    break;
            }
            const step = {
                ...opId,
                opts: {
                    ...opId.opts,
                    ...extraOpts
                },
                rawArgs: fnArgs,
                hashedId,
                input: stepState?.input,
                fn: opts?.fn ? ()=>opts.fn?.(...fnArgs) : void 0,
                promise,
                fulfilled: isFulfilled,
                hasStepState: Boolean(stepState),
                displayName: opId.displayName ?? opId.id,
                handled: false,
                handle: ()=>{
                    if (step.handled) return false;
                    step.handled = true;
                    if (isFulfilled && stepState) {
                        stepState.fulfilled = true;
                        Promise.all([
                            stepState.data,
                            stepState.error,
                            stepState.input
                        ]).then(()=>{
                            if (typeof stepState.data !== "undefined") resolve(stepState.data);
                            else {
                                this.state.recentlyRejectedStepError = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$components$2f$StepError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["StepError"](opId.id, stepState.error);
                                reject(this.state.recentlyRejectedStepError);
                            }
                        });
                    }
                    return true;
                }
            };
            this.state.steps.set(opId.id, step);
            this.state.hasSteps = true;
            pushStepToReport(step);
            /**
			* If this is the last piece of state we had, we've now finished
			* memoizing.
			*/ if (!beforeExecHooksPromise && this.state.allStateUsed()) await (beforeExecHooksPromise = (async ()=>{
                await this.state.hooks?.afterMemoization?.();
                await this.state.hooks?.beforeExecution?.();
            })());
            return promise;
        };
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$components$2f$InngestStepTools$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createStepTools"])(this.options.client, this, stepHandler);
    }
    getUserFnToRun() {
        if (!this.options.isFailureHandler) return this.options.fn["fn"];
        if (!this.options.fn["onFailureFn"]) /**
		* Somehow, we've ended up detecting that this is a failure handler but
		* doesn't have an `onFailure` function. This should never happen.
		*/ throw new Error("Cannot find function `onFailure` handler");
        return this.options.fn["onFailureFn"];
    }
    initializeTimer(state) {
        if (!this.options.requestedRunStep) return;
        this.timeout = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$promises$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createTimeoutPromise"])(this.timeoutDuration);
        this.timeout.then(async ()=>{
            await this.state.hooks?.afterMemoization?.();
            await this.state.hooks?.beforeExecution?.();
            await this.state.hooks?.afterExecution?.();
            state.setCheckpoint({
                type: "step-not-found",
                step: {
                    id: this.options.requestedRunStep,
                    op: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["StepOpCode"].StepNotFound
                }
            });
        });
    }
    async initializeMiddleware() {
        const ctx = this.options.data;
        return await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$components$2f$InngestMiddleware$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getHookStack"])(this.options.fn["middleware"], "onFunctionRun", {
            ctx,
            fn: this.options.fn,
            steps: Object.values(this.options.stepState),
            reqArgs: this.options.reqArgs
        }, {
            transformInput: (prev, output)=>{
                return {
                    ctx: {
                        ...prev.ctx,
                        ...output?.ctx
                    },
                    fn: this.options.fn,
                    steps: prev.steps.map((step, i)=>({
                            ...step,
                            ...output?.steps?.[i]
                        })),
                    reqArgs: prev.reqArgs
                };
            },
            transformOutput: (prev, output)=>{
                return {
                    result: {
                        ...prev.result,
                        ...output?.result
                    },
                    step: prev.step
                };
            }
        });
    }
};
const hashId = (id)=>{
    return sha1().update(id).digest("hex");
};
const hashOp = (op)=>{
    return {
        ...op,
        id: hashId(op.id)
    };
};
/**
* Exported for testing.
*/ const _internals = {
    hashOp,
    hashId
};
;
 //# sourceMappingURL=v2.js.map
}}),
"[project]/node_modules/.pnpm/inngest@3.45.1_@opentelemetry+core@2.2.0_@opentelemetry+api@1.9.0__express@4.21.2_next@_c75e0c332defb7a954d9a52cadcbb8f7/node_modules/inngest/components/execution/v1.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "_internals": (()=>_internals),
    "createV1InngestExecution": (()=>createV1InngestExecution),
    "v1_exports": (()=>v1_exports)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$_virtual$2f$rolldown_runtime$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/inngest@3.45.1_@opentelemetry+core@2.2.0_@opentelemetry+api@1.9.0__express@4.21.2_next@_c75e0c332defb7a954d9a52cadcbb8f7/node_modules/inngest/_virtual/rolldown_runtime.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$components$2f$execution$2f$als$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/inngest@3.45.1_@opentelemetry+core@2.2.0_@opentelemetry+api@1.9.0__express@4.21.2_next@_c75e0c332defb7a954d9a52cadcbb8f7/node_modules/inngest/components/execution/als.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$version$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/inngest@3.45.1_@opentelemetry+core@2.2.0_@opentelemetry+api@1.9.0__express@4.21.2_next@_c75e0c332defb7a954d9a52cadcbb8f7/node_modules/inngest/version.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/inngest@3.45.1_@opentelemetry+core@2.2.0_@opentelemetry+api@1.9.0__express@4.21.2_next@_c75e0c332defb7a954d9a52cadcbb8f7/node_modules/inngest/helpers/consts.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/inngest@3.45.1_@opentelemetry+core@2.2.0_@opentelemetry+api@1.9.0__express@4.21.2_next@_c75e0c332defb7a954d9a52cadcbb8f7/node_modules/inngest/types.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$components$2f$execution$2f$InngestExecution$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/inngest@3.45.1_@opentelemetry+core@2.2.0_@opentelemetry+api@1.9.0__express@4.21.2_next@_c75e0c332defb7a954d9a52cadcbb8f7/node_modules/inngest/components/execution/InngestExecution.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$components$2f$NonRetriableError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/inngest@3.45.1_@opentelemetry+core@2.2.0_@opentelemetry+api@1.9.0__express@4.21.2_next@_c75e0c332defb7a954d9a52cadcbb8f7/node_modules/inngest/components/NonRetriableError.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$errors$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/inngest@3.45.1_@opentelemetry+core@2.2.0_@opentelemetry+api@1.9.0__express@4.21.2_next@_c75e0c332defb7a954d9a52cadcbb8f7/node_modules/inngest/helpers/errors.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$functions$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/inngest@3.45.1_@opentelemetry+core@2.2.0_@opentelemetry+api@1.9.0__express@4.21.2_next@_c75e0c332defb7a954d9a52cadcbb8f7/node_modules/inngest/helpers/functions.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$components$2f$InngestMiddleware$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/inngest@3.45.1_@opentelemetry+core@2.2.0_@opentelemetry+api@1.9.0__express@4.21.2_next@_c75e0c332defb7a954d9a52cadcbb8f7/node_modules/inngest/components/InngestMiddleware.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$components$2f$execution$2f$otel$2f$access$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/inngest@3.45.1_@opentelemetry+core@2.2.0_@opentelemetry+api@1.9.0__express@4.21.2_next@_c75e0c332defb7a954d9a52cadcbb8f7/node_modules/inngest/components/execution/otel/access.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$promises$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/inngest@3.45.1_@opentelemetry+core@2.2.0_@opentelemetry+api@1.9.0__express@4.21.2_next@_c75e0c332defb7a954d9a52cadcbb8f7/node_modules/inngest/helpers/promises.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$components$2f$RetryAfterError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/inngest@3.45.1_@opentelemetry+core@2.2.0_@opentelemetry+api@1.9.0__express@4.21.2_next@_c75e0c332defb7a954d9a52cadcbb8f7/node_modules/inngest/components/RetryAfterError.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$components$2f$StepError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/inngest@3.45.1_@opentelemetry+core@2.2.0_@opentelemetry+api@1.9.0__express@4.21.2_next@_c75e0c332defb7a954d9a52cadcbb8f7/node_modules/inngest/components/StepError.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$components$2f$InngestStepTools$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/inngest@3.45.1_@opentelemetry+core@2.2.0_@opentelemetry+api@1.9.0__express@4.21.2_next@_c75e0c332defb7a954d9a52cadcbb8f7/node_modules/inngest/components/InngestStepTools.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/zod@3.25.76/node_modules/zod/v3/external.js [app-route] (ecmascript) <export * as z>");
var __TURBOPACK__imported__module__$5b$externals$5d2f$next$2f$dist$2f$compiled$2f40$opentelemetry$2f$api__$5b$external$5d$__$28$next$2f$dist$2f$compiled$2f40$opentelemetry$2f$api$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/next/dist/compiled/@opentelemetry/api [external] (next/dist/compiled/@opentelemetry/api, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$hash$2e$js$40$1$2e$1$2e$7$2f$node_modules$2f$hash$2e$js$2f$lib$2f$hash$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash.js [app-route] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
//#region src/components/execution/v1.ts
var v1_exports = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$_virtual$2f$rolldown_runtime$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["__export"])({
    _internals: ()=>_internals,
    createV1InngestExecution: ()=>createV1InngestExecution
});
const { sha1 } = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$hash$2e$js$40$1$2e$1$2e$7$2f$node_modules$2f$hash$2e$js$2f$lib$2f$hash$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"];
const createV1InngestExecution = (options)=>{
    return new V1InngestExecution(options);
};
var V1InngestExecution = class extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$components$2f$execution$2f$InngestExecution$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["InngestExecution"] {
    version = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ExecutionVersion"].V1;
    state;
    fnArg;
    checkpointHandlers;
    timeoutDuration = 1e3 * 10;
    execution;
    userFnToRun;
    /**
	* If we're supposed to run a particular step via `requestedRunStep`, this
	* will be a `Promise` that resolves after no steps have been found for
	* `timeoutDuration` milliseconds.
	*
	* If we're not supposed to run a particular step, this will be `undefined`.
	*/ timeout;
    constructor(options){
        super(options);
        /**
		* Check we have everything we need for checkpointing
		*/ if (this.options.stepMode === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["StepMode"].Sync) {
            if (!this.options.createResponse) throw new Error("createResponse is required for sync step mode");
        }
        this.userFnToRun = this.getUserFnToRun();
        this.state = this.createExecutionState();
        this.fnArg = this.createFnArg();
        this.checkpointHandlers = this.options.stepMode === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["StepMode"].Sync ? this.createCheckpointingCheckpointHandlers() : this.createCheckpointHandlers();
        this.initializeTimer(this.state);
        this.debug("created new V1 execution for run;", this.options.requestedRunStep ? `wanting to run step "${this.options.requestedRunStep}"` : "discovering steps");
        this.debug("existing state keys:", Object.keys(this.state.stepState));
    }
    /**
	* Idempotently start the execution of the user's function.
	*/ start() {
        if (!this.execution) {
            this.debug("starting V1 execution");
            const tracer = __TURBOPACK__imported__module__$5b$externals$5d2f$next$2f$dist$2f$compiled$2f40$opentelemetry$2f$api__$5b$external$5d$__$28$next$2f$dist$2f$compiled$2f40$opentelemetry$2f$api$2c$__cjs$29$__["trace"].getTracer("inngest", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$version$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["version"]);
            this.execution = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$components$2f$execution$2f$als$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getAsyncLocalStorage"])().then((als)=>{
                return als.run({
                    app: this.options.client,
                    execution: {
                        ctx: this.fnArg,
                        instance: this
                    }
                }, async ()=>{
                    return tracer.startActiveSpan("inngest.execution", (span)=>{
                        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$components$2f$execution$2f$otel$2f$access$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["clientProcessorMap"].get(this.options.client)?.declareStartingSpan({
                            span,
                            runId: this.options.runId,
                            traceparent: this.options.headers[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["headerKeys"].TraceParent],
                            tracestate: this.options.headers[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["headerKeys"].TraceState]
                        });
                        return this._start().then((result)=>{
                            this.debug("result:", result);
                            return result;
                        }).finally(()=>{
                            span.end();
                        });
                    });
                });
            });
        }
        return this.execution;
    }
    /**
	* Starts execution of the user's function and the core loop.
	*/ async _start() {
        try {
            const allCheckpointHandler = this.getCheckpointHandler("");
            this.state.hooks = await this.initializeMiddleware();
            await this.startExecution();
            let i = 0;
            for await (const checkpoint of this.state.loop){
                await allCheckpointHandler(checkpoint, i);
                const result = await this.getCheckpointHandler(checkpoint.type)(checkpoint, i++);
                if (result) return result;
            }
        } catch (error) {
            return await this.transformOutput({
                error
            });
        } finally{
            this.state.loop.return();
            await this.state.hooks?.beforeResponse?.();
        }
        /**
		* If we're here, the generator somehow finished without returning a value.
		* This should never happen.
		*/ throw new Error("Core loop finished without returning a value");
    }
    async checkpoint(steps) {
        if (!this.state.checkpointedRun) {
            const res = await this.options.client["inngestApi"].checkpointNewRun({
                runId: this.fnArg.runId,
                event: this.fnArg.event,
                steps
            });
            this.state.checkpointedRun = {
                appId: res.data.app_id,
                fnId: res.data.fn_id,
                token: res.data.token
            };
        } else await this.options.client["inngestApi"].checkpointSteps({
            appId: this.state.checkpointedRun.appId,
            fnId: this.state.checkpointedRun.fnId,
            runId: this.fnArg.runId,
            steps
        });
    }
    async checkpointAndSwitchToAsync(steps) {
        await this.checkpoint(steps);
        if (!this.state.checkpointedRun?.token) throw new Error("Failed to checkpoint and switch to async mode");
        return {
            type: "change-mode",
            ctx: this.fnArg,
            ops: this.ops,
            to: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["StepMode"].Async,
            token: this.state.checkpointedRun?.token
        };
    }
    /**
	* Returns whether we're in the final attempt of execution, or `null` if we
	* can't determine this in the SDK.
	*/ inFinalAttempt() {
        if (typeof this.fnArg.maxAttempts !== "number") return null;
        return this.fnArg.attempt + 1 >= this.fnArg.maxAttempts;
    }
    createCheckpointingCheckpointHandlers() {
        return {
            "": async (checkpoint, i)=>{
                this.debug("sync checkpoint:", checkpoint);
            },
            "function-resolved": async (checkpoint, i)=>{
                await this.checkpoint([
                    {
                        op: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["StepOpCode"].RunComplete,
                        id: _internals.hashId("complete"),
                        data: await this.options.createResponse(checkpoint.data)
                    }
                ]);
                return {
                    type: "function-resolved",
                    ctx: this.fnArg,
                    ops: this.ops,
                    data: checkpoint.data
                };
            },
            "function-rejected": (checkpoint)=>{
                if (this.inFinalAttempt()) return {
                    type: "function-rejected",
                    ctx: this.fnArg,
                    error: checkpoint.error,
                    ops: this.ops,
                    retriable: false
                };
                return this.checkpointAndSwitchToAsync([
                    {
                        id: _internals.hashId("complete"),
                        displayName: "complete",
                        op: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["StepOpCode"].StepError,
                        error: checkpoint.error
                    }
                ]);
            },
            "step-not-found": ({ step })=>{
                return {
                    type: "function-rejected",
                    ctx: this.fnArg,
                    error: /* @__PURE__ */ new Error("Step not found when checkpointing; this should never happen"),
                    ops: this.ops,
                    retriable: false
                };
            },
            "steps-found": async ({ steps })=>{
                if (steps.length !== 1 || steps[0].mode !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["StepMode"].Sync) return this.checkpointAndSwitchToAsync(steps.map((step$1)=>({
                        ...step$1,
                        id: step$1.hashedId
                    })));
                const step = this.state.steps.get(steps[0].id);
                if (!step) throw new Error("Step not found in memoization state; this should never happen and is a bug in the Inngest SDK");
                const start = Date.now();
                const result = await this.executeStep(step);
                const interval = {
                    a: start * 1e6,
                    b: (Date.now() - start) * 1e6
                };
                if (result.error) {
                    await this.checkpoint([
                        {
                            ...step,
                            op: step.op === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["StepOpCode"].StepPlanned ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["StepOpCode"].StepError : step.op,
                            error: result.error
                        }
                    ]);
                    if (!this.state.checkpointedRun?.token) throw new Error("Failed to checkpoint and switch to async mode as no token was returned from the API");
                    return {
                        type: "change-mode",
                        ctx: this.fnArg,
                        ops: this.ops,
                        to: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["StepMode"].Async,
                        token: this.state.checkpointedRun.token
                    };
                }
                if ("data" in result) {
                    step.data = result.data;
                    this.state.stepState[steps[0].hashedId] = step;
                    step.fulfilled = true;
                    await this.checkpoint([
                        {
                            id: step.hashedId,
                            data: step.data,
                            op: step.op === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["StepOpCode"].StepPlanned ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["StepOpCode"].StepRun : step.op,
                            displayName: step.displayName,
                            opts: step.opts,
                            userland: step.userland,
                            name: step.name,
                            timing: interval
                        }
                    ]);
                    step.handle();
                    return;
                }
                throw new Error("A step was run and had no data or error; this is a bug in the Inngest SDK");
            }
        };
    }
    /**
	* Creates a handler for every checkpoint type, defining what to do when we
	* reach that checkpoint in the core loop.
	*/ createCheckpointHandlers() {
        return {
            "": (checkpoint)=>{
                this.debug("async checkpoint:", checkpoint);
            },
            "function-resolved": async ({ data })=>{
                if (this.options.createResponse) data = await this.options.createResponse(data);
                return await this.transformOutput({
                    data
                });
            },
            "function-rejected": async (checkpoint)=>{
                return await this.transformOutput({
                    error: checkpoint.error
                });
            },
            "steps-found": async ({ steps })=>{
                const stepResult = await this.tryExecuteStep(steps);
                if (stepResult) {
                    const transformResult = await this.transformOutput(stepResult);
                    /**
					* Transforming output will always return either function rejection or
					* resolution. In most cases, this can be immediately returned, but in
					* this particular case we want to handle it differently.
					*/ if (transformResult.type === "function-resolved") return {
                        type: "step-ran",
                        ctx: transformResult.ctx,
                        ops: transformResult.ops,
                        step: _internals.hashOp({
                            ...stepResult,
                            data: transformResult.data
                        })
                    };
                    else if (transformResult.type === "function-rejected") {
                        const stepForResponse = _internals.hashOp({
                            ...stepResult,
                            error: transformResult.error
                        });
                        if (stepResult.op === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["StepOpCode"].StepFailed) {
                            const ser = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$errors$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["serializeError"])(transformResult.error);
                            stepForResponse.data = {
                                __serialized: true,
                                name: ser.name,
                                message: ser.message,
                                stack: ""
                            };
                        }
                        return {
                            type: "step-ran",
                            ctx: transformResult.ctx,
                            ops: transformResult.ops,
                            retriable: transformResult.retriable,
                            step: stepForResponse
                        };
                    }
                    return transformResult;
                }
                const newSteps = await this.filterNewSteps(Array.from(this.state.steps.values()));
                if (newSteps) return {
                    type: "steps-found",
                    ctx: this.fnArg,
                    ops: this.ops,
                    steps: newSteps
                };
            },
            "step-not-found": ({ step })=>{
                return {
                    type: "step-not-found",
                    ctx: this.fnArg,
                    ops: this.ops,
                    step
                };
            }
        };
    }
    getCheckpointHandler(type) {
        return this.checkpointHandlers[type];
    }
    async tryExecuteStep(steps) {
        const hashedStepIdToRun = this.options.requestedRunStep || this.getEarlyExecRunStep(steps);
        if (!hashedStepIdToRun) return;
        const step = steps.find((step$1)=>step$1.hashedId === hashedStepIdToRun && step$1.fn);
        if (step) return await this.executeStep(step);
        this.timeout?.reset();
    }
    /**
	* Given a list of outgoing ops, decide if we can execute an op early and
	* return the ID of the step to execute if we can.
	*/ getEarlyExecRunStep(steps) {
        /**
		* We may have been disabled due to parallelism, in which case we can't
		* immediately execute unless explicitly requested.
		*/ if (this.options.disableImmediateExecution) return;
        const unfulfilledSteps = steps.filter((step)=>!step.fulfilled);
        if (unfulfilledSteps.length !== 1) return;
        const op = unfulfilledSteps[0];
        if (op && op.op === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["StepOpCode"].StepPlanned) return op.hashedId;
    }
    async filterNewSteps(foundSteps) {
        if (this.options.requestedRunStep) return;
        /**
		* Gather any steps that aren't memoized and report them.
		*/ const newSteps = foundSteps.filter((step)=>!step.fulfilled);
        if (!newSteps.length) return;
        /**
		* Warn if we've found new steps but haven't yet seen all previous
		* steps. This may indicate that step presence isn't determinate.
		*/ let knownSteps = 0;
        for (const step of foundSteps)if (step.fulfilled) knownSteps++;
        if (!(this.state.stepsToFulfill === knownSteps)) console.warn((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$errors$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["prettyError"])({
            type: "warn",
            whatHappened: "Function may be indeterminate",
            why: "We found new steps before seeing all previous steps, which may indicate that the function is non-deterministic.",
            consequences: "This may cause unexpected behaviour as Inngest executes your function.",
            reassurance: "This is expected if a function is updated in the middle of a run, but may indicate a bug if not."
        }));
        /**
		* We're finishing up; let's trigger the last of the hooks.
		*/ await this.state.hooks?.afterMemoization?.();
        await this.state.hooks?.beforeExecution?.();
        await this.state.hooks?.afterExecution?.();
        const stepList = newSteps.map((step)=>({
                displayName: step.displayName,
                op: step.op,
                id: step.hashedId,
                name: step.name,
                opts: step.opts,
                userland: step.userland
            }));
        /**
		* We also run `onSendEvent` middleware hooks against `step.invoke()` steps
		* to ensure that their `data` is transformed correctly.
		*/ return await this.transformNewSteps(stepList);
    }
    /**
	* Using middleware, transform any newly-found steps before returning them to
	* an Inngest Server.
	*/ async transformNewSteps(steps) {
        return Promise.all(steps.map(async (step)=>{
            if (step.op !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["StepOpCode"].InvokeFunction) return step;
            /**
			* For each event being sent, create a new `onSendEvent` hook stack to
			* process it. We do this as middleware hooks are intended to run once
			* during each lifecycle (onFunctionRun or onSendEvent) and here, a hook
			* is run for every single event.
			*
			* This is done because a developer can use this hook to filter out
			* events entirely; if we batch all of the events together, we can't
			* tell which ones were filtered out if we're processing >1 invocation
			* here.
			*/ const transformedPayload = await (await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$components$2f$InngestMiddleware$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getHookStack"])(this.options.fn["middleware"], "onSendEvent", void 0, {
                transformInput: (prev, output)=>{
                    return {
                        ...prev,
                        ...output
                    };
                },
                transformOutput: (prev, output)=>{
                    return {
                        result: {
                            ...prev.result,
                            ...output?.result
                        }
                    };
                }
            })).transformInput?.({
                payloads: [
                    {
                        ...step.opts?.payload ?? {},
                        name: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["internalEvents"].FunctionInvoked
                    }
                ]
            });
            const newPayload = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$components$2f$InngestStepTools$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["invokePayloadSchema"].parse(transformedPayload?.payloads?.[0] ?? {});
            return {
                ...step,
                opts: {
                    ...step.opts,
                    payload: {
                        ...step.opts?.payload ?? {},
                        ...newPayload
                    }
                }
            };
        }));
    }
    async executeStep({ id, name, opts, fn, displayName, userland }) {
        this.timeout?.clear();
        await this.state.hooks?.afterMemoization?.();
        await this.state.hooks?.beforeExecution?.();
        const outgoingOp = {
            id,
            op: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["StepOpCode"].StepRun,
            name,
            opts,
            displayName,
            userland
        };
        this.state.executingStep = outgoingOp;
        const store = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$components$2f$execution$2f$als$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getAsyncCtx"])();
        if (store?.execution) store.execution.executingStep = {
            id,
            name: displayName
        };
        this.debug(`executing step "${id}"`);
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$promises$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["runAsPromise"])(fn).finally(async ()=>{
            delete this.state.executingStep;
            if (store?.execution) delete store.execution.executingStep;
            await this.state.hooks?.afterExecution?.();
        }).then((data)=>{
            return {
                ...outgoingOp,
                data
            };
        }).catch((error)=>{
            let errorIsRetriable = true;
            if (error instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$components$2f$NonRetriableError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NonRetriableError"]) errorIsRetriable = false;
            else if (this.fnArg.maxAttempts && this.fnArg?.maxAttempts - 1 === this.fnArg.attempt) errorIsRetriable = false;
            if (errorIsRetriable) return {
                ...outgoingOp,
                op: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["StepOpCode"].StepError,
                error
            };
            else return {
                ...outgoingOp,
                op: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["StepOpCode"].StepFailed,
                error
            };
        });
    }
    /**
	* Starts execution of the user's function, including triggering checkpoints
	* and middleware hooks where appropriate.
	*/ async startExecution() {
        /**
		* Mutate input as neccessary based on middleware.
		*/ await this.transformInput();
        /**
		* Start the timer to time out the run if needed.
		*/ this.timeout?.start();
        await this.state.hooks?.beforeMemoization?.();
        /**
		* If we had no state to begin with, immediately end the memoization phase.
		*/ if (this.state.allStateUsed()) {
            await this.state.hooks?.afterMemoization?.();
            await this.state.hooks?.beforeExecution?.();
        }
        /**
		* Trigger the user's function.
		*/ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$promises$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["runAsPromise"])(()=>this.userFnToRun(this.fnArg)).finally(async ()=>{
            await this.state.hooks?.afterMemoization?.();
            await this.state.hooks?.beforeExecution?.();
            await this.state.hooks?.afterExecution?.();
        }).then((data)=>{
            this.state.setCheckpoint({
                type: "function-resolved",
                data
            });
        }).catch((error)=>{
            this.state.setCheckpoint({
                type: "function-rejected",
                error
            });
        });
    }
    /**
	* Using middleware, transform input before running.
	*/ async transformInput() {
        const inputMutations = await this.state.hooks?.transformInput?.({
            ctx: {
                ...this.fnArg
            },
            steps: Object.values(this.state.stepState),
            fn: this.options.fn,
            reqArgs: this.options.reqArgs
        });
        if (inputMutations?.ctx) this.fnArg = inputMutations.ctx;
        if (inputMutations?.steps) this.state.stepState = Object.fromEntries(inputMutations.steps.map((step)=>[
                step.id,
                step
            ]));
    }
    /**
	* Using middleware, transform output before returning.
	*/ async transformOutput(dataOrError) {
        const output = {
            ...dataOrError
        };
        const isStepExecution = Boolean(this.state.executingStep);
        const transformedOutput = await this.state.hooks?.transformOutput?.({
            result: {
                ...output
            },
            step: this.state.executingStep
        });
        const { data, error } = {
            ...output,
            ...transformedOutput?.result
        };
        if (!isStepExecution) await this.state.hooks?.finished?.({
            result: {
                ...typeof error !== "undefined" ? {
                    error
                } : {
                    data
                }
            }
        });
        if (typeof error !== "undefined") {
            /**
			* Ensure we give middleware the chance to decide on retriable behaviour
			* by looking at the error returned from output transformation.
			*/ let retriable = !(error instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$components$2f$NonRetriableError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NonRetriableError"] || error instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$components$2f$StepError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["StepError"] && error === this.state.recentlyRejectedStepError);
            if (retriable && error instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$components$2f$RetryAfterError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["RetryAfterError"]) retriable = error.retryAfter;
            const serializedError = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$errors$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["minifyPrettyError"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$errors$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["serializeError"])(error));
            return {
                type: "function-rejected",
                ctx: this.fnArg,
                ops: this.ops,
                error: serializedError,
                retriable
            };
        }
        return {
            type: "function-resolved",
            ctx: this.fnArg,
            ops: this.ops,
            data: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$functions$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["undefinedToNull"])(data)
        };
    }
    createExecutionState() {
        const d = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$promises$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createDeferredPromiseWithStack"])();
        let checkpointResolve = d.deferred.resolve;
        const checkpointResults = d.results;
        const loop = async function*(cleanUp) {
            try {
                while(true){
                    const res = (await checkpointResults.next()).value;
                    if (res) yield res;
                }
            } finally{
                cleanUp?.();
            }
        }(()=>{
            this.timeout?.clear();
            checkpointResults.return();
        });
        const stepsToFulfill = Object.keys(this.options.stepState).length;
        return {
            stepState: this.options.stepState,
            stepsToFulfill,
            steps: /* @__PURE__ */ new Map(),
            loop,
            hasSteps: Boolean(stepsToFulfill),
            stepCompletionOrder: [
                ...this.options.stepCompletionOrder
            ],
            remainingStepsToBeSeen: new Set(this.options.stepCompletionOrder),
            setCheckpoint: (checkpoint)=>{
                ({ resolve: checkpointResolve } = checkpointResolve(checkpoint));
            },
            allStateUsed: ()=>{
                return this.state.remainingStepsToBeSeen.size === 0;
            }
        };
    }
    get ops() {
        return Object.fromEntries(this.state.steps);
    }
    createFnArg() {
        const step = this.createStepTools();
        let fnArg = {
            ...this.options.data,
            step
        };
        /**
		* Handle use of the `onFailure` option by deserializing the error.
		*/ if (this.options.isFailureHandler) {
            const eventData = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
                error: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["jsonErrorSchema"]
            }).parse(fnArg.event?.data);
            fnArg = {
                ...fnArg,
                error: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$errors$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["deserializeError"])(eventData.error)
            };
        }
        return this.options.transformCtx?.(fnArg) ?? fnArg;
    }
    createStepTools() {
        /**
		* A list of steps that have been found and are being rolled up before being
		* reported to the core loop.
		*/ const foundStepsToReport = /* @__PURE__ */ new Map();
        /**
		* A map of the subset of found steps to report that have not yet been
		* handled. Used for fast access to steps that need to be handled in order.
		*/ const unhandledFoundStepsToReport = /* @__PURE__ */ new Map();
        /**
		* A map of the latest sequential step indexes found for each step ID. Used
		* to ensure that we don't index steps in parallel.
		*
		* Note that these must be sequential; if we've seen or assigned `a:1`,
		* `a:2` and `a:4`, the latest sequential step index is `2`.
		*
		*/ const expectedNextStepIndexes = /* @__PURE__ */ new Map();
        /**
		* An ordered list of step IDs that have yet to be handled in this
		* execution. Used to ensure that we handle steps in the order they were
		* found and based on the `stepCompletionOrder` in this execution's state.
		*/ const remainingStepCompletionOrder = this.state.stepCompletionOrder.slice();
        /**
		* A promise that's used to ensure that step reporting cannot be run more than
		* once in a given asynchronous time span.
		*/ let foundStepsReportPromise;
        /**
		* A promise that's used to represent middleware hooks running before
		* execution.
		*/ let beforeExecHooksPromise;
        /**
		* A flag used to ensure that we only warn about parallel indexing once per
		* execution to avoid spamming the console.
		*/ let warnOfParallelIndexing = false;
        /**
		* Counts the number of times we've extended this tick.
		*/ let tickExtensionCount = 0;
        /**
		* Given a colliding step ID, maybe warn the user about parallel indexing.
		*/ const maybeWarnOfParallelIndexing = (collisionId)=>{
            if (warnOfParallelIndexing) return;
            if (this.state.steps.has(collisionId)) {
                if (!foundStepsToReport.has(collisionId)) {
                    warnOfParallelIndexing = true;
                    console.warn((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$errors$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["prettyError"])({
                        type: "warn",
                        whatHappened: "We detected that you have multiple steps with the same ID.",
                        code: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$errors$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ErrCode"].AUTOMATIC_PARALLEL_INDEXING,
                        why: `This can happen if you're using the same ID for multiple steps across different chains of parallel work. We found the issue with step "${collisionId}".`,
                        reassurance: "Your function is still running, though it may exhibit unexpected behaviour.",
                        consequences: "Using the same IDs across parallel chains of work can cause unexpected behaviour.",
                        toFixNow: "We recommend using a unique ID for each step, especially those happening in parallel."
                    }));
                }
            }
        };
        /**
		* A helper used to report steps to the core loop. Used after adding an item
		* to `foundStepsToReport`.
		*/ const reportNextTick = ()=>{
            if (foundStepsReportPromise) return;
            let extensionPromise;
            if (++tickExtensionCount >= 10) {
                tickExtensionCount = 0;
                extensionPromise = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$promises$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["resolveNextTick"])();
            } else extensionPromise = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$promises$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["resolveAfterPending"])();
            foundStepsReportPromise = extensionPromise.then(()=>beforeExecHooksPromise).then(()=>{
                foundStepsReportPromise = void 0;
                for(let i = 0; i < remainingStepCompletionOrder.length; i++){
                    const nextStepId = remainingStepCompletionOrder[i];
                    if (!nextStepId) continue;
                    if (unhandledFoundStepsToReport.get(nextStepId)?.handle()) {
                        remainingStepCompletionOrder.splice(i, 1);
                        unhandledFoundStepsToReport.delete(nextStepId);
                        reportNextTick();
                        return;
                    }
                }
                const steps = [
                    ...foundStepsToReport.values()
                ];
                foundStepsToReport.clear();
                unhandledFoundStepsToReport.clear();
                this.state.setCheckpoint({
                    type: "steps-found",
                    steps
                });
            });
        };
        /**
		* A helper used to push a step to the list of steps to report.
		*/ const pushStepToReport = (step)=>{
            foundStepsToReport.set(step.id, step);
            unhandledFoundStepsToReport.set(step.hashedId, step);
            reportNextTick();
        };
        const stepHandler = async ({ args, matchOp, opts })=>{
            await beforeExecHooksPromise;
            const opId = matchOp((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$components$2f$InngestStepTools$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getStepOptions"])(args[0]), ...args.slice(1));
            if (this.state.executingStep) /**
			* If a step is found after asynchronous actions during another step's
			* execution, everything is fine. The problem here is if we've found
			* that a step nested inside another a step, which is something we don't
			* support at the time of writing.
			*
			* In this case, we could use something like Async Hooks to understand
			* how the step is being triggered, though this isn't available in all
			* environments.
			*
			* Therefore, we'll only show a warning here to indicate that this is
			* potentially an issue.
			*/ console.warn((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$errors$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["prettyError"])({
                whatHappened: `We detected that you have nested \`step.*\` tooling in \`${opId.displayName ?? opId.id}\``,
                consequences: "Nesting `step.*` tooling is not supported.",
                type: "warn",
                reassurance: "It's possible to see this warning if steps are separated by regular asynchronous calls, which is fine.",
                stack: true,
                toFixNow: "Make sure you're not using `step.*` tooling inside of other `step.*` tooling. If you need to compose steps together, you can create a new async function and call it from within your step function, or use promise chaining.",
                code: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$errors$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ErrCode"].NESTING_STEPS
            }));
            if (this.state.steps.has(opId.id)) {
                const originalId = opId.id;
                maybeWarnOfParallelIndexing(originalId);
                const expectedNextIndex = expectedNextStepIndexes.get(originalId) ?? 1;
                for(let i = expectedNextIndex;; i++){
                    const newId = originalId + __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$components$2f$InngestStepTools$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["STEP_INDEXING_SUFFIX"] + i;
                    if (!this.state.steps.has(newId)) {
                        expectedNextStepIndexes.set(originalId, i + 1);
                        opId.id = newId;
                        opId.userland.index = i;
                        break;
                    }
                }
            }
            const { promise, resolve, reject } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$promises$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createDeferredPromise"])();
            const hashedId = _internals.hashId(opId.id);
            const stepState = this.state.stepState[hashedId];
            let isFulfilled = false;
            if (stepState) {
                stepState.seen = true;
                this.state.remainingStepsToBeSeen.delete(hashedId);
                if (typeof stepState.input === "undefined") isFulfilled = true;
            }
            let extraOpts;
            let fnArgs = [
                ...args
            ];
            if (typeof stepState?.input !== "undefined" && Array.isArray(stepState.input)) switch(opId.op){
                case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["StepOpCode"].StepPlanned:
                    fnArgs = [
                        ...args.slice(0, 2),
                        ...stepState.input
                    ];
                    extraOpts = {
                        input: [
                            ...stepState.input
                        ]
                    };
                    break;
                case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["StepOpCode"].AiGateway:
                    extraOpts = {
                        body: {
                            ...typeof opId.opts?.body === "object" ? {
                                ...opId.opts.body
                            } : {},
                            ...stepState.input[0]
                        }
                    };
                    break;
            }
            const step = {
                ...opId,
                opts: {
                    ...opId.opts,
                    ...extraOpts
                },
                rawArgs: fnArgs,
                hashedId,
                input: stepState?.input,
                fn: opts?.fn ? ()=>opts.fn?.(...fnArgs) : void 0,
                promise,
                fulfilled: isFulfilled,
                hasStepState: Boolean(stepState),
                displayName: opId.displayName ?? opId.id,
                handled: false,
                handle: ()=>{
                    if (step.handled) return false;
                    step.handled = true;
                    const result = this.state.stepState[hashedId];
                    if (step.fulfilled && result) {
                        result.fulfilled = true;
                        Promise.all([
                            result.data,
                            result.error,
                            result.input
                        ]).then(()=>{
                            if (typeof result.data !== "undefined") resolve(result.data);
                            else {
                                this.state.recentlyRejectedStepError = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$components$2f$StepError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["StepError"](opId.id, result.error);
                                reject(this.state.recentlyRejectedStepError);
                            }
                        });
                    }
                    return true;
                }
            };
            this.state.steps.set(opId.id, step);
            this.state.hasSteps = true;
            pushStepToReport(step);
            /**
			* If this is the last piece of state we had, we've now finished
			* memoizing.
			*/ if (!beforeExecHooksPromise && this.state.allStateUsed()) await (beforeExecHooksPromise = (async ()=>{
                await this.state.hooks?.afterMemoization?.();
                await this.state.hooks?.beforeExecution?.();
            })());
            return promise;
        };
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$components$2f$InngestStepTools$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createStepTools"])(this.options.client, this, stepHandler);
    }
    getUserFnToRun() {
        if (!this.options.isFailureHandler) return this.options.fn["fn"];
        if (!this.options.fn["onFailureFn"]) /**
		* Somehow, we've ended up detecting that this is a failure handler but
		* doesn't have an `onFailure` function. This should never happen.
		*/ throw new Error("Cannot find function `onFailure` handler");
        return this.options.fn["onFailureFn"];
    }
    initializeTimer(state) {
        if (!this.options.requestedRunStep) return;
        this.timeout = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$promises$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createTimeoutPromise"])(this.timeoutDuration);
        this.timeout.then(async ()=>{
            await this.state.hooks?.afterMemoization?.();
            await this.state.hooks?.beforeExecution?.();
            await this.state.hooks?.afterExecution?.();
            state.setCheckpoint({
                type: "step-not-found",
                step: {
                    id: this.options.requestedRunStep,
                    op: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["StepOpCode"].StepNotFound
                }
            });
        });
    }
    async initializeMiddleware() {
        const ctx = this.options.data;
        return await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$components$2f$InngestMiddleware$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getHookStack"])(this.options.fn["middleware"], "onFunctionRun", {
            ctx,
            fn: this.options.fn,
            steps: Object.values(this.options.stepState),
            reqArgs: this.options.reqArgs
        }, {
            transformInput: (prev, output)=>{
                return {
                    ctx: {
                        ...prev.ctx,
                        ...output?.ctx
                    },
                    fn: this.options.fn,
                    steps: prev.steps.map((step, i)=>({
                            ...step,
                            ...output?.steps?.[i]
                        })),
                    reqArgs: prev.reqArgs
                };
            },
            transformOutput: (prev, output)=>{
                return {
                    result: {
                        ...prev.result,
                        ...output?.result
                    },
                    step: prev.step
                };
            }
        });
    }
};
const hashId = (id)=>{
    return sha1().update(id).digest("hex");
};
const hashOp = (op)=>{
    return {
        ...op,
        id: hashId(op.id)
    };
};
/**
* Exported for testing.
*/ const _internals = {
    hashOp,
    hashId
};
;
 //# sourceMappingURL=v1.js.map
}}),
"[project]/node_modules/.pnpm/inngest@3.45.1_@opentelemetry+core@2.2.0_@opentelemetry+api@1.9.0__express@4.21.2_next@_c75e0c332defb7a954d9a52cadcbb8f7/node_modules/inngest/components/InngestFunction.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "InngestFunction": (()=>InngestFunction)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/inngest@3.45.1_@opentelemetry+core@2.2.0_@opentelemetry+api@1.9.0__express@4.21.2_next@_c75e0c332defb7a954d9a52cadcbb8f7/node_modules/inngest/helpers/consts.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$strings$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/inngest@3.45.1_@opentelemetry+core@2.2.0_@opentelemetry+api@1.9.0__express@4.21.2_next@_c75e0c332defb7a954d9a52cadcbb8f7/node_modules/inngest/helpers/strings.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$components$2f$execution$2f$v0$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/inngest@3.45.1_@opentelemetry+core@2.2.0_@opentelemetry+api@1.9.0__express@4.21.2_next@_c75e0c332defb7a954d9a52cadcbb8f7/node_modules/inngest/components/execution/v0.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$components$2f$execution$2f$v2$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/inngest@3.45.1_@opentelemetry+core@2.2.0_@opentelemetry+api@1.9.0__express@4.21.2_next@_c75e0c332defb7a954d9a52cadcbb8f7/node_modules/inngest/components/execution/v2.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$components$2f$execution$2f$v1$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/inngest@3.45.1_@opentelemetry+core@2.2.0_@opentelemetry+api@1.9.0__express@4.21.2_next@_c75e0c332defb7a954d9a52cadcbb8f7/node_modules/inngest/components/execution/v1.js [app-route] (ecmascript)");
;
;
;
;
;
//#region src/components/InngestFunction.ts
/**
* A stateless Inngest function, wrapping up function configuration and any
* in-memory steps to run when triggered.
*
* This function can be "registered" to create a handler that Inngest can
* trigger remotely.
*
* @public
*/ var InngestFunction = class InngestFunction {
    static stepId = "step";
    static failureSuffix = "-failure";
    get [Symbol.toStringTag]() {
        return InngestFunction.Tag;
    }
    opts;
    fn;
    onFailureFn;
    client;
    middleware;
    /**
	* A stateless Inngest function, wrapping up function configuration and any
	* in-memory steps to run when triggered.
	*
	* This function can be "registered" to create a handler that Inngest can
	* trigger remotely.
	*/ constructor(client, opts, fn){
        this.client = client;
        this.opts = opts;
        this.fn = fn;
        this.onFailureFn = this.opts.onFailure;
        this.middleware = this.client["initializeMiddleware"](this.opts.middleware, {
            registerInput: {
                fn: this
            },
            prefixStack: this.client["middleware"]
        });
    }
    /**
	* The generated or given ID for this function.
	*/ id(prefix) {
        return [
            prefix,
            this.opts.id
        ].filter(Boolean).join("-");
    }
    /**
	* The generated or given ID for this function, prefixed with the app ID. This
	* is used for routing invokes and identifying the function across apps.
	*/ get absoluteId() {
        return this.id(this.client.id);
    }
    /**
	* The name of this function as it will appear in the Inngest Cloud UI.
	*/ get name() {
        return this.opts.name || this.id();
    }
    /**
	* The description of this function.
	*/ get description() {
        return this.opts.description;
    }
    /**
	* Retrieve the Inngest config for this function.
	*/ getConfig({ baseUrl, appPrefix, isConnect }) {
        const fnId = this.id(appPrefix);
        const stepUrl = new URL(baseUrl.href);
        stepUrl.searchParams.set(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["queryKeys"].FnId, fnId);
        stepUrl.searchParams.set(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["queryKeys"].StepId, InngestFunction.stepId);
        const { retries: attempts, cancelOn, idempotency, batchEvents, rateLimit, throttle, concurrency, debounce, timeouts, priority, singleton } = this.opts;
        /**
		* Convert retries into the format required when defining function
		* configuration.
		*/ const retries = typeof attempts === "undefined" ? void 0 : {
            attempts
        };
        const fn = {
            id: fnId,
            name: this.name,
            triggers: (this.opts.triggers ?? []).map((trigger)=>{
                if ("event" in trigger) return {
                    event: trigger.event,
                    expression: trigger.if
                };
                return {
                    cron: trigger.cron
                };
            }),
            steps: {
                [InngestFunction.stepId]: {
                    id: InngestFunction.stepId,
                    name: InngestFunction.stepId,
                    runtime: {
                        type: isConnect ? "ws" : "http",
                        url: stepUrl.href
                    },
                    retries
                }
            },
            idempotency,
            batchEvents,
            rateLimit,
            throttle,
            concurrency,
            debounce,
            priority,
            timeouts,
            singleton
        };
        if (cancelOn) fn.cancel = cancelOn.map(({ event, timeout, if: ifStr, match })=>{
            const ret = {
                event
            };
            if (timeout) ret.timeout = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$strings$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["timeStr"])(timeout);
            if (match) ret.if = `event.${match} == async.${match}`;
            else if (ifStr) ret.if = ifStr;
            return ret;
        }, []);
        const config = [
            fn
        ];
        if (this.onFailureFn) {
            const id = `${fn.id}${InngestFunction.failureSuffix}`;
            const name = `${fn.name ?? fn.id} (failure)`;
            const failureStepUrl = new URL(stepUrl.href);
            failureStepUrl.searchParams.set(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["queryKeys"].FnId, id);
            config.push({
                id,
                name,
                triggers: [
                    {
                        event: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["internalEvents"].FunctionFailed,
                        expression: `event.data.function_id == '${fnId}'`
                    }
                ],
                steps: {
                    [InngestFunction.stepId]: {
                        id: InngestFunction.stepId,
                        name: InngestFunction.stepId,
                        runtime: {
                            type: "http",
                            url: failureStepUrl.href
                        },
                        retries: {
                            attempts: 1
                        }
                    }
                }
            });
        }
        return config;
    }
    createExecution(opts) {
        const options = {
            fn: this,
            ...opts.partialOptions
        };
        return ({
            [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ExecutionVersion"].V2]: ()=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$components$2f$execution$2f$v2$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createV2InngestExecution"])(options),
            [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ExecutionVersion"].V1]: ()=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$components$2f$execution$2f$v1$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createV1InngestExecution"])(options),
            [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ExecutionVersion"].V0]: ()=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$components$2f$execution$2f$v0$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createV0InngestExecution"])(options)
        })[opts.version]();
    }
    shouldOptimizeParallelism() {
        return this.opts.optimizeParallelism ?? this.client["options"].optimizeParallelism ?? false;
    }
};
(function(_InngestFunction) {
    _InngestFunction.Tag = "Inngest.Function";
})(InngestFunction || (InngestFunction = {}));
;
 //# sourceMappingURL=InngestFunction.js.map
}}),
"[project]/node_modules/.pnpm/inngest@3.45.1_@opentelemetry+core@2.2.0_@opentelemetry+api@1.9.0__express@4.21.2_next@_c75e0c332defb7a954d9a52cadcbb8f7/node_modules/inngest/components/InngestCommHandler.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "InngestCommHandler": (()=>InngestCommHandler)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$components$2f$execution$2f$als$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/inngest@3.45.1_@opentelemetry+core@2.2.0_@opentelemetry+api@1.9.0__express@4.21.2_next@_c75e0c332defb7a954d9a52cadcbb8f7/node_modules/inngest/components/execution/als.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$version$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/inngest@3.45.1_@opentelemetry+core@2.2.0_@opentelemetry+api@1.9.0__express@4.21.2_next@_c75e0c332defb7a954d9a52cadcbb8f7/node_modules/inngest/version.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/inngest@3.45.1_@opentelemetry+core@2.2.0_@opentelemetry+api@1.9.0__express@4.21.2_next@_c75e0c332defb7a954d9a52cadcbb8f7/node_modules/inngest/helpers/consts.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/inngest@3.45.1_@opentelemetry+core@2.2.0_@opentelemetry+api@1.9.0__express@4.21.2_next@_c75e0c332defb7a954d9a52cadcbb8f7/node_modules/inngest/types.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$components$2f$execution$2f$InngestExecution$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/inngest@3.45.1_@opentelemetry+core@2.2.0_@opentelemetry+api@1.9.0__express@4.21.2_next@_c75e0c332defb7a954d9a52cadcbb8f7/node_modules/inngest/components/execution/InngestExecution.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$errors$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/inngest@3.45.1_@opentelemetry+core@2.2.0_@opentelemetry+api@1.9.0__express@4.21.2_next@_c75e0c332defb7a954d9a52cadcbb8f7/node_modules/inngest/helpers/errors.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$functions$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/inngest@3.45.1_@opentelemetry+core@2.2.0_@opentelemetry+api@1.9.0__express@4.21.2_next@_c75e0c332defb7a954d9a52cadcbb8f7/node_modules/inngest/helpers/functions.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$strings$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/inngest@3.45.1_@opentelemetry+core@2.2.0_@opentelemetry+api@1.9.0__express@4.21.2_next@_c75e0c332defb7a954d9a52cadcbb8f7/node_modules/inngest/helpers/strings.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$env$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/inngest@3.45.1_@opentelemetry+core@2.2.0_@opentelemetry+api@1.9.0__express@4.21.2_next@_c75e0c332defb7a954d9a52cadcbb8f7/node_modules/inngest/helpers/env.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$devserver$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/inngest@3.45.1_@opentelemetry+core@2.2.0_@opentelemetry+api@1.9.0__express@4.21.2_next@_c75e0c332defb7a954d9a52cadcbb8f7/node_modules/inngest/helpers/devserver.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$enum$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/inngest@3.45.1_@opentelemetry+core@2.2.0_@opentelemetry+api@1.9.0__express@4.21.2_next@_c75e0c332defb7a954d9a52cadcbb8f7/node_modules/inngest/helpers/enum.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$net$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/inngest@3.45.1_@opentelemetry+core@2.2.0_@opentelemetry+api@1.9.0__express@4.21.2_next@_c75e0c332defb7a954d9a52cadcbb8f7/node_modules/inngest/helpers/net.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$promises$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/inngest@3.45.1_@opentelemetry+core@2.2.0_@opentelemetry+api@1.9.0__express@4.21.2_next@_c75e0c332defb7a954d9a52cadcbb8f7/node_modules/inngest/helpers/promises.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$ServerTiming$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/inngest@3.45.1_@opentelemetry+core@2.2.0_@opentelemetry+api@1.9.0__express@4.21.2_next@_c75e0c332defb7a954d9a52cadcbb8f7/node_modules/inngest/helpers/ServerTiming.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$stream$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/inngest@3.45.1_@opentelemetry+core@2.2.0_@opentelemetry+api@1.9.0__express@4.21.2_next@_c75e0c332defb7a954d9a52cadcbb8f7/node_modules/inngest/helpers/stream.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$components$2f$InngestFunction$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/inngest@3.45.1_@opentelemetry+core@2.2.0_@opentelemetry+api@1.9.0__express@4.21.2_next@_c75e0c332defb7a954d9a52cadcbb8f7/node_modules/inngest/components/InngestFunction.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$components$2f$execution$2f$v1$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/inngest@3.45.1_@opentelemetry+core@2.2.0_@opentelemetry+api@1.9.0__express@4.21.2_next@_c75e0c332defb7a954d9a52cadcbb8f7/node_modules/inngest/components/execution/v1.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$debug$40$4$2e$4$2e$3$2f$node_modules$2f$debug$2f$src$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/debug@4.4.3/node_modules/debug/src/index.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$ulid$40$2$2e$4$2e$0$2f$node_modules$2f$ulid$2f$dist$2f$index$2e$esm$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/ulid@2.4.0/node_modules/ulid/dist/index.esm.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/zod@3.25.76/node_modules/zod/v3/external.js [app-route] (ecmascript) <export * as z>");
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
//#region src/components/InngestCommHandler.ts
/**
* A schema for the response from Inngest when registering.
*/ const registerResSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
    status: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].number().default(200),
    skipped: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].boolean().optional().default(false),
    modified: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].boolean().optional().default(false),
    error: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().default("Successfully registered")
});
/**
* `InngestCommHandler` is a class for handling incoming requests from Inngest (or
* Inngest's tooling such as the dev server or CLI) and taking appropriate
* action for any served functions.
*
* All handlers (Next.js, RedwoodJS, Remix, Deno Fresh, etc.) are created using
* this class; the exposed `serve` function will - most commonly - create an
* instance of `InngestCommHandler` and then return `instance.createHandler()`.
*
* See individual parameter details for more information, or see the
* source code for an existing handler, e.g.
* {@link https://github.com/inngest/inngest-js/blob/main/src/next.ts}
*
* @example
* ```
* // my-custom-handler.ts
* import {
*   InngestCommHandler,
*   type ServeHandlerOptions,
* } from "./components/InngestCommHandler";
*
* export const serve = (options: ServeHandlerOptions) => {
*   const handler = new InngestCommHandler({
*     frameworkName: "my-custom-handler",
*     ...options,
*     handler: (req: Request) => {
*       return {
*         body: () => req.json(),
*         headers: (key) => req.headers.get(key),
*         method: () => req.method,
*         url: () => new URL(req.url, `https://${req.headers.get("host") || ""}`),
*         transformResponse: ({ body, status, headers }) => {
*           return new Response(body, { status, headers });
*         },
*       };
*     },
*   });
*
*   return handler.createHandler();
* };
* ```
*
* @public
*/ var InngestCommHandler = class {
    /**
	* The ID of this serve handler, e.g. `"my-app"`. It's recommended that this
	* value represents the overarching app/service that this set of functions is
	* being served from.
	*/ id;
    /**
	* The handler specified during instantiation of the class.
	*/ handler;
    /**
	* The URL of the Inngest function registration endpoint.
	*/ inngestRegisterUrl;
    /**
	* The name of the framework this handler is designed for. Should be
	* lowercase, alphanumeric characters inclusive of `-` and `/`.
	*/ frameworkName;
    /**
	* The signing key used to validate requests from Inngest. This is
	* intentionally mutable so that we can pick up the signing key from the
	* environment during execution if needed.
	*/ signingKey;
    /**
	* The same as signingKey, except used as a fallback when auth fails using the
	* primary signing key.
	*/ signingKeyFallback;
    /**
	* A property that can be set to indicate whether we believe we are in
	* production mode.
	*
	* Should be set every time a request is received.
	*/ _mode;
    /**
	* The localized `fetch` implementation used by this handler.
	*/ fetch;
    /**
	* The host used to access the Inngest serve endpoint, e.g.:
	*
	*     "https://myapp.com"
	*
	* By default, the library will try to infer this using request details such
	* as the "Host" header and request path, but sometimes this isn't possible
	* (e.g. when running in a more controlled environments such as AWS Lambda or
	* when dealing with proxies/redirects).
	*
	* Provide the custom hostname here to ensure that the path is reported
	* correctly when registering functions with Inngest.
	*
	* To also provide a custom path, use `servePath`.
	*/ _serveHost;
    /**
	* The path to the Inngest serve endpoint. e.g.:
	*
	*     "/some/long/path/to/inngest/endpoint"
	*
	* By default, the library will try to infer this using request details such
	* as the "Host" header and request path, but sometimes this isn't possible
	* (e.g. when running in a more controlled environments such as AWS Lambda or
	* when dealing with proxies/redirects).
	*
	* Provide the custom path (excluding the hostname) here to ensure that the
	* path is reported correctly when registering functions with Inngest.
	*
	* To also provide a custom hostname, use `serveHost`.
	*/ _servePath;
    /**
	* The minimum level to log from the Inngest serve handler.
	*/ logLevel;
    streaming;
    /**
	* A private collection of just Inngest functions, as they have been passed
	* when instantiating the class.
	*/ rawFns;
    client;
    /**
	* A private collection of functions that are being served. This map is used
	* to find and register functions when interacting with Inngest Cloud.
	*/ fns = {};
    env = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$env$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["allProcessEnv"])();
    allowExpiredSignatures;
    _options;
    skipSignatureValidation;
    constructor(options){
        this._options = options;
        /**
		* v2 -> v3 migration error.
		*
		* If a serve handler is passed a client as the first argument, it'll be
		* spread in to these options. We should be able to detect this by picking
		* up a unique property on the object.
		*/ if (Object.hasOwn(options, "eventKey")) throw new Error(`${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["logPrefix"]} You've passed an Inngest client as the first argument to your serve handler. This is no longer supported in v3; please pass the Inngest client as the \`client\` property of an options object instead. See https://www.inngest.com/docs/sdk/migration`);
        this.frameworkName = options.frameworkName;
        this.client = options.client;
        if (options.id) console.warn(`${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["logPrefix"]} The \`id\` serve option is deprecated and will be removed in v4`);
        this.id = options.id || this.client.id;
        this.handler = options.handler;
        /**
		* Provide a hidden option to allow expired signatures to be accepted during
		* testing.
		*/ this.allowExpiredSignatures = Boolean(arguments["0"]?.__testingAllowExpiredSignatures);
        this.rawFns = options.functions?.filter(Boolean) ?? [];
        if (this.rawFns.length !== (options.functions ?? []).length) console.warn(`Some functions passed to serve() are undefined and misconfigured.  Please check your imports.`);
        this.fns = this.rawFns.reduce((acc, fn)=>{
            const configs = fn["getConfig"]({
                baseUrl: new URL("https://example.com"),
                appPrefix: this.id
            });
            const fns = configs.reduce((acc$1, { id }, index)=>{
                return {
                    ...acc$1,
                    [id]: {
                        fn,
                        onFailure: Boolean(index)
                    }
                };
            }, {});
            configs.forEach(({ id })=>{
                if (acc[id]) throw new Error(`Duplicate function ID "${id}"; please change a function's name or provide an explicit ID to avoid conflicts.`);
            });
            return {
                ...acc,
                ...fns
            };
        }, {});
        this.inngestRegisterUrl = new URL("/fn/register", this.apiBaseUrl);
        this.signingKey = options.signingKey;
        this.signingKeyFallback = options.signingKeyFallback;
        this._serveHost = options.serveHost || this.env[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["envKeys"].InngestServeHost];
        this._servePath = options.servePath || this.env[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["envKeys"].InngestServePath];
        this.skipSignatureValidation = options.skipSignatureValidation || false;
        const defaultLogLevel = "info";
        this.logLevel = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].enum(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["logLevels"]).default(defaultLogLevel).catch((ctx)=>{
            this.log("warn", `Unknown log level passed: ${String(ctx.input)}; defaulting to ${defaultLogLevel}`);
            return defaultLogLevel;
        }).parse(options.logLevel || this.env[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["envKeys"].InngestLogLevel]);
        if (this.logLevel === "debug") {
            /**
			* `debug` is an old library; sometimes its runtime detection doesn't work
			* for newer pairings of framework/runtime.
			*
			* One silly symptom of this is that `Debug()` returns an anonymous
			* function with no extra properties instead of a `Debugger` instance if
			* the wrong code is consumed following a bad detection. This results in
			* the following `.enable()` call failing, so we just try carefully to
			* enable it here.
			*/ if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$debug$40$4$2e$4$2e$3$2f$node_modules$2f$debug$2f$src$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].enable && typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$debug$40$4$2e$4$2e$3$2f$node_modules$2f$debug$2f$src$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].enable === "function") __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$debug$40$4$2e$4$2e$3$2f$node_modules$2f$debug$2f$src$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].enable(`${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["debugPrefix"]}:*`);
        }
        const defaultStreamingOption = false;
        this.streaming = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].union([
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].enum([
                "allow",
                "force"
            ]),
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal(false)
        ]).default(defaultStreamingOption).catch((ctx)=>{
            this.log("warn", `Unknown streaming option passed: ${String(ctx.input)}; defaulting to ${String(defaultStreamingOption)}`);
            return defaultStreamingOption;
        }).parse(options.streaming || this.env[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["envKeys"].InngestStreaming]);
        this.fetch = options.fetch ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$env$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getFetch"])(options.fetch) : this.client["fetch"];
    }
    /**
	* Get the API base URL for the Inngest API.
	*
	* This is a getter to encourage checking the environment for the API base URL
	* each time it's accessed, as it may change during execution.
	*/ get apiBaseUrl() {
        return this._options.baseUrl || this.env[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["envKeys"].InngestApiBaseUrl] || this.env[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["envKeys"].InngestBaseUrl] || this.client.apiBaseUrl || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["defaultInngestApiBaseUrl"];
    }
    /**
	* Get the event API base URL for the Inngest API.
	*
	* This is a getter to encourage checking the environment for the event API
	* base URL each time it's accessed, as it may change during execution.
	*/ get eventApiBaseUrl() {
        return this._options.baseUrl || this.env[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["envKeys"].InngestEventApiBaseUrl] || this.env[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["envKeys"].InngestBaseUrl] || this.client.eventBaseUrl || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["defaultInngestEventBaseUrl"];
    }
    /**
	* The host used to access the Inngest serve endpoint, e.g.:
	*
	*     "https://myapp.com"
	*
	* By default, the library will try to infer this using request details such
	* as the "Host" header and request path, but sometimes this isn't possible
	* (e.g. when running in a more controlled environments such as AWS Lambda or
	* when dealing with proxies/redirects).
	*
	* Provide the custom hostname here to ensure that the path is reported
	* correctly when registering functions with Inngest.
	*
	* To also provide a custom path, use `servePath`.
	*/ get serveHost() {
        return this._serveHost || this.env[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["envKeys"].InngestServeHost];
    }
    /**
	* The path to the Inngest serve endpoint. e.g.:
	*
	*     "/some/long/path/to/inngest/endpoint"
	*
	* By default, the library will try to infer this using request details such
	* as the "Host" header and request path, but sometimes this isn't possible
	* (e.g. when running in a more controlled environments such as AWS Lambda or
	* when dealing with proxies/redirects).
	*
	* Provide the custom path (excluding the hostname) here to ensure that the
	* path is reported correctly when registering functions with Inngest.
	*
	* To also provide a custom hostname, use `serveHost`.
	*
	* This is a getter to encourage checking the environment for the serve path
	* each time it's accessed, as it may change during execution.
	*/ get servePath() {
        return this._servePath || this.env[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["envKeys"].InngestServePath];
    }
    get hashedEventKey() {
        if (!this.client["eventKey"] || this.client["eventKey"] === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["dummyEventKey"]) return;
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$strings$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["hashEventKey"])(this.client["eventKey"]);
    }
    get hashedSigningKey() {
        if (!this.signingKey) return;
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$strings$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["hashSigningKey"])(this.signingKey);
    }
    get hashedSigningKeyFallback() {
        if (!this.signingKeyFallback) return;
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$strings$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["hashSigningKey"])(this.signingKeyFallback);
    }
    /**
	* Returns a `boolean` representing whether this handler will stream responses
	* or not. Takes into account the user's preference and the platform's
	* capabilities.
	*/ async shouldStream(actions) {
        if (await actions.queryStringWithDefaults("testing for probe", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["queryKeys"].Probe) !== void 0) return false;
        if (!actions.transformStreamingResponse) return false;
        if (this.streaming === "force") return true;
        return this.streaming === "allow" && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$env$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["platformSupportsStreaming"])(this.frameworkName, this.env);
    }
    async isInngestReq(actions) {
        const reqMessage = `checking if this is an Inngest request`;
        const [runId, signature] = await Promise.all([
            actions.headers(reqMessage, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["headerKeys"].InngestRunId),
            actions.headers(reqMessage, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["headerKeys"].Signature)
        ]);
        return Boolean(runId && typeof signature === "string");
    }
    /**
	* Start handling a request, setting up environments, modes, and returning
	* some helpers.
	*/ async initRequest(...args) {
        const timer = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$ServerTiming$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ServerTiming"]();
        const actions = await this.getActions(timer, ...args);
        const [env, expectedServerKind] = await Promise.all([
            actions.env?.("starting to handle request"),
            actions.headers("checking expected server kind", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["headerKeys"].InngestServerKind)
        ]);
        this.env = {
            ...(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$env$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["allProcessEnv"])(),
            ...env
        };
        const headerPromises = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["forwardedHeaders"].map(async (header)=>{
            return {
                header,
                value: await actions.headers(`fetching ${header} for forwarding`, header)
            };
        });
        const headersToForwardP = Promise.all(headerPromises).then((fetchedHeaders)=>{
            return fetchedHeaders.reduce((acc, { header, value })=>{
                if (value) acc[header] = value;
                return acc;
            }, {});
        });
        const getHeaders = async ()=>({
                ...(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$env$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["inngestHeaders"])({
                    env: this.env,
                    framework: this.frameworkName,
                    client: this.client,
                    expectedServerKind: expectedServerKind || void 0,
                    extras: {
                        "Server-Timing": timer.getHeader()
                    }
                }),
                ...await headersToForwardP
            });
        const assumedMode = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$env$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getMode"])({
            env: this.env,
            client: this.client
        });
        if (assumedMode.isExplicit) this._mode = assumedMode;
        else {
            const serveIsProd = await actions.isProduction?.("starting to handle request");
            if (typeof serveIsProd === "boolean") this._mode = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$env$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Mode"]({
                type: serveIsProd ? "cloud" : "dev",
                isExplicit: false
            });
            else this._mode = assumedMode;
        }
        this.upsertKeysFromEnv();
        return {
            timer,
            actions,
            getHeaders
        };
    }
    /**
	* `createSyncHandler` should be used to return a type-equivalent version of
	* the `handler` specified during instantiation.
	*/ createSyncHandler() {
        return (handler)=>{
            return this.wrapHandler(async (...args)=>{
                const reqInit = await this.initRequest(...args);
                const fn = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$components$2f$InngestFunction$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["InngestFunction"](this.client, {
                    id: this._options.syncOptions?.functionId ?? "",
                    retries: this._options.syncOptions?.retries ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["defaultMaxRetries"]
                }, ()=>handler(...args));
                if (await this.isInngestReq(reqInit.actions)) return this.handleAsyncRequest({
                    ...reqInit,
                    forceExecution: true,
                    args,
                    fns: [
                        fn
                    ]
                });
                return this.handleSyncRequest({
                    ...reqInit,
                    args,
                    asyncMode: this._options.syncOptions?.asyncResponse ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["AsyncResponseType"].Redirect,
                    fn
                });
            });
        };
    }
    /**
	* `createHandler` should be used to return a type-equivalent version of the
	* `handler` specified during instantiation.
	*
	* @example
	* ```
	* // my-custom-handler.ts
	* import {
	*   InngestCommHandler,
	*   type ServeHandlerOptions,
	* } from "./components/InngestCommHandler";
	*
	* export const serve = (options: ServeHandlerOptions) => {
	*   const handler = new InngestCommHandler({
	*     frameworkName: "my-custom-handler",
	*     ...options,
	*     handler: (req: Request) => {
	*       return {
	*         body: () => req.json(),
	*         headers: (key) => req.headers.get(key),
	*         method: () => req.method,
	*         url: () => new URL(req.url, `https://${req.headers.get("host") || ""}`),
	*         transformResponse: ({ body, status, headers }) => {
	*           return new Response(body, { status, headers });
	*         },
	*       };
	*     },
	*   });
	*
	*   return handler.createHandler();
	* };
	* ```
	*/ createHandler() {
        return this.wrapHandler(async (...args)=>{
            return this.handleAsyncRequest({
                ...await this.initRequest(...args),
                args
            });
        });
    }
    /**
	* Given a set of actions that let us access the incoming request, create a
	* `http/run.started` event that repesents a run starting from an HTTP
	* request.
	*/ async createHttpEvent(actions, fn) {
        const reason = "creating sync event";
        const contentTypePromise = actions.headers(reason, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["headerKeys"].ContentType).then((v)=>v ?? "");
        const ipPromise = actions.headers(reason, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["headerKeys"].ForwardedFor).then((v)=>{
            if (v) return v;
            return actions.headers(reason, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["headerKeys"].RealIp).then((v$1)=>v$1 ?? "");
        });
        const methodPromise = actions.method(reason);
        const urlPromise = actions.url(reason).then((v)=>this.reqUrl(v));
        const domainPromise = urlPromise.then((url)=>`${url.protocol}//${url.host}`);
        const pathPromise = urlPromise.then((url)=>url.pathname);
        const queryParamsPromise = urlPromise.then((url)=>url.searchParams.toString());
        const bodyPromise = actions.textBody(reason).then((body$1)=>{
            return typeof body$1 === "string" ? body$1 : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$strings$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["stringify"])(body$1);
        });
        const [contentType, domain, ip, method, path, queryParams, body] = await Promise.all([
            contentTypePromise,
            domainPromise,
            ipPromise,
            methodPromise,
            pathPromise,
            queryParamsPromise,
            bodyPromise
        ]);
        return {
            name: "http/run.started",
            data: {
                content_type: contentType,
                domain,
                ip,
                method,
                path,
                query_params: queryParams,
                body,
                fn: fn.id()
            }
        };
    }
    async handleSyncRequest({ timer, actions, fn, asyncMode, args }) {
        if (!actions.experimentalTransformSyncResponse) throw new Error("This platform does not support synchronous Inngest function executions.");
        if (await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$components$2f$execution$2f$als$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getAsyncCtx"])()) throw new Error("We already seem to be in the context of an Inngest execution, but didn't expect to be. Did you already wrap this handler?");
        const runId = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$ulid$40$2$2e$4$2e$0$2f$node_modules$2f$ulid$2f$dist$2f$index$2e$esm$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ulid"])();
        const event = await this.createHttpEvent(actions, fn);
        const exeVersion = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$components$2f$execution$2f$InngestExecution$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["PREFERRED_EXECUTION_VERSION"];
        const result = await fn["createExecution"]({
            version: exeVersion,
            partialOptions: {
                client: this.client,
                data: {
                    runId,
                    event,
                    attempt: 0,
                    events: [
                        event
                    ],
                    maxAttempts: fn.opts.retries ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["defaultMaxRetries"]
                },
                runId,
                headers: {},
                reqArgs: args,
                stepCompletionOrder: [],
                stepState: {},
                disableImmediateExecution: false,
                isFailureHandler: false,
                timer,
                createResponse: (data)=>actions.experimentalTransformSyncResponse("creating sync execution", data).then((res)=>({
                            ...res,
                            version: exeVersion
                        })),
                stepMode: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["StepMode"].Sync
            }
        }).start();
        const resultHandler = {
            "step-not-found": ()=>{
                throw new Error("We should not get the result 'step-not-found' when checkpointing. This is a bug in the `inngest` SDK");
            },
            "steps-found": ()=>{
                throw new Error("We should not get the result 'steps-found' when checkpointing. This is a bug in the `inngest` SDK");
            },
            "step-ran": ()=>{
                throw new Error("We should not get the result 'step-ran' when checkpointing. This is a bug in the `inngest` SDK");
            },
            "function-rejected": ()=>{
                throw new Error("We should not get the result 'function-rejected' when checkpointing. This is a bug in the `inngest` SDK");
            },
            "function-resolved": ({ data })=>{
                return data;
            },
            "change-mode": async ({ token })=>{
                switch(asyncMode){
                    case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["AsyncResponseType"].Redirect:
                        return actions.transformResponse("creating sync->async redirect response", {
                            status: 302,
                            headers: {
                                [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["headerKeys"].Location]: await this.client["inngestApi"]["getTargetUrl"](`/v1/http/runs/${runId}/output?token=${token}`).then((url)=>url.toString())
                            },
                            version: exeVersion,
                            body: ""
                        });
                    case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["AsyncResponseType"].Token:
                        return actions.transformResponse("creating sync->async token response", {
                            status: 200,
                            headers: {},
                            version: exeVersion,
                            body: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$strings$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["stringify"])({
                                run_id: runId,
                                token
                            })
                        });
                    default:
                        break;
                }
                throw new Error("Not implemented: change-mode");
            }
        }[result.type];
        if (!resultHandler) throw new Error(`No handler for execution result type: ${result.type}. This is a bug in the \`inngest\` SDK`);
        return resultHandler(result);
    }
    async handleAsyncRequest({ timer, actions, args, getHeaders, forceExecution, fns }) {
        if (forceExecution && !actions.experimentalTransformSyncResponse) throw new Error("This platform does not support async executions in Inngest for APIs.");
        const methodP = actions.method("starting to handle request");
        const contentLength = await actions.headers("checking signature for request", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["headerKeys"].ContentLength).then((value)=>{
            if (!value) return;
            return Number.parseInt(value, 10);
        });
        const [signature, method, body] = await Promise.all([
            actions.headers("checking signature for request", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["headerKeys"].Signature).then((headerSignature)=>{
                return headerSignature ?? void 0;
            }),
            methodP,
            methodP.then((method$1)=>{
                if (method$1 === "POST" || method$1 === "PUT") {
                    if (!contentLength) return "";
                    return actions.body(`checking body for request signing as method is ${method$1}`);
                }
                return "";
            })
        ]);
        const signatureValidation = this.validateSignature(signature, body);
        const actionRes = timer.wrap("action", ()=>this.handleAction({
                actions,
                timer,
                getHeaders,
                reqArgs: args,
                signatureValidation,
                body,
                method,
                forceExecution: Boolean(forceExecution),
                fns
            }));
        /**
		* Prepares an action response by merging returned data to provide
		* trailing information such as `Server-Timing` headers.
		*
		* It should always prioritize the headers returned by the action, as they
		* may contain important information such as `Content-Type`.
		*/ const prepareActionRes = async (res)=>{
            const headers = {
                ...await getHeaders(),
                ...res.headers,
                ...res.version === null ? {} : {
                    [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["headerKeys"].RequestVersion]: (res.version ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$components$2f$execution$2f$InngestExecution$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["PREFERRED_EXECUTION_VERSION"]).toString()
                }
            };
            let signature$1;
            try {
                signature$1 = await signatureValidation.then((result)=>{
                    if (!result.success || !result.keyUsed) return;
                    return this.getResponseSignature(result.keyUsed, res.body);
                });
            } catch (err) {
                return {
                    ...res,
                    headers,
                    body: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$strings$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["stringify"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$errors$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["serializeError"])(err)),
                    status: 500
                };
            }
            if (signature$1) headers[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["headerKeys"].Signature] = signature$1;
            return {
                ...res,
                headers
            };
        };
        if (await this.shouldStream(actions)) {
            if (await actions.method("starting streaming response") === "POST") {
                const { stream, finalize } = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$stream$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createStream"])();
                /**
				* Errors are handled by `handleAction` here to ensure that an
				* appropriate response is always given.
				*/ actionRes.then((res)=>{
                    return finalize(prepareActionRes(res));
                });
                return timer.wrap("res", async ()=>{
                    return actions.transformStreamingResponse?.("starting streaming response", {
                        status: 201,
                        headers: await getHeaders(),
                        body: stream,
                        version: null
                    });
                });
            }
        }
        return timer.wrap("res", async ()=>{
            return actionRes.then(prepareActionRes).then((actionRes$1)=>{
                return actions.transformResponse("sending back response", actionRes$1);
            });
        });
    }
    async getActions(timer, ...args) {
        /**
		* Used for testing, allow setting action overrides externally when
		* calling the handler. Always search the final argument.
		*/ const lastArg = args[args.length - 1];
        const actionOverrides = typeof lastArg === "object" && lastArg !== null && "actionOverrides" in lastArg && typeof lastArg["actionOverrides"] === "object" && lastArg["actionOverrides"] !== null ? lastArg["actionOverrides"] : {};
        /**
		* We purposefully `await` the handler, as it could be either sync or
		* async.
		*/ const rawActions = {
            ...await timer.wrap("handler", ()=>this.handler(...args)).catch((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$errors$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["rethrowError"])("Serve handler failed to run")),
            ...actionOverrides
        };
        /**
		* Mapped promisified handlers from userland `serve()` function mixed in
		* with some helpers.
		*/ const actions = {
            ...Object.entries(rawActions).reduce((acc, [key, value])=>{
                if (typeof value !== "function") return acc;
                return {
                    ...acc,
                    [key]: (reason, ...args$1)=>{
                        const errMessage = [
                            `Failed calling \`${key}\` from serve handler`,
                            reason
                        ].filter(Boolean).join(" when ");
                        const fn = ()=>value(...args$1);
                        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$promises$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["runAsPromise"])(fn).catch((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$errors$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["rethrowError"])(errMessage)).catch((err)=>{
                            this.log("error", err);
                            throw err;
                        });
                    }
                };
            }, {}),
            queryStringWithDefaults: async (reason, key)=>{
                const url = await actions.url(reason);
                return await actions.queryString?.(reason, key, url) || url.searchParams.get(key) || void 0;
            },
            ...actionOverrides
        };
        return actions;
    }
    wrapHandler(handler) {
        /**
		* Some platforms check (at runtime) the length of the function being used
		* to handle an endpoint. If this is a variadic function, it will fail that
		* check.
		*
		* Therefore, we expect the arguments accepted to be the same length as the
		* `handler` function passed internally.
		*
		* We also set a name to avoid a common useless name in tracing such as
		* `"anonymous"` or `"bound function"`.
		*
		* https://github.com/getsentry/sentry-javascript/issues/3284
		*/ Object.defineProperties(handler, {
            name: {
                value: "InngestHandler"
            },
            length: {
                value: this.handler.length
            }
        });
        return handler;
    }
    get mode() {
        return this._mode;
    }
    set mode(m) {
        this._mode = m;
        if (m) this.client["mode"] = m;
    }
    /**
	* Given a set of functions to check if an action is available from the
	* instance's handler, enact any action that is found.
	*
	* This method can fetch varying payloads of data, but ultimately is the place
	* where _decisions_ are made regarding functionality.
	*
	* For example, if we find that we should be viewing the UI, this function
	* will decide whether the UI should be visible based on the payload it has
	* found (e.g. env vars, options, etc).
	*/ async handleAction({ actions, timer, getHeaders, reqArgs, signatureValidation, body: rawBody, method, forceExecution, fns }) {
        const isMissingBody = rawBody === void 0;
        let body = rawBody;
        try {
            let url = await actions.url("starting to handle request");
            if (method === "POST" || forceExecution) {
                if (!forceExecution && isMissingBody) {
                    this.log("error", "Missing body when executing, possibly due to missing request body middleware");
                    return {
                        status: 500,
                        headers: {
                            "Content-Type": "application/json"
                        },
                        body: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$strings$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["stringify"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$errors$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["serializeError"])(/* @__PURE__ */ new Error("Missing request body when executing, possibly due to missing request body middleware"))),
                        version: void 0
                    };
                }
                const validationResult = await signatureValidation;
                if (!validationResult.success) return {
                    status: 401,
                    headers: {
                        "Content-Type": "application/json"
                    },
                    body: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$strings$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["stringify"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$errors$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["serializeError"])(validationResult.err)),
                    version: void 0
                };
                let fn;
                let fnId;
                let stepId;
                if (forceExecution) {
                    fn = fns?.length && fns[0] ? {
                        fn: fns[0],
                        onFailure: false
                    } : Object.values(this.fns)[0];
                    fnId = fn?.fn.id();
                    stepId = "step";
                    body = {
                        event: {},
                        events: [],
                        steps: {},
                        version: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$components$2f$execution$2f$InngestExecution$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["PREFERRED_EXECUTION_VERSION"],
                        ctx: {
                            attempt: 0,
                            disable_immediate_execution: false,
                            use_api: true,
                            max_attempts: 3,
                            run_id: await actions.headers("getting run ID for forced execution", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["headerKeys"].InngestRunId),
                            stack: {
                                stack: [],
                                current: 0
                            }
                        }
                    };
                } else {
                    const rawProbe = await actions.queryStringWithDefaults("testing for probe", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["queryKeys"].Probe);
                    if (rawProbe) {
                        const probe$1 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$enum$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["enumFromValue"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["probe"], rawProbe);
                        if (!probe$1) return {
                            status: 400,
                            headers: {
                                "Content-Type": "application/json"
                            },
                            body: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$strings$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["stringify"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$errors$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["serializeError"])(/* @__PURE__ */ new Error(`Unknown probe "${rawProbe}"`))),
                            version: void 0
                        };
                        return ({
                            [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["probe"].Trust]: ()=>({
                                    status: 200,
                                    headers: {
                                        "Content-Type": "application/json"
                                    },
                                    body: "",
                                    version: void 0
                                })
                        })[probe$1]();
                    }
                    fnId = await actions.queryStringWithDefaults("processing run request", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["queryKeys"].FnId);
                    if (!fnId) throw new Error("No function ID found in async request");
                    fn = this.fns[fnId];
                    stepId = await actions.queryStringWithDefaults("processing run request", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["queryKeys"].StepId) || null;
                }
                if (typeof fnId === "undefined" || !fn) throw new Error("No function ID found in request");
                const { version: version$1, result } = this.runStep({
                    functionId: fnId,
                    data: body,
                    stepId,
                    timer,
                    reqArgs,
                    headers: await getHeaders(),
                    fn,
                    forceExecution,
                    actions
                });
                const stepOutput = await result;
                /**
				* Functions can return `undefined`, but we'll always convert this to
				* `null`, as this is appropriately serializable by JSON.
				*/ const opDataUndefinedToNull = (op)=>{
                    op.data = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$functions$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["undefinedToNull"])(op.data);
                    return op;
                };
                const handler = {
                    "function-rejected": (result$1)=>{
                        return {
                            status: result$1.retriable ? 500 : 400,
                            headers: {
                                "Content-Type": "application/json",
                                [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["headerKeys"].NoRetry]: result$1.retriable ? "false" : "true",
                                ...typeof result$1.retriable === "string" ? {
                                    [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["headerKeys"].RetryAfter]: result$1.retriable
                                } : {}
                            },
                            body: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$strings$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["stringify"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$functions$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["undefinedToNull"])(result$1.error)),
                            version: version$1
                        };
                    },
                    "function-resolved": (result$1)=>{
                        if (forceExecution) {
                            const runCompleteOp = {
                                id: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$components$2f$execution$2f$v1$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["_internals"].hashId("complete"),
                                op: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["StepOpCode"].RunComplete,
                                data: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$functions$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["undefinedToNull"])(result$1.data)
                            };
                            return {
                                status: 206,
                                headers: {
                                    "Content-Type": "application/json"
                                },
                                body: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$strings$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["stringify"])(runCompleteOp),
                                version: version$1
                            };
                        }
                        return {
                            status: 200,
                            headers: {
                                "Content-Type": "application/json"
                            },
                            body: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$strings$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["stringify"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$functions$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["undefinedToNull"])(result$1.data)),
                            version: version$1
                        };
                    },
                    "step-not-found": (result$1)=>{
                        return {
                            status: 500,
                            headers: {
                                "Content-Type": "application/json",
                                [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["headerKeys"].NoRetry]: "false"
                            },
                            body: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$strings$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["stringify"])({
                                error: `Could not find step "${result$1.step.displayName || result$1.step.id}" to run; timed out`
                            }),
                            version: version$1
                        };
                    },
                    "step-ran": (result$1)=>{
                        const step = opDataUndefinedToNull(result$1.step);
                        return {
                            status: 206,
                            headers: {
                                "Content-Type": "application/json",
                                ...typeof result$1.retriable !== "undefined" ? {
                                    [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["headerKeys"].NoRetry]: result$1.retriable ? "false" : "true",
                                    ...typeof result$1.retriable === "string" ? {
                                        [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["headerKeys"].RetryAfter]: result$1.retriable
                                    } : {}
                                } : {}
                            },
                            body: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$strings$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["stringify"])([
                                step
                            ]),
                            version: version$1
                        };
                    },
                    "steps-found": (result$1)=>{
                        const steps = result$1.steps.map(opDataUndefinedToNull);
                        return {
                            status: 206,
                            headers: {
                                "Content-Type": "application/json"
                            },
                            body: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$strings$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["stringify"])(steps),
                            version: version$1
                        };
                    },
                    "change-mode": (result$1)=>{
                        return {
                            status: 500,
                            headers: {
                                "Content-Type": "application/json",
                                [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["headerKeys"].NoRetry]: "true"
                            },
                            body: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$strings$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["stringify"])({
                                error: `We wanted to change mode to "${result$1.to}", but this is not supported within the InngestCommHandler. This is a bug in the Inngest SDK.`
                            }),
                            version: version$1
                        };
                    }
                }[stepOutput.type];
                try {
                    return await handler(stepOutput);
                } catch (err) {
                    this.log("error", "Error handling execution result", err);
                    throw err;
                }
            }
            const env = (await getHeaders())[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["headerKeys"].Environment] ?? null;
            if (method === "GET") return {
                status: 200,
                body: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$strings$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["stringify"])(await this.introspectionBody({
                    actions,
                    env,
                    signatureValidation,
                    url
                })),
                headers: {
                    "Content-Type": "application/json"
                },
                version: void 0
            };
            if (method === "PUT") {
                const [deployId, inBandSyncRequested] = await Promise.all([
                    actions.queryStringWithDefaults("processing deployment request", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["queryKeys"].DeployId).then((deployId$1)=>{
                        return deployId$1 === "undefined" ? void 0 : deployId$1;
                    }),
                    Promise.resolve((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$env$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["parseAsBoolean"])(this.env[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["envKeys"].InngestAllowInBandSync])).then((allowInBandSync)=>{
                        if (allowInBandSync !== void 0 && !allowInBandSync) return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["syncKind"].OutOfBand;
                        return actions.headers("processing deployment request", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["headerKeys"].InngestSyncKind);
                    }).then((kind)=>{
                        return kind === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["syncKind"].InBand;
                    })
                ]);
                if (inBandSyncRequested) {
                    if (isMissingBody) {
                        this.log("error", "Missing body when syncing, possibly due to missing request body middleware");
                        return {
                            status: 500,
                            headers: {
                                "Content-Type": "application/json"
                            },
                            body: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$strings$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["stringify"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$errors$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["serializeError"])(/* @__PURE__ */ new Error("Missing request body when syncing, possibly due to missing request body middleware"))),
                            version: void 0
                        };
                    }
                    if (!(await signatureValidation).success) return {
                        status: 401,
                        body: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$strings$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["stringify"])({
                            code: "sig_verification_failed"
                        }),
                        headers: {
                            "Content-Type": "application/json"
                        },
                        version: void 0
                    };
                    const res = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["inBandSyncRequestBodySchema"].safeParse(body);
                    if (!res.success) return {
                        status: 400,
                        body: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$strings$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["stringify"])({
                            code: "invalid_request",
                            message: res.error.message
                        }),
                        headers: {
                            "Content-Type": "application/json"
                        },
                        version: void 0
                    };
                    url = this.reqUrl(new URL(res.data.url));
                    return {
                        status: 200,
                        body: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$strings$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["stringify"])(await this.inBandRegisterBody({
                            actions,
                            deployId,
                            env,
                            signatureValidation,
                            url
                        })),
                        headers: {
                            "Content-Type": "application/json",
                            [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["headerKeys"].InngestSyncKind]: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["syncKind"].InBand
                        },
                        version: void 0
                    };
                }
                const { status, message, modified } = await this.register(this.reqUrl(url), deployId, getHeaders);
                return {
                    status,
                    body: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$strings$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["stringify"])({
                        message,
                        modified
                    }),
                    headers: {
                        "Content-Type": "application/json",
                        [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["headerKeys"].InngestSyncKind]: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["syncKind"].OutOfBand
                    },
                    version: void 0
                };
            }
        } catch (err) {
            return {
                status: 500,
                body: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$strings$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["stringify"])({
                    type: "internal",
                    ...(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$errors$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["serializeError"])(err)
                }),
                headers: {
                    "Content-Type": "application/json"
                },
                version: void 0
            };
        }
        return {
            status: 405,
            body: JSON.stringify({
                message: "No action found; request was likely not POST, PUT, or GET",
                mode: this._mode
            }),
            headers: {},
            version: void 0
        };
    }
    runStep({ actions, functionId, stepId, data, timer, reqArgs, headers, fn, forceExecution }) {
        if (!fn) throw new Error(`Could not find function with ID "${functionId}"`);
        const immediateFnData = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$functions$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["parseFnData"])(data);
        let { version: version$1 } = immediateFnData;
        if (version$1 === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ExecutionVersion"].V1 && fn.fn["shouldOptimizeParallelism"]?.()) version$1 = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ExecutionVersion"].V2;
        const result = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$promises$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["runAsPromise"])(async ()=>{
            const anyFnData = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$functions$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["fetchAllFnData"])({
                data: immediateFnData,
                api: this.client["inngestApi"],
                version: version$1
            });
            if (!anyFnData.ok) throw new Error(anyFnData.error);
            const createResponse = forceExecution && actions.experimentalTransformSyncResponse ? (data$1)=>actions.experimentalTransformSyncResponse("created sync->async response", data$1).then((res)=>({
                        ...res,
                        version: version$1
                    })) : void 0;
            const executionOptions = await ((s)=>s)({
                [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ExecutionVersion"].V0]: ({ event, events, steps, ctx, version: version$2 })=>{
                    const stepState = Object.entries(steps ?? {}).reduce((acc, [id, data$1])=>{
                        return {
                            ...acc,
                            [id]: {
                                id,
                                data: data$1
                            }
                        };
                    }, {});
                    return {
                        version: version$2,
                        partialOptions: {
                            client: this.client,
                            runId: ctx?.run_id || "",
                            stepMode: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["StepMode"].Async,
                            data: {
                                event,
                                events,
                                runId: ctx?.run_id || "",
                                attempt: ctx?.attempt ?? 0
                            },
                            stepState,
                            requestedRunStep: stepId === "step" ? void 0 : stepId || void 0,
                            timer,
                            isFailureHandler: fn.onFailure,
                            stepCompletionOrder: ctx?.stack?.stack ?? [],
                            reqArgs,
                            headers,
                            createResponse
                        }
                    };
                },
                [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ExecutionVersion"].V1]: ({ event, events, steps, ctx, version: version$2 })=>{
                    const stepState = Object.entries(steps ?? {}).reduce((acc, [id, result$1])=>{
                        return {
                            ...acc,
                            [id]: result$1.type === "data" ? {
                                id,
                                data: result$1.data
                            } : result$1.type === "input" ? {
                                id,
                                input: result$1.input
                            } : {
                                id,
                                error: result$1.error
                            }
                        };
                    }, {});
                    return {
                        version: version$2,
                        partialOptions: {
                            client: this.client,
                            runId: ctx?.run_id || "",
                            stepMode: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["StepMode"].Async,
                            data: {
                                event,
                                events,
                                runId: ctx?.run_id || "",
                                attempt: ctx?.attempt ?? 0,
                                maxAttempts: ctx?.max_attempts
                            },
                            stepState,
                            requestedRunStep: stepId === "step" ? void 0 : stepId || void 0,
                            timer,
                            isFailureHandler: fn.onFailure,
                            disableImmediateExecution: ctx?.disable_immediate_execution,
                            stepCompletionOrder: ctx?.stack?.stack ?? [],
                            reqArgs,
                            headers,
                            createResponse
                        }
                    };
                },
                [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ExecutionVersion"].V2]: ({ event, events, steps, ctx, version: version$2 })=>{
                    const stepState = Object.entries(steps ?? {}).reduce((acc, [id, result$1])=>{
                        return {
                            ...acc,
                            [id]: result$1.type === "data" ? {
                                id,
                                data: result$1.data
                            } : result$1.type === "input" ? {
                                id,
                                input: result$1.input
                            } : {
                                id,
                                error: result$1.error
                            }
                        };
                    }, {});
                    return {
                        version: version$2,
                        partialOptions: {
                            client: this.client,
                            runId: ctx?.run_id || "",
                            stepMode: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["StepMode"].Async,
                            data: {
                                event,
                                events,
                                runId: ctx?.run_id || "",
                                attempt: ctx?.attempt ?? 0,
                                maxAttempts: ctx?.max_attempts
                            },
                            stepState,
                            requestedRunStep: stepId === "step" ? void 0 : stepId || void 0,
                            timer,
                            isFailureHandler: fn.onFailure,
                            disableImmediateExecution: ctx?.disable_immediate_execution,
                            stepCompletionOrder: ctx?.stack?.stack ?? [],
                            reqArgs,
                            headers,
                            createResponse
                        }
                    };
                }
            })[version$1](anyFnData.value);
            return fn.fn["createExecution"](executionOptions).start();
        });
        return {
            version: version$1,
            result
        };
    }
    configs(url) {
        const configs = Object.values(this.rawFns).reduce((acc, fn)=>[
                ...acc,
                ...fn["getConfig"]({
                    baseUrl: url,
                    appPrefix: this.id
                })
            ], []);
        for (const config of configs){
            const check = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["functionConfigSchema"].safeParse(config);
            if (!check.success) {
                const errors = check.error.errors.map((err)=>err.message).join("; ");
                this.log("warn", `Config invalid for function "${config.id}" : ${errors}`);
            }
        }
        return configs;
    }
    /**
	* Return an Inngest serve endpoint URL given a potential `path` and `host`.
	*
	* Will automatically use the `serveHost` and `servePath` if they have been
	* set when registering.
	*/ reqUrl(url) {
        let ret = new URL(url);
        const serveHost = this.serveHost || this.env[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["envKeys"].InngestServeHost];
        const servePath = this.servePath || this.env[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["envKeys"].InngestServePath];
        if (servePath) ret.pathname = servePath;
        if (serveHost) ret = new URL(ret.pathname + ret.search, serveHost);
        return ret;
    }
    registerBody({ url, deployId }) {
        return {
            url: url.href,
            deployType: "ping",
            framework: this.frameworkName,
            appName: this.id,
            functions: this.configs(url),
            sdk: `js:v${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$version$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["version"]}`,
            v: "0.1",
            deployId: deployId || void 0,
            capabilities: {
                trust_probe: "v1",
                connect: "v1"
            },
            appVersion: this.client.appVersion
        };
    }
    async inBandRegisterBody({ actions, deployId, env, signatureValidation, url }) {
        const registerBody = this.registerBody({
            deployId,
            url
        });
        const introspectionBody = await this.introspectionBody({
            actions,
            env,
            signatureValidation,
            url
        });
        const body = {
            app_id: this.id,
            appVersion: this.client.appVersion,
            capabilities: registerBody.capabilities,
            env,
            framework: registerBody.framework,
            functions: registerBody.functions,
            inspection: introspectionBody,
            platform: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$env$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getPlatformName"])({
                ...(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$env$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["allProcessEnv"])(),
                ...this.env
            }),
            sdk_author: "inngest",
            sdk_language: "",
            sdk_version: "",
            sdk: registerBody.sdk,
            url: registerBody.url
        };
        if (introspectionBody.authentication_succeeded) {
            body.sdk_language = introspectionBody.sdk_language;
            body.sdk_version = introspectionBody.sdk_version;
        }
        return body;
    }
    async introspectionBody({ actions, env, signatureValidation, url }) {
        const registerBody = this.registerBody({
            url: this.reqUrl(url),
            deployId: null
        });
        if (!this._mode) throw new Error("No mode set; cannot introspect without mode");
        let introspection = {
            authentication_succeeded: null,
            extra: {
                is_mode_explicit: this._mode.isExplicit
            },
            has_event_key: this.client["eventKeySet"](),
            has_signing_key: Boolean(this.signingKey),
            function_count: registerBody.functions.length,
            mode: this._mode.type,
            schema_version: "2024-05-24"
        };
        if (this._mode.type === "cloud") try {
            if (!(await signatureValidation).success) throw new Error("Signature validation failed");
            introspection = {
                ...introspection,
                authentication_succeeded: true,
                api_origin: this.apiBaseUrl,
                app_id: this.id,
                capabilities: {
                    trust_probe: "v1",
                    connect: "v1"
                },
                env,
                event_api_origin: this.eventApiBaseUrl,
                event_key_hash: this.hashedEventKey ?? null,
                extra: {
                    ...introspection.extra,
                    is_streaming: await this.shouldStream(actions)
                },
                framework: this.frameworkName,
                sdk_language: "js",
                sdk_version: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$version$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["version"],
                serve_origin: this.serveHost ?? null,
                serve_path: this.servePath ?? null,
                signing_key_fallback_hash: this.hashedSigningKeyFallback ?? null,
                signing_key_hash: this.hashedSigningKey ?? null
            };
        } catch  {
            introspection = {
                ...introspection,
                authentication_succeeded: false
            };
        }
        return introspection;
    }
    async register(url, deployId, getHeaders) {
        const body = this.registerBody({
            url,
            deployId
        });
        let res;
        let registerURL = new URL(this.inngestRegisterUrl.href);
        if (this._mode && this._mode.isInferred && this._mode.isDev) {
            const host = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$env$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["devServerHost"])(this.env);
            if (await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$devserver$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["devServerAvailable"])(host, this.fetch)) registerURL = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$devserver$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["devServerUrl"])(host, "/fn/register");
        } else if (this._mode?.explicitDevUrl) registerURL = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$devserver$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["devServerUrl"])(this._mode.explicitDevUrl.href, "/fn/register");
        if (deployId) registerURL.searchParams.set(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["queryKeys"].DeployId, deployId);
        try {
            res = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$net$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["fetchWithAuthFallback"])({
                authToken: this.hashedSigningKey,
                authTokenFallback: this.hashedSigningKeyFallback,
                fetch: this.fetch,
                url: registerURL.href,
                options: {
                    method: "POST",
                    body: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$strings$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["stringify"])(body),
                    headers: {
                        ...await getHeaders(),
                        [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["headerKeys"].InngestSyncKind]: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["syncKind"].OutOfBand
                    },
                    redirect: "follow"
                }
            });
        } catch (err) {
            this.log("error", err);
            return {
                status: 500,
                message: `Failed to register${err instanceof Error ? `; ${err.message}` : ""}`,
                modified: false
            };
        }
        const raw = await res.text();
        let data = {};
        try {
            data = JSON.parse(raw);
        } catch (err) {
            this.log("warn", "Couldn't unpack register response:", err);
            let message = "Failed to register";
            if (err instanceof Error) message += `; ${err.message}`;
            message += `; status code: ${res.status}`;
            return {
                status: 500,
                message,
                modified: false
            };
        }
        let status;
        let error;
        let skipped;
        let modified;
        try {
            ({ status, error, skipped, modified } = registerResSchema.parse(data));
        } catch (err) {
            this.log("warn", "Invalid register response schema:", err);
            let message = "Failed to register";
            if (err instanceof Error) message += `; ${err.message}`;
            message += `; status code: ${res.status}`;
            return {
                status: 500,
                message,
                modified: false
            };
        }
        if (!skipped) this.log("debug", "registered inngest functions:", res.status, res.statusText, data);
        return {
            status,
            message: error,
            modified
        };
    }
    /**
	* Given an environment, upsert any missing keys. This is useful in
	* situations where environment variables are passed directly to handlers or
	* are otherwise difficult to access during initialization.
	*/ upsertKeysFromEnv() {
        if (this.env[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["envKeys"].InngestSigningKey]) {
            if (!this.signingKey) this.signingKey = String(this.env[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["envKeys"].InngestSigningKey]);
            this.client["inngestApi"].setSigningKey(this.signingKey);
        }
        if (this.env[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["envKeys"].InngestSigningKeyFallback]) {
            if (!this.signingKeyFallback) this.signingKeyFallback = String(this.env[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["envKeys"].InngestSigningKeyFallback]);
            this.client["inngestApi"].setSigningKeyFallback(this.signingKeyFallback);
        }
        if (!this.client["eventKeySet"]() && this.env[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["envKeys"].InngestEventKey]) this.client.setEventKey(String(this.env[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["envKeys"].InngestEventKey]));
        if (this.env[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["envKeys"].InngestDevServerUrl]) this.log("warn", `Use of ${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["envKeys"].InngestDevServerUrl} has been deprecated in v3; please use ${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["envKeys"].InngestBaseUrl} instead. See https://www.inngest.com/docs/sdk/migration`);
    }
    /**
	* Validate the signature of a request and return the signing key used to
	* validate it.
	*/ async validateSignature(sig, body) {
        try {
            if (this.skipSignatureValidation) return {
                success: true,
                keyUsed: ""
            };
            if (this._mode && !this._mode.isCloud) return {
                success: true,
                keyUsed: ""
            };
            if (!this.signingKey) throw new Error(`No signing key found in client options or ${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["envKeys"].InngestSigningKey} env var. Find your keys at https://app.inngest.com/secrets`);
            if (!sig) throw new Error(`No ${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["headerKeys"].Signature} provided`);
            return {
                success: true,
                keyUsed: new RequestSignature(sig).verifySignature({
                    body,
                    allowExpiredSignatures: this.allowExpiredSignatures,
                    signingKey: this.signingKey,
                    signingKeyFallback: this.signingKeyFallback
                })
            };
        } catch (err) {
            return {
                success: false,
                err
            };
        }
    }
    getResponseSignature(key, body) {
        const now = Date.now();
        return `t=${now}&s=${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$net$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["signDataWithKey"])(body, key, now.toString())}`;
    }
    /**
	* Log to stdout/stderr if the log level is set to include the given level.
	* The default log level is `"info"`.
	*
	* This is an abstraction over `console.log` and will try to use the correct
	* method for the given log level.  For example, `log("error", "foo")` will
	* call `console.error("foo")`.
	*/ log(level, ...args) {
        const logLevels$1 = [
            "debug",
            "info",
            "warn",
            "error",
            "fatal",
            "silent"
        ];
        const logLevelSetting = logLevels$1.indexOf(this.logLevel);
        if (logLevels$1.indexOf(level) >= logLevelSetting) {
            let logger = console.log;
            if (Object.hasOwn(console, level)) logger = console[level];
            logger(`${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["logPrefix"]} ${level} -`, ...args);
        }
    }
};
var RequestSignature = class {
    timestamp;
    signature;
    constructor(sig){
        const params = new URLSearchParams(sig);
        this.timestamp = params.get("t") || "";
        this.signature = params.get("s") || "";
        if (!this.timestamp || !this.signature) throw new Error(`Invalid ${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["headerKeys"].Signature} provided`);
    }
    hasExpired(allowExpiredSignatures) {
        if (allowExpiredSignatures) return false;
        return Date.now() - /* @__PURE__ */ new Date(Number.parseInt(this.timestamp) * 1e3).valueOf() > 1e3 * 60 * 5;
    }
    #verifySignature({ body, signingKey, allowExpiredSignatures }) {
        if (this.hasExpired(allowExpiredSignatures)) throw new Error("Signature has expired");
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$net$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["signDataWithKey"])(body, signingKey, this.timestamp) !== this.signature) throw new Error("Invalid signature");
    }
    verifySignature({ body, signingKey, signingKeyFallback, allowExpiredSignatures }) {
        try {
            this.#verifySignature({
                body,
                signingKey,
                allowExpiredSignatures
            });
            return signingKey;
        } catch (err) {
            if (!signingKeyFallback) throw err;
            this.#verifySignature({
                body,
                signingKey: signingKeyFallback,
                allowExpiredSignatures
            });
            return signingKeyFallback;
        }
    }
};
;
 //# sourceMappingURL=InngestCommHandler.js.map
}}),
"[project]/node_modules/.pnpm/inngest@3.45.1_@opentelemetry+core@2.2.0_@opentelemetry+api@1.9.0__express@4.21.2_next@_c75e0c332defb7a954d9a52cadcbb8f7/node_modules/inngest/next.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "frameworkName": (()=>frameworkName),
    "serve": (()=>serve)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$env$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/inngest@3.45.1_@opentelemetry+core@2.2.0_@opentelemetry+api@1.9.0__express@4.21.2_next@_c75e0c332defb7a954d9a52cadcbb8f7/node_modules/inngest/helpers/env.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$components$2f$InngestCommHandler$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/inngest@3.45.1_@opentelemetry+core@2.2.0_@opentelemetry+api@1.9.0__express@4.21.2_next@_c75e0c332defb7a954d9a52cadcbb8f7/node_modules/inngest/components/InngestCommHandler.js [app-route] (ecmascript)");
;
;
//#region src/next.ts
/**
* The name of the framework, used to identify the framework in Inngest
* dashboards and during testing.
*/ const frameworkName = "nextjs";
const isRecord = (val)=>{
    return typeof val === "object" && val !== null;
};
const isFunction = (val)=>{
    return typeof val === "function";
};
const isNext12ApiResponse = (val)=>{
    return isRecord(val) && isFunction(val.setHeader) && isFunction(val.status) && isFunction(val.send);
};
/**
* In Next.js, serve and register any declared functions with Inngest, making
* them available to be triggered by events.
*
* Supports Next.js 12+, both serverless and edge.
*
* @example Next.js <=12 or the pages router can export the handler directly
* ```ts
* export default serve({ client: inngest, functions: [fn1, fn2] });
* ```
*
* @example Next.js >=13 with the `app` dir must export individual methods
* ```ts
* export const { GET, POST, PUT } = serve({
*            client: inngest,
*            functions: [fn1, fn2],
* });
* ```
*
* @public
*/ const serve = (options)=>{
    /**
	* Next.js 13 uses
	* {@link https://beta.nextjs.org/docs/routing/route-handlers Route Handlers}
	* to declare API routes instead of a generic catch-all method that was
	* available using the `pages/api` directory.
	*
	* This means that users must now export a function for each method supported
	* by the endpoint. For us, this means requiring a user explicitly exports
	* `GET`, `POST`, and `PUT` functions.
	*
	* Because of this, we'll add circular references to those property names of
	* the returned handler, meaning we can write some succinct code to export
	* them. Thanks, @goodoldneon.
	*
	* @example
	* ```ts
	* export const { GET, POST, PUT } = serve(...);
	* ```
	*
	* See {@link https://beta.nextjs.org/docs/routing/route-handlers}
	*/ const baseFn = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$components$2f$InngestCommHandler$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["InngestCommHandler"]({
        frameworkName,
        ...options,
        handler: (reqMethod, ...args)=>{
            const [expectedReq, res] = args;
            const req = expectedReq;
            const getHeader = (key)=>{
                const header = typeof req.headers.get === "function" ? req.headers.get(key) : req.headers[key];
                return Array.isArray(header) ? header[0] : header;
            };
            return {
                body: ()=>typeof req.json === "function" ? req.json() : req.body,
                headers: getHeader,
                method: ()=>{
                    return reqMethod || req.method || "";
                },
                isProduction: ()=>{
                    /**
					* Vercel Edge Functions do not allow dynamic access to environment
					* variables, so we'll manage production checks directly here.
					*
					* We try/catch to avoid situations where Next.js is being used in
					* environments where `process.env` is not accessible or polyfilled.
					*/ try {
                        return ("TURBOPACK compile-time value", "development") === "production";
                    } catch (_err) {}
                },
                queryString: (key, url)=>{
                    const qs = req.query?.[key] || url.searchParams.get(key);
                    return Array.isArray(qs) ? qs[0] : qs;
                },
                url: ()=>{
                    let absoluteUrl;
                    try {
                        absoluteUrl = new URL(req.url);
                    } catch  {}
                    if (absoluteUrl) {
                        /**
						* `req.url` here should may be the full URL, including query string.
						* There are some caveats, however, where Next.js will obfuscate
						* the host. For example, in the case of `host.docker.internal`,
						* Next.js will instead set the host here to `localhost`.
						*
						* To avoid this, we'll try to parse the URL from `req.url`, but
						* also use the `host` header if it's available.
						*/ const host$1 = options.serveHost || getHeader("host");
                        if (host$1) {
                            const hostWithProtocol = new URL(host$1.includes("://") ? host$1 : `${absoluteUrl.protocol}//${host$1}`);
                            absoluteUrl.protocol = hostWithProtocol.protocol;
                            absoluteUrl.host = hostWithProtocol.host;
                            absoluteUrl.port = hostWithProtocol.port;
                            absoluteUrl.username = hostWithProtocol.username;
                            absoluteUrl.password = hostWithProtocol.password;
                        }
                        return absoluteUrl;
                    }
                    let scheme = "https";
                    const host = options.serveHost || getHeader("host") || "";
                    try {
                        if (("TURBOPACK compile-time value", "development") === "development") scheme = "http";
                    } catch (_err) {}
                    return new URL(req.url, `${scheme}://${host}`);
                },
                transformResponse: ({ body, headers, status })=>{
                    /**
					* Carefully attempt to set headers and data on the response object
					* for Next.js 12 support.
					*
					* This also assumes that we're not using Next.js 15, where the `res`
					* object is repopulated as a `RouteContext` object. We expect these
					* methods to NOT be defined in Next.js 15.
					*
					* We could likely use `instanceof ServerResponse` to better check the
					* type of this, though Next.js 12 had issues with this due to not
					* instantiating the response correctly.
					*/ if (isNext12ApiResponse(res)) {
                        for (const [key, value] of Object.entries(headers))res.setHeader(key, value);
                        res.status(status);
                        res.send(body);
                        /**
						* If we're here, we're in a serverless endpoint (not edge), so
						* we've correctly sent the response and can return `undefined`.
						*
						* Next.js 13 edge requires that the return value is typed as
						* `Response`, so we still enforce that as we cannot dynamically
						* adjust typing based on the environment.
						*/ return;
                    }
                    return new ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$env$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getResponse"])())(body, {
                        status,
                        headers
                    });
                },
                transformStreamingResponse: ({ body, headers, status })=>{
                    return new Response(body, {
                        status,
                        headers
                    });
                }
            };
        }
    }).createHandler();
    const fn = baseFn.bind(null, void 0);
    /**
	* Ensure we have a non-variadic length to avoid issues with forced type
	* checking.
	*/ Object.defineProperty(fn, "length", {
        value: 1
    });
    return Object.defineProperties(fn, {
        GET: {
            value: baseFn.bind(null, "GET")
        },
        POST: {
            value: baseFn.bind(null, "POST")
        },
        PUT: {
            value: baseFn.bind(null, "PUT")
        }
    });
};
;
 //# sourceMappingURL=next.js.map
}}),
"[project]/node_modules/.pnpm/inngest@3.45.1_@opentelemetry+core@2.2.0_@opentelemetry+api@1.9.0__express@4.21.2_next@_c75e0c332defb7a954d9a52cadcbb8f7/node_modules/inngest/api/api.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "InngestApi": (()=>InngestApi)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/inngest@3.45.1_@opentelemetry+core@2.2.0_@opentelemetry+api@1.9.0__express@4.21.2_next@_c75e0c332defb7a954d9a52cadcbb8f7/node_modules/inngest/helpers/consts.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/inngest@3.45.1_@opentelemetry+core@2.2.0_@opentelemetry+api@1.9.0__express@4.21.2_next@_c75e0c332defb7a954d9a52cadcbb8f7/node_modules/inngest/types.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$api$2f$schema$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/inngest@3.45.1_@opentelemetry+core@2.2.0_@opentelemetry+api@1.9.0__express@4.21.2_next@_c75e0c332defb7a954d9a52cadcbb8f7/node_modules/inngest/api/schema.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$errors$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/inngest@3.45.1_@opentelemetry+core@2.2.0_@opentelemetry+api@1.9.0__express@4.21.2_next@_c75e0c332defb7a954d9a52cadcbb8f7/node_modules/inngest/helpers/errors.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$strings$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/inngest@3.45.1_@opentelemetry+core@2.2.0_@opentelemetry+api@1.9.0__express@4.21.2_next@_c75e0c332defb7a954d9a52cadcbb8f7/node_modules/inngest/helpers/strings.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$devserver$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/inngest@3.45.1_@opentelemetry+core@2.2.0_@opentelemetry+api@1.9.0__express@4.21.2_next@_c75e0c332defb7a954d9a52cadcbb8f7/node_modules/inngest/helpers/devserver.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$net$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/inngest@3.45.1_@opentelemetry+core@2.2.0_@opentelemetry+api@1.9.0__express@4.21.2_next@_c75e0c332defb7a954d9a52cadcbb8f7/node_modules/inngest/helpers/net.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/zod@3.25.76/node_modules/zod/v3/external.js [app-route] (ecmascript) <export * as z>");
;
;
;
;
;
;
;
;
//#region src/api/api.ts
const realtimeSubscriptionTokenSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
    jwt: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string()
});
const sendSignalSuccessResponseSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
    data: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
        run_id: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().min(1)
    })
});
const checkpointNewRunResponseSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
    data: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
        fn_id: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().min(1),
        app_id: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().min(1),
        run_id: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().min(1),
        token: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$3$2e$25$2e$76$2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().min(1).optional()
    })
});
var InngestApi = class {
    apiBaseUrl;
    signingKey;
    signingKeyFallback;
    fetch;
    mode;
    constructor({ baseUrl, signingKey, signingKeyFallback, fetch, mode }){
        this.apiBaseUrl = baseUrl;
        this.signingKey = signingKey;
        this.signingKeyFallback = signingKeyFallback;
        this.fetch = fetch;
        this.mode = mode;
    }
    get hashedKey() {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$strings$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["hashSigningKey"])(this.signingKey);
    }
    get hashedFallbackKey() {
        if (!this.signingKeyFallback) return;
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$strings$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["hashSigningKey"])(this.signingKeyFallback);
    }
    setSigningKey(key) {
        if (typeof key === "string" && this.signingKey === "") this.signingKey = key;
    }
    setSigningKeyFallback(key) {
        if (typeof key === "string" && !this.signingKeyFallback) this.signingKeyFallback = key;
    }
    async getTargetUrl(path) {
        if (this.apiBaseUrl) return new URL(path, this.apiBaseUrl);
        let url = new URL(path, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["defaultInngestApiBaseUrl"]);
        if (this.mode.isDev && this.mode.isInferred && !this.apiBaseUrl) {
            if (await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$devserver$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["devServerAvailable"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["defaultDevServerHost"], this.fetch)) url = new URL(path, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["defaultDevServerHost"]);
        }
        return url;
    }
    async req(url, options) {
        const finalUrl = typeof url === "string" ? await this.getTargetUrl(url) : url;
        try {
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ok"])(await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$net$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["fetchWithAuthFallback"])({
                authToken: this.hashedKey,
                authTokenFallback: this.hashedFallbackKey,
                fetch: this.fetch,
                url: finalUrl,
                options: {
                    ...options,
                    headers: {
                        "Content-Type": "application/json",
                        ...options?.headers
                    }
                }
            }));
        } catch (error) {
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["err"])(error);
        }
    }
    async getRunSteps(runId, version) {
        const result = await this.req(`/v0/runs/${runId}/actions`);
        if (result.ok) {
            const res = result.value;
            const data = await res.json();
            if (res.ok) return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ok"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$api$2f$schema$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["stepsSchemas"][version].parse(data));
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["err"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$api$2f$schema$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["errorSchema"].parse(data));
        }
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["err"])({
            error: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$errors$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getErrorMessage"])(result.error, "Unknown error retrieving step data"),
            status: 500
        });
    }
    async getRunBatch(runId) {
        const result = await this.req(`/v0/runs/${runId}/batch`);
        if (result.ok) {
            const res = result.value;
            const data = await res.json();
            if (res.ok) return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ok"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$api$2f$schema$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["batchSchema"].parse(data));
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["err"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$api$2f$schema$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["errorSchema"].parse(data));
        }
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["err"])({
            error: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$errors$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getErrorMessage"])(result.error, "Unknown error retrieving event batch"),
            status: 500
        });
    }
    async publish(publishOptions, data) {
        const isStream = data instanceof ReadableStream;
        const url = await this.getTargetUrl("/v1/realtime/publish");
        url.searchParams.set("channel", publishOptions.channel || "");
        if (publishOptions.runId) url.searchParams.set("run_id", publishOptions.runId);
        for (const topic of publishOptions.topics)url.searchParams.append("topic", topic);
        const result = await this.req(url, {
            body: isStream ? data : typeof data === "string" ? data : JSON.stringify(data),
            method: "POST",
            headers: {
                "Content-Type": isStream ? "text/stream" : "application/json"
            },
            ...isStream ? {
                duplex: "half"
            } : {}
        });
        if (result.ok) {
            const res = result.value;
            if (!res.ok) throw new Error(`Failed to publish event: ${res.status} ${res.statusText}`);
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ok"])(void 0);
        }
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["err"])({
            error: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$errors$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getErrorMessage"])(result.error, "Unknown error publishing event"),
            status: 500
        });
    }
    async sendSignal(signalOptions, options) {
        const url = await this.getTargetUrl("/v1/signals");
        const body = {
            signal: signalOptions.signal,
            data: signalOptions.data
        };
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$net$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["fetchWithAuthFallback"])({
            authToken: this.hashedKey,
            authTokenFallback: this.hashedFallbackKey,
            fetch: this.fetch,
            url,
            options: {
                method: "POST",
                body: JSON.stringify(body),
                headers: {
                    "Content-Type": "application/json",
                    ...options?.headers
                }
            }
        }).then(async (res)=>{
            if (res.status === 404) return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ok"])({
                runId: void 0
            });
            const resClone = res.clone();
            let json;
            try {
                json = await res.json();
            } catch  {
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["err"])({
                    error: `Failed to send signal: ${res.status} ${res.statusText} - ${await resClone.text()}`,
                    status: res.status
                });
            }
            if (!res.ok) try {
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["err"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$api$2f$schema$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["errorSchema"].parse(json));
            } catch  {
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["err"])({
                    error: `Failed to send signal: ${res.status} ${res.statusText} - ${await res.text()}`,
                    status: res.status
                });
            }
            const parseRes = sendSignalSuccessResponseSchema.safeParse(json);
            if (!parseRes.success) return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["err"])({
                error: `Successfully sent signal, but response parsing failed: ${res.status} ${res.statusText} - ${await resClone.text()}`,
                status: res.status
            });
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ok"])({
                runId: parseRes.data.data.run_id
            });
        }).catch((error)=>{
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["err"])({
                error: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$errors$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getErrorMessage"])(error, "Unknown error sending signal"),
                status: 500
            });
        });
    }
    async getSubscriptionToken(channel, topics) {
        const url = await this.getTargetUrl("/v1/realtime/token");
        const body = topics.map((topic)=>({
                channel,
                name: topic,
                kind: "run"
            }));
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$net$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["fetchWithAuthFallback"])({
            authToken: this.hashedKey,
            authTokenFallback: this.hashedFallbackKey,
            fetch: this.fetch,
            url,
            options: {
                method: "POST",
                body: JSON.stringify(body),
                headers: {
                    "Content-Type": "application/json"
                }
            }
        }).then(async (res)=>{
            if (!res.ok) throw new Error(`Failed to get subscription token: ${res.status} ${res.statusText} - ${await res.text()}`);
            return realtimeSubscriptionTokenSchema.parse(await res.json()).jwt;
        }).catch((error)=>{
            throw new Error((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$errors$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getErrorMessage"])(error, "Unknown error getting subscription token"));
        });
    }
    /**
	* Start a new run, optionally passing in a number of steps to initialize the
	* run with.
	*/ async checkpointNewRun(args) {
        const body = JSON.stringify({
            run_id: args.runId,
            event: args.event,
            steps: args.steps
        });
        const result = await this.req("/v1/checkpoint", {
            method: "POST",
            body
        });
        if (!result.ok) throw new Error((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$errors$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getErrorMessage"])(result.error, "Unknown error checkpointing new run"));
        const res = result.value;
        if (res.ok) {
            const rawData = await res.json();
            return checkpointNewRunResponseSchema.parse(rawData);
        }
        throw new Error(`Failed to checkpoint new run: ${res.status} ${res.statusText} - ${await res.text()}`);
    }
    /**
	* Checkpoint steps for a given run.
	*/ async checkpointSteps(args) {
        const body = JSON.stringify({
            fn_id: args.fnId,
            app_id: args.appId,
            run_id: args.runId,
            steps: args.steps
        });
        const result = await this.req(`/v1/checkpoint/${args.runId}/steps`, {
            method: "POST",
            body
        });
        if (!result.ok) throw new Error((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$errors$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getErrorMessage"])(result.error, "Unknown error checkpointing steps"));
        const res = result.value;
        if (!res.ok) throw new Error(`Failed to checkpoint steps: ${res.status} ${res.statusText} - ${await res.text()}`);
    }
};
;
 //# sourceMappingURL=api.js.map
}}),
"[project]/node_modules/.pnpm/inngest@3.45.1_@opentelemetry+core@2.2.0_@opentelemetry+api@1.9.0__express@4.21.2_next@_c75e0c332defb7a954d9a52cadcbb8f7/node_modules/inngest/helpers/crypto.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
//#region src/helpers/crypto.ts
/**
* Create a cryptographically secure random value.
*
* @throws {Error} If the crypto module is not available.
*/ __turbopack_context__.s({
    "createEntropy": (()=>createEntropy)
});
function createEntropy(byteLength) {
    const bytes = new Uint8Array(byteLength);
    const { crypto } = globalThis;
    if (!crypto) throw new Error("missing crypto module");
    if (!crypto.getRandomValues) throw new Error("missing crypto.getRandomValues");
    crypto.getRandomValues(bytes);
    return bytes;
}
;
 //# sourceMappingURL=crypto.js.map
}}),
"[project]/node_modules/.pnpm/inngest@3.45.1_@opentelemetry+core@2.2.0_@opentelemetry+api@1.9.0__express@4.21.2_next@_c75e0c332defb7a954d9a52cadcbb8f7/node_modules/inngest/middleware/logger.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "DefaultLogger": (()=>DefaultLogger),
    "ProxyLogger": (()=>ProxyLogger)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$promises$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/inngest@3.45.1_@opentelemetry+core@2.2.0_@opentelemetry+api@1.9.0__express@4.21.2_next@_c75e0c332defb7a954d9a52cadcbb8f7/node_modules/inngest/helpers/promises.js [app-route] (ecmascript)");
;
//#region src/middleware/logger.ts
var DefaultLogger = class {
    info(...args) {
        console.info(...args);
    }
    warn(...args) {
        console.warn(...args);
    }
    error(...args) {
        console.error(...args);
    }
    debug(...args) {
        console.debug(...args);
    }
};
/**
* ProxyLogger aims to provide a thin wrapper on user's provided logger.
* It's expected to be turned on and off based on the function execution
* context, so it doesn't result in duplicated logging.
*
* And also attempt to allow enough time for the logger to flush all logs.
*
* @public
*/ var ProxyLogger = class {
    logger;
    enabled = false;
    constructor(logger){
        this.logger = logger;
        return new Proxy(this, {
            get (target, prop, receiver) {
                if (prop in target) return Reflect.get(target, prop, receiver);
                return Reflect.get(target.logger, prop, receiver);
            }
        });
    }
    info(...args) {
        if (!this.enabled) return;
        this.logger.info(...args);
    }
    warn(...args) {
        if (!this.enabled) return;
        this.logger.warn(...args);
    }
    error(...args) {
        if (!this.enabled) return;
        this.logger.error(...args);
    }
    debug(...args) {
        if (!this.enabled || !(typeof this.logger.debug === "function")) return;
        this.logger.debug(...args);
    }
    enable() {
        this.enabled = true;
    }
    disable() {
        this.enabled = false;
    }
    async flush() {
        if (this.logger.constructor.name == DefaultLogger.name) return;
        const logger = this.logger;
        if (typeof logger.flush === "function") {
            await logger.flush();
            return;
        }
        await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$promises$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["resolveNextTick"])();
    }
};
;
 //# sourceMappingURL=logger.js.map
}}),
"[project]/node_modules/.pnpm/inngest@3.45.1_@opentelemetry+core@2.2.0_@opentelemetry+api@1.9.0__express@4.21.2_next@_c75e0c332defb7a954d9a52cadcbb8f7/node_modules/inngest/components/Inngest.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "Inngest": (()=>Inngest)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/inngest@3.45.1_@opentelemetry+core@2.2.0_@opentelemetry+api@1.9.0__express@4.21.2_next@_c75e0c332defb7a954d9a52cadcbb8f7/node_modules/inngest/helpers/consts.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/inngest@3.45.1_@opentelemetry+core@2.2.0_@opentelemetry+api@1.9.0__express@4.21.2_next@_c75e0c332defb7a954d9a52cadcbb8f7/node_modules/inngest/types.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$errors$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/inngest@3.45.1_@opentelemetry+core@2.2.0_@opentelemetry+api@1.9.0__express@4.21.2_next@_c75e0c332defb7a954d9a52cadcbb8f7/node_modules/inngest/helpers/errors.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$components$2f$InngestMiddleware$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/inngest@3.45.1_@opentelemetry+core@2.2.0_@opentelemetry+api@1.9.0__express@4.21.2_next@_c75e0c332defb7a954d9a52cadcbb8f7/node_modules/inngest/components/InngestMiddleware.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$strings$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/inngest@3.45.1_@opentelemetry+core@2.2.0_@opentelemetry+api@1.9.0__express@4.21.2_next@_c75e0c332defb7a954d9a52cadcbb8f7/node_modules/inngest/helpers/strings.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$env$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/inngest@3.45.1_@opentelemetry+core@2.2.0_@opentelemetry+api@1.9.0__express@4.21.2_next@_c75e0c332defb7a954d9a52cadcbb8f7/node_modules/inngest/helpers/env.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$devserver$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/inngest@3.45.1_@opentelemetry+core@2.2.0_@opentelemetry+api@1.9.0__express@4.21.2_next@_c75e0c332defb7a954d9a52cadcbb8f7/node_modules/inngest/helpers/devserver.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$promises$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/inngest@3.45.1_@opentelemetry+core@2.2.0_@opentelemetry+api@1.9.0__express@4.21.2_next@_c75e0c332defb7a954d9a52cadcbb8f7/node_modules/inngest/helpers/promises.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$components$2f$InngestFunction$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/inngest@3.45.1_@opentelemetry+core@2.2.0_@opentelemetry+api@1.9.0__express@4.21.2_next@_c75e0c332defb7a954d9a52cadcbb8f7/node_modules/inngest/components/InngestFunction.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$api$2f$api$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/inngest@3.45.1_@opentelemetry+core@2.2.0_@opentelemetry+api@1.9.0__express@4.21.2_next@_c75e0c332defb7a954d9a52cadcbb8f7/node_modules/inngest/api/api.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$crypto$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/inngest@3.45.1_@opentelemetry+core@2.2.0_@opentelemetry+api@1.9.0__express@4.21.2_next@_c75e0c332defb7a954d9a52cadcbb8f7/node_modules/inngest/helpers/crypto.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$middleware$2f$logger$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/inngest@3.45.1_@opentelemetry+core@2.2.0_@opentelemetry+api@1.9.0__express@4.21.2_next@_c75e0c332defb7a954d9a52cadcbb8f7/node_modules/inngest/middleware/logger.js [app-route] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
;
;
//#region src/components/Inngest.ts
/**
* A client used to interact with the Inngest API by sending or reacting to
* events.
*
* To provide event typing, see {@link EventSchemas}.
*
* ```ts
* const inngest = new Inngest({ id: "my-app" });
*
* // or to provide event typing too
* const inngest = new Inngest({
*   id: "my-app",
*   schemas: new EventSchemas().fromRecord<{
*     "app/user.created": {
*       data: { userId: string };
*     };
*   }>(),
* });
* ```
*
* @public
*/ var Inngest = class Inngest {
    get [Symbol.toStringTag]() {
        return Inngest.Tag;
    }
    /**
	* The ID of this instance, most commonly a reference to the application it
	* resides in.
	*
	* The ID of your client should remain the same for its lifetime; if you'd
	* like to change the name of your client as it appears in the Inngest UI,
	* change the `name` property instead.
	*/ id;
    /**
	* Stores the options so we can remember explicit settings the user has
	* provided.
	*/ options;
    /**
	* Inngest event key, used to send events to Inngest Cloud.
	*/ eventKey = "";
    _apiBaseUrl;
    _eventBaseUrl;
    inngestApi;
    /**
	* The absolute URL of the Inngest Cloud API.
	*/ sendEventUrl = new URL(`e/${this.eventKey}`, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["defaultInngestEventBaseUrl"]);
    headers;
    fetch;
    logger;
    localFns = [];
    /**
	* A promise that resolves when the middleware stack has been initialized and
	* the client is ready to be used.
	*/ middleware;
    /**
	* Whether the client is running in a production environment. This can
	* sometimes be `undefined` if the client has expressed no preference or
	* perhaps environment variables are only available at a later stage in the
	* runtime, for example when receiving a request.
	*
	* An {@link InngestCommHandler} should prioritize this value over all other
	* settings, but should still check for the presence of an environment
	* variable if it is not set.
	*/ _mode;
    schemas;
    _appVersion;
    get apiBaseUrl() {
        return this._apiBaseUrl;
    }
    get eventBaseUrl() {
        return this._eventBaseUrl;
    }
    get env() {
        return this.headers[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["headerKeys"].Environment] ?? null;
    }
    get appVersion() {
        return this._appVersion;
    }
    /**
	* A client used to interact with the Inngest API by sending or reacting to
	* events.
	*
	* To provide event typing, see {@link EventSchemas}.
	*
	* ```ts
	* const inngest = new Inngest({ name: "My App" });
	*
	* // or to provide event typing too
	* const inngest = new Inngest({
	*   name: "My App",
	*   schemas: new EventSchemas().fromRecord<{
	*     "app/user.created": {
	*       data: { userId: string };
	*     };
	*   }>(),
	* });
	* ```
	*/ constructor(options){
        this.options = options;
        const { id, fetch, logger = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$middleware$2f$logger$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["DefaultLogger"](), middleware, isDev, schemas, appVersion } = this.options;
        if (!id) throw new Error("An `id` must be passed to create an Inngest instance.");
        this.id = id;
        this._mode = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$env$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getMode"])({
            explicitMode: typeof isDev === "boolean" ? isDev ? "dev" : "cloud" : void 0
        });
        this.fetch = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$env$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getFetch"])(fetch);
        this.inngestApi = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$api$2f$api$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["InngestApi"]({
            baseUrl: this.apiBaseUrl,
            signingKey: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$env$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["processEnv"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["envKeys"].InngestSigningKey) || "",
            signingKeyFallback: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$env$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["processEnv"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["envKeys"].InngestSigningKeyFallback),
            fetch: this.fetch,
            mode: this.mode
        });
        this.schemas = schemas;
        this.loadModeEnvVars();
        this.logger = logger;
        this.middleware = this.initializeMiddleware([
            ...builtInMiddleware,
            ...middleware || []
        ]);
        this._appVersion = appVersion;
    }
    /**
	* Returns a `Promise` that resolves when the app is ready and all middleware
	* has been initialized.
	*/ get ready() {
        return this.middleware.then(()=>{});
    }
    /**
	* Set the environment variables for this client. This is useful if you are
	* passed environment variables at runtime instead of as globals and need to
	* update the client with those values as requests come in.
	*/ setEnvVars(env = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$env$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["allProcessEnv"])()) {
        this.mode = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$env$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getMode"])({
            env,
            client: this
        });
        return this;
    }
    loadModeEnvVars() {
        this._apiBaseUrl = this.options.baseUrl || this.mode["env"][__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["envKeys"].InngestApiBaseUrl] || this.mode["env"][__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["envKeys"].InngestBaseUrl] || this.mode.getExplicitUrl(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["defaultInngestApiBaseUrl"]);
        this._eventBaseUrl = this.options.baseUrl || this.mode["env"][__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["envKeys"].InngestEventApiBaseUrl] || this.mode["env"][__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["envKeys"].InngestBaseUrl] || this.mode.getExplicitUrl(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["defaultInngestEventBaseUrl"]);
        this.setEventKey(this.options.eventKey || this.mode["env"][__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["envKeys"].InngestEventKey] || "");
        this.headers = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$env$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["inngestHeaders"])({
            inngestEnv: this.options.env,
            env: this.mode["env"]
        });
        this.inngestApi["mode"] = this.mode;
        this.inngestApi["apiBaseUrl"] = this._apiBaseUrl;
    }
    /**
	* Initialize all passed middleware, running the `register` function on each
	* in sequence and returning the requested hook registrations.
	*/ async initializeMiddleware(middleware = [], opts) {
        /**
		* Wait for the prefix stack to run first; do not trigger ours before this
		* is complete.
		*/ const prefix = await (opts?.prefixStack ?? []);
        const stack = middleware.reduce(async (acc, m)=>{
            const prev = await acc;
            const next = await m.init({
                client: this,
                ...opts?.registerInput
            });
            return [
                ...prev,
                next
            ];
        }, Promise.resolve([]));
        return [
            ...prefix,
            ...await stack
        ];
    }
    get mode() {
        return this._mode;
    }
    set mode(m) {
        this._mode = m;
        this.loadModeEnvVars();
    }
    /**
	* Given a response from Inngest, relay the error to the caller.
	*/ async getResponseError(response, rawBody, foundErr = "Unknown error") {
        let errorMessage = foundErr;
        if (errorMessage === "Unknown error") switch(response.status){
            case 401:
                errorMessage = "Event key Not Found";
                break;
            case 400:
                errorMessage = "Cannot process event payload";
                break;
            case 403:
                errorMessage = "Forbidden";
                break;
            case 404:
                errorMessage = "Event key not found";
                break;
            case 406:
                errorMessage = `${JSON.stringify(await rawBody)}`;
                break;
            case 409:
            case 412:
                errorMessage = "Event transformation failed";
                break;
            case 413:
                errorMessage = "Event payload too large";
                break;
            case 500:
                errorMessage = "Internal server error";
                break;
            default:
                try {
                    errorMessage = await response.text();
                } catch (_err) {
                    errorMessage = `${JSON.stringify(await rawBody)}`;
                }
                break;
        }
        return /* @__PURE__ */ new Error(`Inngest API Error: ${response.status} ${errorMessage}`);
    }
    /**
	* Set the event key for this instance of Inngest. This is useful if for some
	* reason the key is not available at time of instantiation or present in the
	* `INNGEST_EVENT_KEY` environment variable.
	*/ setEventKey(eventKey) {
        this.eventKey = eventKey || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["dummyEventKey"];
        this.sendEventUrl = new URL(`e/${this.eventKey}`, this.eventBaseUrl || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["defaultInngestEventBaseUrl"]);
    }
    eventKeySet() {
        return Boolean(this.eventKey) && this.eventKey !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["dummyEventKey"];
    }
    /**
	* EXPERIMENTAL: This API is not yet stable and may change in the future
	* without a major version bump.
	*
	* Send a Signal to Inngest.
	*/ async sendSignal({ signal, data, env }) {
        const headers = {
            ...env ? {
                [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["headerKeys"].Environment]: env
            } : {}
        };
        return this._sendSignal({
            signal,
            data,
            headers
        });
    }
    async _sendSignal({ signal, data, headers }) {
        const res = await this.inngestApi.sendSignal({
            signal,
            data
        }, {
            ...this.headers,
            ...headers
        });
        if (res.ok) return res.value;
        throw new Error(`Failed to send signal: ${res.error?.error || "Unknown error"}`);
    }
    /**
	* Send one or many events to Inngest. Takes an entire payload (including
	* name) as each input.
	*
	* ```ts
	* await inngest.send({ name: "app/user.created", data: { id: 123 } });
	* ```
	*
	* Returns a promise that will resolve if the event(s) were sent successfully,
	* else throws with an error explaining what went wrong.
	*
	* If you wish to send an event with custom types (i.e. one that hasn't been
	* generated), make sure to add it when creating your Inngest instance, like
	* so:
	*
	* ```ts
	* const inngest = new Inngest({
	*   name: "My App",
	*   schemas: new EventSchemas().fromRecord<{
	*     "my/event": {
	*       name: "my/event";
	*       data: { bar: string };
	*     };
	*   }>(),
	* });
	* ```
	*/ async send(payload, options) {
        const headers = {
            ...options?.env ? {
                [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["headerKeys"].Environment]: options.env
            } : {}
        };
        return this._send({
            payload,
            headers
        });
    }
    /**
	* Internal method for sending an event, used to allow Inngest internals to
	* further customize the request sent to an Inngest Server.
	*/ async _send({ payload, headers }) {
        const nowMillis = /* @__PURE__ */ new Date().getTime();
        let maxAttempts = 5;
        try {
            const entropy = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$crypto$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createEntropy"])(10);
            const entropyBase64 = Buffer.from(entropy).toString("base64");
            headers = {
                ...headers,
                [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["headerKeys"].EventIdSeed]: `${nowMillis},${entropyBase64}`
            };
        } catch (err) {
            let message = "Event-sending retries disabled";
            if (err instanceof Error) message += `: ${err.message}`;
            console.debug(message);
            maxAttempts = 1;
        }
        const hooks = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$components$2f$InngestMiddleware$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getHookStack"])(this.middleware, "onSendEvent", void 0, {
            transformInput: (prev, output)=>{
                return {
                    ...prev,
                    ...output
                };
            },
            transformOutput (prev, output) {
                return {
                    result: {
                        ...prev.result,
                        ...output?.result
                    }
                };
            }
        });
        let payloads = Array.isArray(payload) ? payload : payload ? [
            payload
        ] : [];
        const inputChanges = await hooks.transformInput?.({
            payloads: [
                ...payloads
            ]
        });
        if (inputChanges?.payloads) payloads = [
            ...inputChanges.payloads
        ];
        payloads = payloads.map((p)=>{
            return {
                ...p,
                id: p.id,
                ts: p.ts || nowMillis,
                data: p.data || {}
            };
        });
        const applyHookToOutput = async (arg)=>{
            const hookOutput = await hooks.transformOutput?.(arg);
            return {
                ...arg.result,
                ...hookOutput?.result
            };
        };
        /**
		* It can be valid for a user to send an empty list of events; if this
		* happens, show a warning that this may not be intended, but don't throw.
		*/ if (!payloads.length) {
            console.warn((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$errors$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["prettyError"])({
                type: "warn",
                whatHappened: "`inngest.send()` called with no events",
                reassurance: "This is not an error, but you may not have intended to do this.",
                consequences: "The returned promise will resolve, but no events have been sent to Inngest.",
                stack: true
            }));
            return await applyHookToOutput({
                result: {
                    ids: []
                }
            });
        }
        let url = this.sendEventUrl.href;
        /**
		* If in prod mode and key is not present, fail now.
		*/ if (this.mode.isCloud && !this.eventKeySet()) throw new Error((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$errors$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["prettyError"])({
            whatHappened: "Failed to send event",
            consequences: "Your event or events were not sent to Inngest.",
            why: "We couldn't find an event key to use to send events to Inngest.",
            toFixNow: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$errors$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["fixEventKeyMissingSteps"]
        }));
        /**
		* If dev mode has been inferred, try to hit the dev server first to see if
		* it exists. If it does, use it, otherwise fall back to whatever server we
		* have configured.
		*
		* `INNGEST_BASE_URL` is used to set both dev server and prod URLs, so if a
		* user has set this it means they have already chosen a URL to hit.
		*/ if (this.mode.isDev && this.mode.isInferred && !this.eventBaseUrl) {
            if (await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$devserver$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["devServerAvailable"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["defaultDevServerHost"], this.fetch)) url = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$devserver$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["devServerUrl"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["defaultDevServerHost"], `e/${this.eventKey}`).href;
        }
        return await applyHookToOutput({
            result: {
                ids: (await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$promises$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["retryWithBackoff"])(async ()=>{
                    let rawBody;
                    let body;
                    const response = await this.fetch(url, {
                        method: "POST",
                        body: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$strings$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["stringify"])(payloads),
                        headers: {
                            ...this.headers,
                            ...headers
                        }
                    });
                    try {
                        rawBody = await response.json();
                        body = await __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["sendEventResponseSchema"].parseAsync(rawBody);
                    } catch (_err) {
                        throw await this.getResponseError(response, rawBody);
                    }
                    if (body.status !== 200 || body.error) throw await this.getResponseError(response, rawBody, body.error);
                    return body;
                }, {
                    maxAttempts,
                    baseDelay: 100
                })).ids
            }
        });
    }
    createFunction = (rawOptions, rawTrigger, handler)=>{
        const fn = this._createFunction(rawOptions, rawTrigger, handler);
        this.localFns.push(fn);
        return fn;
    };
    get funcs() {
        return this.localFns;
    }
    _createFunction = (rawOptions, rawTrigger, handler)=>{
        const options = this.sanitizeOptions(rawOptions);
        const triggers = this.sanitizeTriggers(rawTrigger);
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$components$2f$InngestFunction$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["InngestFunction"](this, {
            ...options,
            triggers
        }, handler);
    };
    /**
	* Runtime-only validation.
	*/ sanitizeOptions(options) {
        if (Object.hasOwn(options, "fns")) console.warn(`${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["logPrefix"]} InngestFunction: \`fns\` option has been deprecated in v3; use \`middleware\` instead. See https://www.inngest.com/docs/sdk/migration`);
        if (typeof options === "string") {
            console.warn(`${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["logPrefix"]} InngestFunction: Creating a function with a string as the first argument has been deprecated in v3; pass an object instead. See https://www.inngest.com/docs/sdk/migration`);
            return {
                id: options
            };
        }
        return options;
    }
    /**
	* Runtime-only validation.
	*/ sanitizeTriggers(triggers) {
        if (typeof triggers === "string") {
            console.warn(`${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["logPrefix"]} InngestFunction: Creating a function with a string as the second argument has been deprecated in v3; pass an object instead. See https://www.inngest.com/docs/sdk/migration`);
            return [
                {
                    event: triggers
                }
            ];
        }
        if (!Array.isArray(triggers)) return [
            triggers
        ];
        return triggers;
    }
};
/**
* Default middleware that is included in every client, placed after the user's
* middleware on the client but before function-level middleware.
*
* It is defined here to ensure that comments are included in the generated TS
* definitions. Without this, we infer the stack of built-in middleware without
* comments, losing a lot of value.
*
* If this is moved, please ensure that using this package in another project
* can correctly access comments on mutated input and output.
*
* This return pattern mimics the output of a `satisfies` suffix; it's used as
* we support versions of TypeScript prior to the introduction of `satisfies`.
*/ const builtInMiddleware = ((m)=>m)([
    new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$components$2f$InngestMiddleware$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["InngestMiddleware"]({
        name: "Inngest: Logger",
        init ({ client }) {
            return {
                onFunctionRun (arg) {
                    const { ctx } = arg;
                    const metadata = {
                        runID: ctx.runId,
                        eventName: ctx.event.name,
                        functionName: arg.fn.name
                    };
                    let providedLogger = client["logger"];
                    try {
                        if ("child" in providedLogger) providedLogger = providedLogger.child(metadata);
                    } catch (err) {
                        console.error("failed to create \"childLogger\" with error: ", err);
                    }
                    const logger = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$inngest$40$3$2e$45$2e$1_$40$opentelemetry$2b$core$40$2$2e$2$2e$0_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_$5f$express$40$4$2e$21$2e$2_next$40$_c75e0c332defb7a954d9a52cadcbb8f7$2f$node_modules$2f$inngest$2f$middleware$2f$logger$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ProxyLogger"](providedLogger);
                    return {
                        transformInput () {
                            return {
                                ctx: {
                                    logger
                                }
                            };
                        },
                        beforeExecution () {
                            logger.enable();
                        },
                        transformOutput ({ result: { error } }) {
                            if (error) logger.error(error);
                        },
                        async beforeResponse () {
                            await logger.flush();
                        }
                    };
                }
            };
        }
    })
]);
(function(_Inngest) {
    _Inngest.Tag = "Inngest.App";
})(Inngest || (Inngest = {}));
;
 //# sourceMappingURL=Inngest.js.map
}}),
"[project]/node_modules/.pnpm/inngest@3.32.5_express@4.21.2_next@15.3.4_@opentelemetry+api@1.9.0_react-dom@19.2.0_rea_302ab31fd2a599b814fb517e8771719b/node_modules/inngest/components/EventSchemas.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var __rest = this && this.__rest || function(s, e) {
    var t = {};
    for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function") for(var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++){
        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
    }
    return t;
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.EventSchemas = void 0;
/**
 * Provide an `EventSchemas` class to type events, providing type safety when
 * sending events and running functions via Inngest.
 *
 * You can provide generated Inngest types, custom types, types using Zod, or
 * a combination of the above. See {@link EventSchemas} for more information.
 *
 * @example
 *
 * ```ts
 * export const inngest = new Inngest({
 *   id: "my-app",
 *   schemas: new EventSchemas().fromZod({
 *     "app/user.created": {
 *       data: z.object({
 *         id: z.string(),
 *         name: z.string(),
 *       }),
 *     },
 *   }),
 * });
 * ```
 *
 * @public
 */ class EventSchemas {
    constructor(){
        this.runtimeSchemas = {};
    }
    addRuntimeSchemas(schemas) {
        this.runtimeSchemas = Object.assign(Object.assign({}, this.runtimeSchemas), schemas);
    }
    /**
     * Use generated Inngest types to type events.
     */ fromGenerated() {
        return this;
    }
    /**
     * Use a `Record<>` type to type events.
     *
     * @example
     *
     * ```ts
     * export const inngest = new Inngest({
     *   id: "my-app",
     *   schemas: new EventSchemas().fromRecord<{
     *     "app/user.created": {
     *       data: {
     *         id: string;
     *         name: string;
     *       };
     *     };
     *   }>(),
     * });
     * ```
     */ fromRecord(..._args) {
        return this;
    }
    /**
     * Use a union type to type events.
     *
     * @example
     *
     * ```ts
     * type AccountCreated = {
     *   name: "app/account.created";
     *   data: { org: string };
     *   user: { id: string };
     * };
     *
     * type AccountDeleted = {
     *   name: "app/account.deleted";
     *   data: { org: string };
     *   user: { id: string };
     * };
     *
     * type Events = AccountCreated | AccountDeleted;
     *
     * export const inngest = new Inngest({
     *   id: "my-app",
     *   schemas: new EventSchemas().fromUnion<Events>(),
     * });
     * ```
     */ fromUnion() {
        return this;
    }
    /**
     * Use Zod to type events.
     *
     * @example
     *
     * ```ts
     * export const inngest = new Inngest({
     *   id: "my-app",
     *   schemas: new EventSchemas().fromZod({
     *     "app/user.created": {
     *       data: z.object({
     *         id: z.string(),
     *         name: z.string(),
     *       }),
     *     },
     *   }),
     * });
     * ```
     */ fromZod(schemas) {
        let runtimeSchemas;
        if (Array.isArray(schemas)) {
            runtimeSchemas = schemas.reduce((acc, schema)=>{
                const _a = schema.shape, { name: { value: name } } = _a, rest = __rest(_a, [
                    "name"
                ]);
                return Object.assign(Object.assign({}, acc), {
                    [name]: rest
                });
            }, {});
        } else {
            runtimeSchemas = schemas;
        }
        this.addRuntimeSchemas(runtimeSchemas);
        return this;
    }
}
exports.EventSchemas = EventSchemas; //# sourceMappingURL=EventSchemas.js.map
}}),
"[project]/node_modules/.pnpm/inngest@3.32.5_express@4.21.2_next@15.3.4_@opentelemetry+api@1.9.0_react-dom@19.2.0_rea_302ab31fd2a599b814fb517e8771719b/node_modules/inngest/helpers/consts.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.syncKind = exports.serverKind = exports.dummyEventKey = exports.debugPrefix = exports.logPrefix = exports.internalEvents = exports.defaultDevServerHost = exports.defaultInngestEventBaseUrl = exports.defaultInngestApiBaseUrl = exports.headerKeys = exports.envKeys = exports.probe = exports.queryKeys = void 0;
const chalk_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/.pnpm/chalk@4.1.2/node_modules/chalk/source/index.js [app-route] (ecmascript)"));
/**
 * Keys for accessing query parameters included in requests from Inngest to run
 * functions.
 *
 * Used internally to create handlers using `InngestCommHandler`, but can be
 * imported to be used if creating a custom handler outside of the package.
 *
 * @public
 */ var queryKeys;
(function(queryKeys) {
    queryKeys["DeployId"] = "deployId";
    queryKeys["FnId"] = "fnId";
    queryKeys["Probe"] = "probe";
    queryKeys["StepId"] = "stepId";
})(queryKeys || (exports.queryKeys = queryKeys = {}));
var probe;
(function(probe) {
    probe["Trust"] = "trust";
})(probe || (exports.probe = probe = {}));
var envKeys;
(function(envKeys) {
    envKeys["InngestSigningKey"] = "INNGEST_SIGNING_KEY";
    envKeys["InngestSigningKeyFallback"] = "INNGEST_SIGNING_KEY_FALLBACK";
    envKeys["InngestEventKey"] = "INNGEST_EVENT_KEY";
    /**
     * @deprecated Removed in v3. Use {@link InngestBaseUrl} instead.
     */ envKeys["InngestDevServerUrl"] = "INNGEST_DEVSERVER_URL";
    envKeys["InngestEnvironment"] = "INNGEST_ENV";
    envKeys["InngestBaseUrl"] = "INNGEST_BASE_URL";
    envKeys["InngestEventApiBaseUrl"] = "INNGEST_EVENT_API_BASE_URL";
    envKeys["InngestApiBaseUrl"] = "INNGEST_API_BASE_URL";
    envKeys["InngestServeHost"] = "INNGEST_SERVE_HOST";
    envKeys["InngestServePath"] = "INNGEST_SERVE_PATH";
    envKeys["InngestLogLevel"] = "INNGEST_LOG_LEVEL";
    envKeys["InngestStreaming"] = "INNGEST_STREAMING";
    envKeys["InngestDevMode"] = "INNGEST_DEV";
    envKeys["InngestAllowInBandSync"] = "INNGEST_ALLOW_IN_BAND_SYNC";
    /**
     * @deprecated It's unknown what this env var was used for, but we do not
     * provide explicit support for it. Prefer using `INNGEST_ENV` instead.
     */ envKeys["BranchName"] = "BRANCH_NAME";
    /**
     * The git branch of the commit the deployment was triggered by. Example:
     * `improve-about-page`.
     *
     * {@link https://vercel.com/docs/concepts/projects/environment-variables/system-environment-variables#system-environment-variables}
     */ envKeys["VercelBranch"] = "VERCEL_GIT_COMMIT_REF";
    /**
     * Expected to be `"1"` if defined.
     */ envKeys["IsVercel"] = "VERCEL";
    /**
     * The branch name of the current deployment. May only be accessible at build
     * time, but included here just in case.
     *
     * {@link https://developers.cloudflare.com/pages/platform/build-configuration/#environment-variables}
     */ envKeys["CloudflarePagesBranch"] = "CF_PAGES_BRANCH";
    /**
     * Expected to be `"1"` if defined.
     */ envKeys["IsCloudflarePages"] = "CF_PAGES";
    /**
     * The branch name of the deployment from Git to Netlify, if available.
     *
     * {@link https://docs.netlify.com/configure-builds/environment-variables/#git-metadata}
     */ envKeys["NetlifyBranch"] = "BRANCH";
    /**
     * Expected to be `"true"` if defined.
     */ envKeys["IsNetlify"] = "NETLIFY";
    /**
     * The Git branch for a service or deploy.
     *
     * {@link https://render.com/docs/environment-variables#all-services}
     */ envKeys["RenderBranch"] = "RENDER_GIT_BRANCH";
    /**
     * Expected to be `"true"` if defined.
     */ envKeys["IsRender"] = "RENDER";
    /**
     * The branch that triggered the deployment. Example: `main`
     *
     * {@link https://docs.railway.app/develop/variables#railway-provided-variables}
     */ envKeys["RailwayBranch"] = "RAILWAY_GIT_BRANCH";
    /**
     * The railway environment for the deployment. Example: `production`
     *
     * {@link https://docs.railway.app/develop/variables#railway-provided-variables}
     */ envKeys["RailwayEnvironment"] = "RAILWAY_ENVIRONMENT";
    envKeys["VercelEnvKey"] = "VERCEL_ENV";
    envKeys["OpenAiApiKey"] = "OPENAI_API_KEY";
    envKeys["GeminiApiKey"] = "GEMINI_API_KEY";
    envKeys["AnthropicApiKey"] = "ANTHROPIC_API_KEY";
})(envKeys || (exports.envKeys = envKeys = {}));
/**
 * Keys for accessing headers included in requests from Inngest to run
 * functions.
 *
 * Used internally to create handlers using `InngestCommHandler`, but can be
 * imported to be used if creating a custom handler outside of the package.
 *
 * @public
 */ var headerKeys;
(function(headerKeys) {
    headerKeys["ContentLength"] = "content-length";
    headerKeys["Signature"] = "x-inngest-signature";
    headerKeys["SdkVersion"] = "x-inngest-sdk";
    headerKeys["Environment"] = "x-inngest-env";
    headerKeys["Platform"] = "x-inngest-platform";
    headerKeys["Framework"] = "x-inngest-framework";
    headerKeys["NoRetry"] = "x-inngest-no-retry";
    headerKeys["RequestVersion"] = "x-inngest-req-version";
    headerKeys["RetryAfter"] = "retry-after";
    headerKeys["InngestServerKind"] = "x-inngest-server-kind";
    headerKeys["InngestExpectedServerKind"] = "x-inngest-expected-server-kind";
    headerKeys["InngestSyncKind"] = "x-inngest-sync-kind";
    headerKeys["TraceParent"] = "traceparent";
    headerKeys["TraceState"] = "tracestate";
})(headerKeys || (exports.headerKeys = headerKeys = {}));
exports.defaultInngestApiBaseUrl = "https://api.inngest.com/";
exports.defaultInngestEventBaseUrl = "https://inn.gs/";
exports.defaultDevServerHost = "http://127.0.0.1:8288/";
/**
 * Events that Inngest may send internally that can be used to trigger
 * functions.
 *
 * @public
 */ var internalEvents;
(function(internalEvents) {
    /**
     * A function has failed after exhausting all available retries. This event
     * will contain the original event and the error that caused the failure.
     */ internalEvents["FunctionFailed"] = "inngest/function.failed";
    internalEvents["FunctionInvoked"] = "inngest/function.invoked";
    internalEvents["FunctionFinished"] = "inngest/function.finished";
    internalEvents["ScheduledTimer"] = "inngest/scheduled.timer";
})(internalEvents || (exports.internalEvents = internalEvents = {}));
exports.logPrefix = chalk_1.default.magenta.bold("[Inngest]");
exports.debugPrefix = "inngest";
exports.dummyEventKey = "NO_EVENT_KEY_SET";
var serverKind;
(function(serverKind) {
    serverKind["Dev"] = "dev";
    serverKind["Cloud"] = "cloud";
})(serverKind || (exports.serverKind = serverKind = {}));
var syncKind;
(function(syncKind) {
    syncKind["InBand"] = "in_band";
    syncKind["OutOfBand"] = "out_of_band";
})(syncKind || (exports.syncKind = syncKind = {})); //# sourceMappingURL=consts.js.map
}}),
"[project]/node_modules/.pnpm/inngest@3.32.5_express@4.21.2_next@15.3.4_@opentelemetry+api@1.9.0_react-dom@19.2.0_rea_302ab31fd2a599b814fb517e8771719b/node_modules/inngest/helpers/devserver.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.devServerUrl = exports.devServerAvailable = void 0;
const consts_js_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/inngest@3.32.5_express@4.21.2_next@15.3.4_@opentelemetry+api@1.9.0_react-dom@19.2.0_rea_302ab31fd2a599b814fb517e8771719b/node_modules/inngest/helpers/consts.js [app-route] (ecmascript)");
/**
 * Attempts to contact the dev server, returning a boolean indicating whether or
 * not it was successful.
 *
 * @example devServerUrl(process.env[envKeys.DevServerUrl], "/your-path")
 */ const devServerAvailable = async (/**
 * The host of the dev server. You should pass in an environment variable as
 * this parameter.
 */ host = consts_js_1.defaultDevServerHost, /**
 * The fetch implementation to use to communicate with the dev server.
 */ fetch)=>{
    try {
        const url = (0, exports.devServerUrl)(host, "/dev");
        const result = await fetch(url.toString());
        await result.json();
        return true;
    } catch (e) {
        return false;
    }
};
exports.devServerAvailable = devServerAvailable;
/**
 * devServerUrl returns a full URL for the given path name.
 *
 * Because Cloudflare/V8 platforms don't allow process.env, you are expected
 * to pass in the host from the dev server env key:
 *
 * @example devServerUrl(processEnv(envKeys.DevServerUrl), "/your-path")
 * @example devServerUrl("http://localhost:8288/", "/your-path")
 */ const devServerUrl = (host = consts_js_1.defaultDevServerHost, pathname = "")=>{
    return new URL(pathname, host.includes("://") ? host : `http://${host}`);
};
exports.devServerUrl = devServerUrl; //# sourceMappingURL=devserver.js.map
}}),
"[project]/node_modules/.pnpm/inngest@3.32.5_express@4.21.2_next@15.3.4_@opentelemetry+api@1.9.0_react-dom@19.2.0_rea_302ab31fd2a599b814fb517e8771719b/node_modules/inngest/components/NonRetriableError.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.NonRetriableError = void 0;
/**
 * An error that, when thrown, indicates to Inngest that the function should
 * cease all execution and not retry.
 *
 * A `message` must be provided, and an optional `cause` can be provided to
 * provide more context to the error.
 *
 * @public
 */ class NonRetriableError extends Error {
    constructor(message, options){
        super(message);
        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
        this.cause = options === null || options === void 0 ? void 0 : options.cause;
        this.name = "NonRetriableError";
    }
}
exports.NonRetriableError = NonRetriableError; //# sourceMappingURL=NonRetriableError.js.map
}}),
"[project]/node_modules/.pnpm/inngest@3.32.5_express@4.21.2_next@15.3.4_@opentelemetry+api@1.9.0_react-dom@19.2.0_rea_302ab31fd2a599b814fb517e8771719b/node_modules/inngest/helpers/errors.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.functionStoppedRunningErr = exports.rethrowError = exports.OutgoingResultError = exports.fixEventKeyMissingSteps = exports.prettyError = exports.getErrorMessage = exports.minifyPrettyError = exports.prettyErrorSplitter = exports.ErrCode = exports.deserializeError = exports.isSerializedError = exports.serializeError = void 0;
const chalk_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/.pnpm/chalk@4.1.2/node_modules/chalk/source/index.js [app-route] (ecmascript)"));
const json_stringify_safe_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/.pnpm/json-stringify-safe@5.0.1/node_modules/json-stringify-safe/stringify.js [app-route] (ecmascript)"));
const serialize_error_cjs_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/serialize-error-cjs@0.1.4/node_modules/serialize-error-cjs/dist/index.js [app-route] (ecmascript)");
const strip_ansi_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/.pnpm/strip-ansi@5.2.0/node_modules/strip-ansi/index.js [app-route] (ecmascript)"));
const zod_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/zod@3.22.5/node_modules/zod/lib/index.js [app-route] (ecmascript)");
const NonRetriableError_js_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/inngest@3.32.5_express@4.21.2_next@15.3.4_@opentelemetry+api@1.9.0_react-dom@19.2.0_rea_302ab31fd2a599b814fb517e8771719b/node_modules/inngest/components/NonRetriableError.js [app-route] (ecmascript)");
const SERIALIZED_KEY = "__serialized";
const SERIALIZED_VALUE = true;
/**
 * Add first-class support for certain errors that we control, in addition to
 * built-in errors such as `TypeError`.
 *
 * Adding these allows these non-standard errors to be correctly serialized,
 * sent to Inngest, then deserialized back into the correct error type for users
 * to react to correctly.
 *
 * Note that these errors only support `message?: string | undefined` as the
 * input; more custom errors are not supported with this current strategy.
 */ serialize_error_cjs_1.errorConstructors.set("NonRetriableError", NonRetriableError_js_1.NonRetriableError);
/**
 * Serialise an error to a serialized JSON string.
 *
 * Errors do not serialise nicely to JSON, so we use this function to convert
 * them to a serialized JSON string. Doing this is also non-trivial for some
 * errors, so we use the `serialize-error` package to do it for us.
 *
 * See {@link https://www.npmjs.com/package/serialize-error}
 *
 * This function is a small wrapper around that package to also add a `type`
 * property to the serialised error, so that we can distinguish between
 * serialised errors and other objects.
 *
 * Will not reserialise existing serialised errors.
 */ const serializeError = (subject)=>{
    try {
        // Try to understand if this is already done.
        // Will handle stringified errors.
        const existingSerializedError = (0, exports.isSerializedError)(subject);
        if (existingSerializedError) {
            return existingSerializedError;
        }
        if (typeof subject === "object" && subject !== null) {
            // Is an object, so let's try and serialize it.
            const serializedErr = (0, serialize_error_cjs_1.serializeError)(subject);
            // Serialization can succeed but assign no name or message, so we'll
            // map over the result here to ensure we have everything.
            // We'll just stringify the entire subject for the message, as this at
            // least provides some context for the user.
            const ret = Object.assign(Object.assign({}, serializedErr), {
                name: serializedErr.name || "Error",
                message: serializedErr.message || (0, json_stringify_safe_1.default)(subject) || "Unknown error; error serialization could not find a message.",
                stack: serializedErr.stack || "",
                [SERIALIZED_KEY]: SERIALIZED_VALUE
            });
            // If we have a cause, make sure we recursively serialize them too.
            let target = ret;
            const maxDepth = 5;
            for(let i = 0; i < maxDepth; i++){
                if (typeof target === "object" && target !== null && "cause" in target && target.cause) {
                    target = target.cause = (0, exports.serializeError)(target.cause);
                    continue;
                }
                break;
            }
            return ret;
        }
        // If it's not an object, it's hard to parse this as an Error. In this case,
        // we'll throw an error to start attempting backup strategies.
        throw new Error("Error is not an object; strange throw value.");
    } catch (err) {
        try {
            // If serialization fails, fall back to a regular Error and use the
            // original object as the message for an Error. We don't know what this
            // object looks like, so we can't do anything else with it.
            return Object.assign(Object.assign({}, (0, exports.serializeError)(new Error(typeof subject === "string" ? subject : (0, json_stringify_safe_1.default)(subject)))), {
                // Remove the stack; it's not relevant here
                stack: "",
                [SERIALIZED_KEY]: SERIALIZED_VALUE
            });
        } catch (err) {
            // If this failed, then stringifying the object also failed, so we'll just
            // return a completely generic error.
            // Failing to stringify the object is very unlikely.
            return {
                name: "Could not serialize source error",
                message: "Serializing the source error failed.",
                stack: "",
                [SERIALIZED_KEY]: SERIALIZED_VALUE
            };
        }
    }
};
exports.serializeError = serializeError;
/**
 * Check if an object or a string is a serialised error created by
 * {@link serializeError}.
 */ const isSerializedError = (value)=>{
    try {
        if (typeof value === "string") {
            const parsed = zod_1.z.object({
                [SERIALIZED_KEY]: zod_1.z.literal(SERIALIZED_VALUE),
                name: zod_1.z.enum([
                    ...Array.from(serialize_error_cjs_1.errorConstructors.keys())
                ]),
                message: zod_1.z.string(),
                stack: zod_1.z.string()
            }).passthrough().safeParse(JSON.parse(value));
            if (parsed.success) {
                return parsed.data;
            }
        }
        if (typeof value === "object" && value !== null) {
            const objIsSerializedErr = Object.prototype.hasOwnProperty.call(value, SERIALIZED_KEY) && // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
            value[SERIALIZED_KEY] === SERIALIZED_VALUE;
            if (objIsSerializedErr) {
                return value;
            }
        }
    } catch (_a) {
    // no-op; we'll return undefined if parsing failed, as it isn't a serialized
    // error
    }
};
exports.isSerializedError = isSerializedError;
/**
 * Deserialise an error created by {@link serializeError}.
 *
 * Ensures we only deserialise errors that meet a minimum level of
 * applicability, inclusive of error handling to ensure that badly serialized
 * errors are still handled.
 */ const deserializeError = (subject)=>{
    const requiredFields = [
        "name",
        "message"
    ];
    try {
        const hasRequiredFields = requiredFields.every((field)=>{
            return Object.prototype.hasOwnProperty.call(subject, field);
        });
        if (!hasRequiredFields) {
            throw new Error();
        }
        const deserializedErr = (0, serialize_error_cjs_1.deserializeError)(subject);
        if ("cause" in deserializedErr) {
            deserializedErr.cause = (0, exports.deserializeError)(deserializedErr.cause);
        }
        return deserializedErr;
    } catch (_a) {
        const err = new Error("Unknown error; could not reserialize");
        /**
         * Remove the stack so that it's not misleadingly shown as the Inngest
         * internals.
         */ err.stack = undefined;
        return err;
    }
};
exports.deserializeError = deserializeError;
var ErrCode;
(function(ErrCode) {
    ErrCode["NESTING_STEPS"] = "NESTING_STEPS";
    /**
     * Legacy v0 execution error code for when a function has changed and no
     * longer matches its in-progress state.
     *
     * @deprecated Not for use in latest execution method.
     */ ErrCode["NON_DETERMINISTIC_FUNCTION"] = "NON_DETERMINISTIC_FUNCTION";
    /**
     * Legacy v0 execution error code for when a function is found to be using
     * async actions after memoziation has occurred, which v0 doesn't support.
     *
     * @deprecated Not for use in latest execution method.
     */ ErrCode["ASYNC_DETECTED_AFTER_MEMOIZATION"] = "ASYNC_DETECTED_AFTER_MEMOIZATION";
    /**
     * Legacy v0 execution error code for when a function is found to be using
     * steps after a non-step async action has occurred.
     *
     * @deprecated Not for use in latest execution method.
     */ ErrCode["STEP_USED_AFTER_ASYNC"] = "STEP_USED_AFTER_ASYNC";
    ErrCode["AUTOMATIC_PARALLEL_INDEXING"] = "AUTOMATIC_PARALLEL_INDEXING";
})(ErrCode || (exports.ErrCode = ErrCode = {}));
exports.prettyErrorSplitter = "=================================================";
/**
 * Given an unknown `err`, mutate it to minify any pretty errors that it
 * contains.
 */ const minifyPrettyError = (err)=>{
    var _a, _b, _c, _d;
    try {
        if (!isError(err)) {
            return err;
        }
        const isPrettyError = err.message.includes(exports.prettyErrorSplitter);
        if (!isPrettyError) {
            return err;
        }
        const sanitizedMessage = (0, strip_ansi_1.default)(err.message);
        const message = ((_b = (_a = sanitizedMessage.split("  ")[1]) === null || _a === void 0 ? void 0 : _a.split("\n")[0]) === null || _b === void 0 ? void 0 : _b.trim()) || err.message;
        const code = ((_d = (_c = sanitizedMessage.split("\n\nCode: ")[1]) === null || _c === void 0 ? void 0 : _c.split("\n\n")[0]) === null || _d === void 0 ? void 0 : _d.trim()) || undefined;
        err.message = [
            code,
            message
        ].filter(Boolean).join(" - ");
        if (err.stack) {
            const sanitizedStack = (0, strip_ansi_1.default)(err.stack);
            const stackRest = sanitizedStack.split(`${exports.prettyErrorSplitter}\n`).slice(2).join("\n");
            err.stack = `${err.name}: ${err.message}\n${stackRest}`;
        }
        return err;
    } catch (noopErr) {
        return err;
    }
};
exports.minifyPrettyError = minifyPrettyError;
/**
 * Given an `err`, return a boolean representing whether it is in the shape of
 * an `Error` or not.
 */ const isError = (err)=>{
    try {
        if (err instanceof Error) {
            return true;
        }
        const hasName = Object.prototype.hasOwnProperty.call(err, "name");
        const hasMessage = Object.prototype.hasOwnProperty.call(err, "message");
        return hasName && hasMessage;
    } catch (noopErr) {
        return false;
    }
};
/**
 * Given an `unknown` object, retrieve the `message` property from it, or fall
 * back to the `fallback` string if it doesn't exist or is empty.
 */ const getErrorMessage = (err, fallback)=>{
    const { message } = zod_1.z.object({
        message: zod_1.z.string().min(1)
    }).catch({
        message: fallback
    }).parse(err);
    return message;
};
exports.getErrorMessage = getErrorMessage;
/**
 * Given a {@link PrettyError}, return a nicely-formatted string ready to log
 * or throw.
 *
 * Useful for ensuring that errors are logged in a consistent, helpful format
 * across the SDK by prompting for key pieces of information.
 */ const prettyError = ({ type = "error", whatHappened, otherwise, reassurance, toFixNow, why, consequences, stack, code })=>{
    var _a, _b;
    const { icon, colorFn } = {
        error: {
            icon: "",
            colorFn: chalk_1.default.red
        },
        warn: {
            icon: "",
            colorFn: chalk_1.default.yellow
        }
    }[type];
    let header = `${icon}  ${chalk_1.default.bold.underline(whatHappened.trim())}`;
    if (stack) {
        header += "\n" + [
            ...((_a = new Error().stack) === null || _a === void 0 ? void 0 : _a.split("\n").slice(1).filter(Boolean)) || []
        ].join("\n");
    }
    let toFixNowStr = (_b = Array.isArray(toFixNow) ? toFixNow.map((s)=>s.trim()).filter(Boolean).map((s, i)=>`\t${i + 1}. ${s}`).join("\n") : toFixNow === null || toFixNow === void 0 ? void 0 : toFixNow.trim()) !== null && _b !== void 0 ? _b : "";
    if (Array.isArray(toFixNow) && toFixNowStr) {
        toFixNowStr = `To fix this, you can take one of the following courses of action:\n\n${toFixNowStr}`;
    }
    let body = [
        reassurance === null || reassurance === void 0 ? void 0 : reassurance.trim(),
        why === null || why === void 0 ? void 0 : why.trim(),
        consequences === null || consequences === void 0 ? void 0 : consequences.trim()
    ].filter(Boolean).join(" ");
    body += body ? `\n\n${toFixNowStr}` : toFixNowStr;
    const trailer = [
        otherwise === null || otherwise === void 0 ? void 0 : otherwise.trim()
    ].filter(Boolean).join(" ");
    const message = [
        exports.prettyErrorSplitter,
        header,
        body,
        trailer,
        code ? `Code: ${code}` : "",
        exports.prettyErrorSplitter
    ].filter(Boolean).join("\n\n");
    return colorFn(message);
};
exports.prettyError = prettyError;
exports.fixEventKeyMissingSteps = [
    "Set the `INNGEST_EVENT_KEY` environment variable",
    `Pass a key to the \`new Inngest()\` constructor using the \`${"eventKey"}\` option`,
    `Use \`inngest.${"setEventKey"}()\` at runtime`
];
/**
 * An error that, when thrown, indicates internally that an outgoing operation
 * contains an error.
 *
 * We use this because serialized `data` sent back to Inngest may differ from
 * the error instance itself due to middleware.
 *
 * @internal
 */ class OutgoingResultError extends Error {
    constructor(result){
        super("OutgoingOpError");
        this.result = result;
    }
}
exports.OutgoingResultError = OutgoingResultError;
/**
 * Create a function that will rethrow an error with a prefix added to the
 * message.
 *
 * Useful for adding context to errors that are rethrown.
 *
 * @example
 * ```ts
 * await doSomeAction().catch(rethrowError("Failed to do some action"));
 * ```
 */ // eslint-disable-next-line @typescript-eslint/no-explicit-any
const rethrowError = (prefix)=>{
    return (err)=>{
        try {
            // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/restrict-template-expressions
            err.message && (err.message = `${prefix}; ${err.message}`);
        } catch (noopErr) {
        // no-op
        } finally{
            // eslint-disable-next-line no-unsafe-finally
            throw err;
        }
    };
};
exports.rethrowError = rethrowError;
/**
 * Legacy v0 execution error for functions that don't support mixing steps and
 * regular async actions.
 */ const functionStoppedRunningErr = (code)=>{
    return (0, exports.prettyError)({
        whatHappened: "Your function was stopped from running",
        why: "We detected a mix of asynchronous logic, some using step tooling and some not.",
        consequences: "This can cause unexpected behaviour when a function is paused and resumed and is therefore strongly discouraged; we stopped your function to ensure nothing unexpected happened!",
        stack: true,
        toFixNow: "Ensure that your function is either entirely step-based or entirely non-step-based, by either wrapping all asynchronous logic in `step.run()` calls or by removing all `step.*()` calls.",
        otherwise: "For more information on why step functions work in this manner, see https://www.inngest.com/docs/functions/multi-step#gotchas",
        code
    });
};
exports.functionStoppedRunningErr = functionStoppedRunningErr; //# sourceMappingURL=errors.js.map
}}),
"[project]/node_modules/.pnpm/inngest@3.32.5_express@4.21.2_next@15.3.4_@opentelemetry+api@1.9.0_react-dom@19.2.0_rea_302ab31fd2a599b814fb517e8771719b/node_modules/inngest/helpers/net.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.fetchWithAuthFallback = fetchWithAuthFallback;
exports.signDataWithKey = signDataWithKey;
const canonicalize_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/.pnpm/canonicalize@1.0.8/node_modules/canonicalize/lib/canonicalize.js [app-route] (ecmascript)"));
const hash_js_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash.js [app-route] (ecmascript)");
/**
 * Send an HTTP request with the given signing key. If the response is a 401 or
 * 403, then try again with the fallback signing key
 */ async function fetchWithAuthFallback({ authToken, authTokenFallback, fetch, options, url }) {
    let res = await fetch(url, Object.assign(Object.assign({}, options), {
        headers: Object.assign(Object.assign({}, options === null || options === void 0 ? void 0 : options.headers), {
            Authorization: `Bearer ${authToken}`
        })
    }));
    if ([
        401,
        403
    ].includes(res.status) && authTokenFallback) {
        res = await fetch(url, Object.assign(Object.assign({}, options), {
            headers: Object.assign(Object.assign({}, options === null || options === void 0 ? void 0 : options.headers), {
                Authorization: `Bearer ${authTokenFallback}`
            })
        }));
    }
    return res;
}
function signDataWithKey(data, signingKey, ts) {
    // Calculate the HMAC of the request body ourselves.
    // We make the assumption here that a stringified body is the same as the
    // raw bytes; it may be pertinent in the future to always parse, then
    // canonicalize the body to ensure it's consistent.
    const encoded = typeof data === "string" ? data : (0, canonicalize_1.default)(data);
    // Remove the `/signkey-[test|prod]-/` prefix from our signing key to calculate the HMAC.
    const key = signingKey.replace(/signkey-\w+-/, "");
    // eslint-disable-next-line @typescript-eslint/no-unsafe-argument, @typescript-eslint/no-explicit-any
    const mac = (0, hash_js_1.hmac)(hash_js_1.sha256, key).update(encoded).update(ts).digest("hex");
    return mac;
} //# sourceMappingURL=net.js.map
}}),
"[project]/node_modules/.pnpm/inngest@3.32.5_express@4.21.2_next@15.3.4_@opentelemetry+api@1.9.0_react-dom@19.2.0_rea_302ab31fd2a599b814fb517e8771719b/node_modules/inngest/helpers/strings.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.hashSigningKey = exports.hashEventKey = exports.stringifyUnknown = exports.timeStr = exports.slugify = exports.stringify = void 0;
const hash_js_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash.js [app-route] (ecmascript)");
const json_stringify_safe_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/.pnpm/json-stringify-safe@5.0.1/node_modules/json-stringify-safe/stringify.js [app-route] (ecmascript)"));
const ms_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/.pnpm/ms@2.1.3/node_modules/ms/index.js [app-route] (ecmascript)"));
/**
 * Safely `JSON.stringify()` an `input`, handling circular refernences and
 * removing `BigInt` values.
 */ // eslint-disable-next-line @typescript-eslint/no-explicit-any
const stringify = (input)=>{
    return (0, json_stringify_safe_1.default)(input, (key, value)=>{
        if (typeof value !== "bigint") {
            // eslint-disable-next-line @typescript-eslint/no-unsafe-return
            return value;
        }
    });
};
exports.stringify = stringify;
/**
 * Returns a slugified string used to generate consistent IDs.
 *
 * This can be used to generate a consistent ID for a function when migrating
 * from v2 to v3 of the SDK.
 *
 * @public
 */ const slugify = (str)=>{
    const join = "-";
    return str.toLowerCase().replace(/[^a-z0-9-]+/g, join).replace(/-+/g, join).split(join).filter(Boolean).join(join);
};
exports.slugify = slugify;
const millisecond = 1;
const second = millisecond * 1000;
const minute = second * 60;
const hour = minute * 60;
const day = hour * 24;
const week = day * 7;
/**
 * A collection of periods in milliseconds and their suffixes used when creating
 * time strings.
 */ const periods = [
    [
        "w",
        week
    ],
    [
        "d",
        day
    ],
    [
        "h",
        hour
    ],
    [
        "m",
        minute
    ],
    [
        "s",
        second
    ]
];
/**
 * Convert a given `Date`, `number`, or `ms`-compatible `string` to a
 * Inngest sleep-compatible time string (e.g. `"1d"` or `"2h3010s"`).
 *
 * Can optionally provide a `now` date to use as the base for the calculation,
 * otherwise a new date will be created on invocation.
 */ const timeStr = (/**
 * The future date to use to convert to a time string.
 */ input)=>{
    if (input instanceof Date) {
        return input.toISOString();
    }
    const milliseconds = typeof input === "string" ? (0, ms_1.default)(input) : input;
    const [, timeStr] = periods.reduce(([num, str], [suffix, period])=>{
        const numPeriods = Math.floor(num / period);
        if (numPeriods > 0) {
            return [
                num % period,
                `${str}${numPeriods}${suffix}`
            ];
        }
        return [
            num,
            str
        ];
    }, [
        milliseconds,
        ""
    ]);
    return timeStr;
};
exports.timeStr = timeStr;
/**
 * Given an unknown input, stringify it if it's a boolean, a number, or a
 * string, else return `undefined`.
 */ const stringifyUnknown = (input)=>{
    if (typeof input === "boolean" || typeof input === "number" || typeof input === "string") {
        return input.toString();
    }
};
exports.stringifyUnknown = stringifyUnknown;
const hashEventKey = (eventKey)=>{
    return (0, hash_js_1.sha256)().update(eventKey).digest("hex");
};
exports.hashEventKey = hashEventKey;
const hashSigningKey = (signingKey)=>{
    var _a;
    if (!signingKey) {
        return "";
    }
    const prefix = ((_a = signingKey.match(/^signkey-[\w]+-/)) === null || _a === void 0 ? void 0 : _a.shift()) || "";
    const key = signingKey.replace(/^signkey-[\w]+-/, "");
    // Decode the key from its hex representation into a bytestream
    return `${prefix}${(0, hash_js_1.sha256)().update(key, "hex").digest("hex")}`;
};
exports.hashSigningKey = hashSigningKey; //# sourceMappingURL=strings.js.map
}}),
"[project]/node_modules/.pnpm/inngest@3.32.5_express@4.21.2_next@15.3.4_@opentelemetry+api@1.9.0_react-dom@19.2.0_rea_302ab31fd2a599b814fb517e8771719b/node_modules/inngest/types.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/**
 * Internal types and schemas used throughout the Inngest SDK.
 *
 * Note that types intended to be imported and utilized in userland code will be
 * exported from the main entrypoint of the SDK, `inngest`; importing types
 * directly from this file may result in breaking changes in non-major bumps as
 * only those exported from `inngest` are considered stable.
 *
 * @module
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.inBandSyncRequestBodySchema = exports.err = exports.ok = exports.functionConfigSchema = exports.logLevels = exports.sendEventResponseSchema = exports.incomingOpSchema = exports.StepOpCode = exports.jsonErrorSchema = void 0;
const zod_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/zod@3.22.5/node_modules/zod/lib/index.js [app-route] (ecmascript)");
const baseJsonErrorSchema = zod_1.z.object({
    name: zod_1.z.string().trim().optional(),
    error: zod_1.z.string().trim().optional(),
    message: zod_1.z.string().trim().optional(),
    stack: zod_1.z.string().trim().optional()
});
exports.jsonErrorSchema = baseJsonErrorSchema.extend({
    cause: zod_1.z.lazy(()=>exports.jsonErrorSchema).optional()
}).passthrough().catch({}).transform((val)=>{
    return Object.assign(Object.assign({}, val), {
        name: val.name || "Error",
        message: val.message || val.error || "Unknown error",
        stack: val.stack
    });
});
/**
 * Unique codes for the different types of operation that can be sent to Inngest
 * from SDK step functions.
 */ var StepOpCode;
(function(StepOpCode) {
    StepOpCode["WaitForEvent"] = "WaitForEvent";
    /**
     * Legacy equivalent to `"StepRun"`. Has mixed data wrapping (e.g. `data` or
     * `data.data` depending on SDK version), so this is phased out in favour of
     * `"StepRun"`, which never wraps.
     *
     * Note that it is still used for v0 executions for backwards compatibility.
     *
     * @deprecated Only used for v0 executions; use `"StepRun"` instead.
     */ StepOpCode["Step"] = "Step";
    StepOpCode["StepRun"] = "StepRun";
    StepOpCode["StepError"] = "StepError";
    StepOpCode["StepPlanned"] = "StepPlanned";
    StepOpCode["Sleep"] = "Sleep";
    /**
     * Used to signify that the executor has requested that a step run, but we
     * could not find that step.
     *
     * This is likely indicative that a step was renamed or removed from the
     * function.
     */ StepOpCode["StepNotFound"] = "StepNotFound";
    StepOpCode["InvokeFunction"] = "InvokeFunction";
    StepOpCode["AiGateway"] = "AIGateway";
})(StepOpCode || (exports.StepOpCode = StepOpCode = {}));
exports.incomingOpSchema = zod_1.z.object({
    id: zod_1.z.string().min(1),
    data: zod_1.z.any().optional(),
    error: zod_1.z.any().optional(),
    input: zod_1.z.any().optional()
});
exports.sendEventResponseSchema = zod_1.z.object({
    /**
     * Event IDs
     */ ids: zod_1.z.array(zod_1.z.string()).default([]),
    /**
     * HTTP Status Code. Will be undefined if no request was sent.
     */ status: zod_1.z.number().default(0),
    /**
     * Error message. Will be undefined if no error occurred.
     */ error: zod_1.z.string().optional()
});
/**
 * A set of log levels that can be used to control the amount of logging output
 * from various parts of the Inngest library.
 *
 * @public
 */ exports.logLevels = [
    "fatal",
    "error",
    "warn",
    "info",
    "debug",
    "silent"
];
/**
 * This schema is used internally to share the shape of a concurrency option
 * when validating config. We cannot add comments to Zod fields, so we just use
 * an extra type check to ensure it matches our exported expectations.
 */ const concurrencyOptionSchema = zod_1.z.strictObject({
    limit: zod_1.z.number(),
    key: zod_1.z.string().optional(),
    scope: zod_1.z.enum([
        "fn",
        "env",
        "account"
    ]).optional()
});
const _checkConcurrencySchemaAligns = true;
/**
 * The schema used to represent an individual function being synced with
 * Inngest.
 *
 * Note that this should only be used to validate the shape of a config object
 * and not used for feature compatibility, such as feature X being exclusive
 * with feature Y; these should be handled on the Inngest side.
 */ exports.functionConfigSchema = zod_1.z.strictObject({
    name: zod_1.z.string().optional(),
    id: zod_1.z.string(),
    triggers: zod_1.z.array(zod_1.z.union([
        zod_1.z.strictObject({
            event: zod_1.z.string(),
            expression: zod_1.z.string().optional()
        }),
        zod_1.z.strictObject({
            cron: zod_1.z.string()
        })
    ])),
    steps: zod_1.z.record(zod_1.z.strictObject({
        id: zod_1.z.string(),
        name: zod_1.z.string(),
        runtime: zod_1.z.strictObject({
            type: zod_1.z.union([
                zod_1.z.literal("http"),
                zod_1.z.literal("ws")
            ]),
            url: zod_1.z.string()
        }),
        retries: zod_1.z.strictObject({
            attempts: zod_1.z.number().optional()
        }).optional()
    })),
    idempotency: zod_1.z.string().optional(),
    batchEvents: zod_1.z.strictObject({
        maxSize: zod_1.z.number(),
        timeout: zod_1.z.string(),
        key: zod_1.z.string().optional()
    }).optional(),
    rateLimit: zod_1.z.strictObject({
        key: zod_1.z.string().optional(),
        limit: zod_1.z.number(),
        period: zod_1.z.string().transform((x)=>x)
    }).optional(),
    throttle: zod_1.z.strictObject({
        key: zod_1.z.string().optional(),
        limit: zod_1.z.number(),
        period: zod_1.z.string().transform((x)=>x),
        burst: zod_1.z.number().optional()
    }).optional(),
    cancel: zod_1.z.array(zod_1.z.strictObject({
        event: zod_1.z.string(),
        if: zod_1.z.string().optional(),
        timeout: zod_1.z.string().optional()
    })).optional(),
    debounce: zod_1.z.strictObject({
        key: zod_1.z.string().optional(),
        period: zod_1.z.string().transform((x)=>x),
        timeout: zod_1.z.string().transform((x)=>x).optional()
    }).optional(),
    timeouts: zod_1.z.strictObject({
        start: zod_1.z.string().transform((x)=>x).optional(),
        finish: zod_1.z.string().transform((x)=>x).optional()
    }).optional(),
    priority: zod_1.z.strictObject({
        run: zod_1.z.string().optional()
    }).optional(),
    concurrency: zod_1.z.union([
        zod_1.z.number(),
        concurrencyOptionSchema.transform((x)=>x),
        zod_1.z.array(concurrencyOptionSchema.transform((x)=>x)).min(1).max(2)
    ]).optional()
});
const ok = (data)=>{
    return {
        ok: true,
        value: data
    };
};
exports.ok = ok;
const err = (error)=>{
    return {
        ok: false,
        error
    };
};
exports.err = err;
exports.inBandSyncRequestBodySchema = zod_1.z.strictObject({
    url: zod_1.z.string()
}); //# sourceMappingURL=types.js.map
}}),
"[project]/node_modules/.pnpm/inngest@3.32.5_express@4.21.2_next@15.3.4_@opentelemetry+api@1.9.0_react-dom@19.2.0_rea_302ab31fd2a599b814fb517e8771719b/node_modules/inngest/components/execution/InngestExecution.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.InngestExecution = exports.PREFERRED_EXECUTION_VERSION = exports.ExecutionVersion = void 0;
const debug_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/.pnpm/debug@4.4.3/node_modules/debug/src/index.js [app-route] (ecmascript)"));
const consts_js_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/inngest@3.32.5_express@4.21.2_next@15.3.4_@opentelemetry+api@1.9.0_react-dom@19.2.0_rea_302ab31fd2a599b814fb517e8771719b/node_modules/inngest/helpers/consts.js [app-route] (ecmascript)");
/**
 * The execution models the SDK is aware of.
 *
 * This is used in a number of places to ensure all execution versions are
 * accounted for for a given operation.
 */ var ExecutionVersion;
(function(ExecutionVersion) {
    ExecutionVersion[ExecutionVersion["V0"] = 0] = "V0";
    ExecutionVersion[ExecutionVersion["V1"] = 1] = "V1";
    ExecutionVersion[ExecutionVersion["V2"] = 2] = "V2";
})(ExecutionVersion || (exports.ExecutionVersion = ExecutionVersion = {}));
/**
 * The preferred execution version that will be used by the SDK when handling
 * brand new runs where the Executor is allowing us to choose.
 *
 * Changing this should not ever be a breaking change, as this will only change
 * new runs, not existing ones.
 */ exports.PREFERRED_EXECUTION_VERSION = ExecutionVersion.V1;
class InngestExecution {
    constructor(options){
        this.options = options;
        this.debug = (0, debug_1.default)(`${consts_js_1.debugPrefix}:${this.options.runId}`);
    }
}
exports.InngestExecution = InngestExecution; //# sourceMappingURL=InngestExecution.js.map
}}),
"[project]/node_modules/.pnpm/inngest@3.32.5_express@4.21.2_next@15.3.4_@opentelemetry+api@1.9.0_react-dom@19.2.0_rea_302ab31fd2a599b814fb517e8771719b/node_modules/inngest/api/schema.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.batchSchema = exports.stepsSchemas = exports.errorSchema = void 0;
const zod_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/zod@3.22.5/node_modules/zod/lib/index.js [app-route] (ecmascript)");
const InngestExecution_js_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/inngest@3.32.5_express@4.21.2_next@15.3.4_@opentelemetry+api@1.9.0_react-dom@19.2.0_rea_302ab31fd2a599b814fb517e8771719b/node_modules/inngest/components/execution/InngestExecution.js [app-route] (ecmascript)");
const types_js_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/inngest@3.32.5_express@4.21.2_next@15.3.4_@opentelemetry+api@1.9.0_react-dom@19.2.0_rea_302ab31fd2a599b814fb517e8771719b/node_modules/inngest/types.js [app-route] (ecmascript)");
exports.errorSchema = zod_1.z.object({
    error: zod_1.z.string(),
    status: zod_1.z.number()
});
const v0StepSchema = zod_1.z.record(zod_1.z.any().refine((v)=>typeof v !== "undefined", {
    message: "Values in steps must be defined"
})).optional().nullable();
const v1StepSchema = zod_1.z.record(zod_1.z.object({
    type: zod_1.z.literal("data").optional().default("data"),
    data: zod_1.z.any().refine((v)=>typeof v !== "undefined", {
        message: "Data in steps must be defined"
    })
}).strict().or(zod_1.z.object({
    type: zod_1.z.literal("error").optional().default("error"),
    error: types_js_1.jsonErrorSchema
}).strict()).or(zod_1.z.object({
    type: zod_1.z.literal("input").optional().default("input"),
    input: zod_1.z.any().refine((v)=>typeof v !== "undefined", {
        message: "If input is present it must not be `undefined`"
    })
}).strict())/**
     * If the result isn't a distcint `data` or `error` object, then it's
     * likely that the executor has set this directly to a value, for example
     * in the case of `sleep` or `waitForEvent`.
     *
     * In this case, pull the entire value through as data.
     */ // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
.or(zod_1.z.any().transform((v)=>({
        type: "data",
        data: v
    })))).default({});
const v2StepSchema = v1StepSchema;
exports.stepsSchemas = {
    [InngestExecution_js_1.ExecutionVersion.V0]: v0StepSchema,
    [InngestExecution_js_1.ExecutionVersion.V1]: v1StepSchema,
    [InngestExecution_js_1.ExecutionVersion.V2]: v2StepSchema
};
exports.batchSchema = zod_1.z.array(zod_1.z.record(zod_1.z.any()).transform((v)=>v)); //# sourceMappingURL=schema.js.map
}}),
"[project]/node_modules/.pnpm/inngest@3.32.5_express@4.21.2_next@15.3.4_@opentelemetry+api@1.9.0_react-dom@19.2.0_rea_302ab31fd2a599b814fb517e8771719b/node_modules/inngest/api/api.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.InngestApi = void 0;
const consts_js_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/inngest@3.32.5_express@4.21.2_next@15.3.4_@opentelemetry+api@1.9.0_react-dom@19.2.0_rea_302ab31fd2a599b814fb517e8771719b/node_modules/inngest/helpers/consts.js [app-route] (ecmascript)");
const devserver_js_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/inngest@3.32.5_express@4.21.2_next@15.3.4_@opentelemetry+api@1.9.0_react-dom@19.2.0_rea_302ab31fd2a599b814fb517e8771719b/node_modules/inngest/helpers/devserver.js [app-route] (ecmascript)");
const errors_js_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/inngest@3.32.5_express@4.21.2_next@15.3.4_@opentelemetry+api@1.9.0_react-dom@19.2.0_rea_302ab31fd2a599b814fb517e8771719b/node_modules/inngest/helpers/errors.js [app-route] (ecmascript)");
const net_js_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/inngest@3.32.5_express@4.21.2_next@15.3.4_@opentelemetry+api@1.9.0_react-dom@19.2.0_rea_302ab31fd2a599b814fb517e8771719b/node_modules/inngest/helpers/net.js [app-route] (ecmascript)");
const strings_js_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/inngest@3.32.5_express@4.21.2_next@15.3.4_@opentelemetry+api@1.9.0_react-dom@19.2.0_rea_302ab31fd2a599b814fb517e8771719b/node_modules/inngest/helpers/strings.js [app-route] (ecmascript)");
const types_js_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/inngest@3.32.5_express@4.21.2_next@15.3.4_@opentelemetry+api@1.9.0_react-dom@19.2.0_rea_302ab31fd2a599b814fb517e8771719b/node_modules/inngest/types.js [app-route] (ecmascript)");
const schema_js_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/inngest@3.32.5_express@4.21.2_next@15.3.4_@opentelemetry+api@1.9.0_react-dom@19.2.0_rea_302ab31fd2a599b814fb517e8771719b/node_modules/inngest/api/schema.js [app-route] (ecmascript)");
class InngestApi {
    constructor({ baseUrl, signingKey, signingKeyFallback, fetch, mode }){
        this.apiBaseUrl = baseUrl;
        this.signingKey = signingKey;
        this.signingKeyFallback = signingKeyFallback;
        this.fetch = fetch;
        this.mode = mode;
    }
    get hashedKey() {
        return (0, strings_js_1.hashSigningKey)(this.signingKey);
    }
    get hashedFallbackKey() {
        if (!this.signingKeyFallback) {
            return;
        }
        return (0, strings_js_1.hashSigningKey)(this.signingKeyFallback);
    }
    // set the signing key in case it was not instantiated previously
    setSigningKey(key) {
        if (typeof key === "string" && this.signingKey === "") {
            this.signingKey = key;
        }
    }
    setSigningKeyFallback(key) {
        if (typeof key === "string" && !this.signingKeyFallback) {
            this.signingKeyFallback = key;
        }
    }
    async getTargetUrl(path) {
        if (this.apiBaseUrl) {
            return new URL(path, this.apiBaseUrl);
        }
        let url = new URL(path, consts_js_1.defaultInngestApiBaseUrl);
        if (this.mode.isDev && this.mode.isInferred && !this.apiBaseUrl) {
            const devAvailable = await (0, devserver_js_1.devServerAvailable)(consts_js_1.defaultDevServerHost, this.fetch);
            if (devAvailable) {
                url = new URL(path, consts_js_1.defaultDevServerHost);
            }
        }
        return url;
    }
    async getRunSteps(runId, version) {
        return (0, net_js_1.fetchWithAuthFallback)({
            authToken: this.hashedKey,
            authTokenFallback: this.hashedFallbackKey,
            fetch: this.fetch,
            url: await this.getTargetUrl(`/v0/runs/${runId}/actions`)
        }).then(async (resp)=>{
            const data = await resp.json();
            if (resp.ok) {
                return (0, types_js_1.ok)(schema_js_1.stepsSchemas[version].parse(data));
            } else {
                return (0, types_js_1.err)(schema_js_1.errorSchema.parse(data));
            }
        }).catch((error)=>{
            return (0, types_js_1.err)({
                error: (0, errors_js_1.getErrorMessage)(error, "Unknown error retrieving step data"),
                status: 500
            });
        });
    }
    async getRunBatch(runId) {
        return (0, net_js_1.fetchWithAuthFallback)({
            authToken: this.hashedKey,
            authTokenFallback: this.hashedFallbackKey,
            fetch: this.fetch,
            url: await this.getTargetUrl(`/v0/runs/${runId}/batch`)
        }).then(async (resp)=>{
            const data = await resp.json();
            if (resp.ok) {
                return (0, types_js_1.ok)(schema_js_1.batchSchema.parse(data));
            } else {
                return (0, types_js_1.err)(schema_js_1.errorSchema.parse(data));
            }
        }).catch((error)=>{
            return (0, types_js_1.err)({
                error: (0, errors_js_1.getErrorMessage)(error, "Unknown error retrieving event batch"),
                status: 500
            });
        });
    }
}
exports.InngestApi = InngestApi; //# sourceMappingURL=api.js.map
}}),
"[project]/node_modules/.pnpm/inngest@3.32.5_express@4.21.2_next@15.3.4_@opentelemetry+api@1.9.0_react-dom@19.2.0_rea_302ab31fd2a599b814fb517e8771719b/node_modules/inngest/version.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.version = void 0;
// Generated by genversion.
exports.version = "3.32.5"; //# sourceMappingURL=version.js.map
}}),
"[project]/node_modules/.pnpm/inngest@3.32.5_express@4.21.2_next@15.3.4_@opentelemetry+api@1.9.0_react-dom@19.2.0_rea_302ab31fd2a599b814fb517e8771719b/node_modules/inngest/helpers/env.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
// This file exists to help normalize process.env amongst the backend
// and frontend.  Many frontends (eg. Next, CRA) utilize webpack's DefinePlugin
// along with prefixes, meaning we have to explicitly use the full `process.env.FOO`
// string in order to read variables.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.parseAsBoolean = exports.getResponse = exports.getFetch = exports.platformSupportsStreaming = exports.getPlatformName = exports.inngestHeaders = exports.allProcessEnv = exports.processEnv = exports.getEnvironmentName = exports.getMode = exports.Mode = exports.devServerHost = void 0;
const version_js_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/inngest@3.32.5_express@4.21.2_next@15.3.4_@opentelemetry+api@1.9.0_react-dom@19.2.0_rea_302ab31fd2a599b814fb517e8771719b/node_modules/inngest/version.js [app-route] (ecmascript)");
const consts_js_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/inngest@3.32.5_express@4.21.2_next@15.3.4_@opentelemetry+api@1.9.0_react-dom@19.2.0_rea_302ab31fd2a599b814fb517e8771719b/node_modules/inngest/helpers/consts.js [app-route] (ecmascript)");
const strings_js_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/inngest@3.32.5_express@4.21.2_next@15.3.4_@opentelemetry+api@1.9.0_react-dom@19.2.0_rea_302ab31fd2a599b814fb517e8771719b/node_modules/inngest/helpers/strings.js [app-route] (ecmascript)");
/**
 * devServerHost returns the dev server host by searching for the INNGEST_DEVSERVER_URL
 * environment variable (plus project prefixces for eg. react, such as REACT_APP_INNGEST_DEVSERVER_URL).
 *
 * If not found this returns undefined, indicating that the env var has not been set.
 *
 * @example devServerHost()
 */ const devServerHost = (env = (0, exports.allProcessEnv)())=>{
    // devServerKeys are the env keys we search for to discover the dev server
    // URL.  This includes the standard key first, then includes prefixed keys
    // for use within common frameworks (eg. CRA, next).
    //
    // We have to fully write these using process.env as they're typically
    // processed using webpack's DefinePlugin, which is dumb and does a straight
    // text replacement instead of actually understanding the AST, despite webpack
    // being fully capable of understanding the AST.
    const prefixes = [
        "REACT_APP_",
        "NEXT_PUBLIC_"
    ];
    const keys = [
        consts_js_1.envKeys.InngestBaseUrl,
        consts_js_1.envKeys.InngestDevMode
    ];
    const values = keys.flatMap((key)=>{
        return prefixes.map((prefix)=>{
            return env[prefix + key];
        });
    });
    return values.find((v)=>{
        if (!v) {
            return;
        }
        try {
            return Boolean(new URL(v));
        } catch (_a) {
        // no-op
        }
    });
};
exports.devServerHost = devServerHost;
const checkFns = ((checks)=>checks)({
    equals: (actual, expected)=>actual === expected,
    "starts with": (actual, expected)=>{
        var _a;
        return expected ? (_a = actual === null || actual === void 0 ? void 0 : actual.startsWith(expected)) !== null && _a !== void 0 ? _a : false : false;
    },
    "is truthy": (actual)=>Boolean(actual),
    "is truthy but not": (actual, expected)=>Boolean(actual) && actual !== expected
});
const prodChecks = [
    [
        "CF_PAGES",
        "equals",
        "1"
    ],
    [
        "CONTEXT",
        "starts with",
        "prod"
    ],
    [
        "ENVIRONMENT",
        "starts with",
        "prod"
    ],
    [
        "NODE_ENV",
        "starts with",
        "prod"
    ],
    [
        "VERCEL_ENV",
        "starts with",
        "prod"
    ],
    [
        "DENO_DEPLOYMENT_ID",
        "is truthy"
    ],
    [
        consts_js_1.envKeys.VercelEnvKey,
        "is truthy but not",
        "development"
    ],
    [
        consts_js_1.envKeys.IsNetlify,
        "is truthy"
    ],
    [
        consts_js_1.envKeys.IsRender,
        "is truthy"
    ],
    [
        consts_js_1.envKeys.RailwayBranch,
        "is truthy"
    ],
    [
        consts_js_1.envKeys.IsCloudflarePages,
        "is truthy"
    ]
];
class Mode {
    constructor({ type, isExplicit, explicitDevUrl, env = (0, exports.allProcessEnv)() }){
        this.env = env;
        this.type = type;
        this.isExplicit = isExplicit || Boolean(explicitDevUrl);
        this.explicitDevUrl = explicitDevUrl;
    }
    get isDev() {
        return this.type === "dev";
    }
    get isCloud() {
        return this.type === "cloud";
    }
    get isInferred() {
        return !this.isExplicit;
    }
    /**
     * If we are explicitly in a particular mode, retrieve the URL that we are
     * sure we should be using, not considering any environment variables or other
     * influences.
     */ getExplicitUrl(defaultCloudUrl) {
        if (!this.isExplicit) {
            return undefined;
        }
        if (this.explicitDevUrl) {
            return this.explicitDevUrl.href;
        }
        if (this.isCloud) {
            return defaultCloudUrl;
        }
        if (this.isDev) {
            return consts_js_1.defaultDevServerHost;
        }
        return undefined;
    }
}
exports.Mode = Mode;
/**
 * Returns the mode of the current environment, based off of either passed
 * environment variables or `process.env`, or explicit settings.
 */ const getMode = ({ env = (0, exports.allProcessEnv)(), client, explicitMode } = {})=>{
    if (explicitMode) {
        return new Mode({
            type: explicitMode,
            isExplicit: true,
            env
        });
    }
    if (client === null || client === void 0 ? void 0 : client["mode"].isExplicit) {
        return client["mode"];
    }
    if (consts_js_1.envKeys.InngestDevMode in env) {
        if (typeof env[consts_js_1.envKeys.InngestDevMode] === "string") {
            try {
                const explicitDevUrl = new URL(env[consts_js_1.envKeys.InngestDevMode]);
                return new Mode({
                    type: "dev",
                    isExplicit: true,
                    explicitDevUrl,
                    env
                });
            } catch (_a) {
            // no-op
            }
        }
        const envIsDev = (0, exports.parseAsBoolean)(env[consts_js_1.envKeys.InngestDevMode]);
        if (typeof envIsDev === "boolean") {
            return new Mode({
                type: envIsDev ? "dev" : "cloud",
                isExplicit: true,
                env
            });
        }
    }
    const isProd = prodChecks.some(([key, checkKey, expected])=>{
        return checkFns[checkKey]((0, strings_js_1.stringifyUnknown)(env[key]), expected);
    });
    return new Mode({
        type: isProd ? "cloud" : "dev",
        isExplicit: false,
        env
    });
};
exports.getMode = getMode;
/**
 * getEnvironmentName returns the suspected branch name for this environment by
 * searching through a set of common environment variables.
 *
 * This could be used to determine if we're on a branch deploy or not, though it
 * should be noted that we don't know if this is the default branch or not.
 */ const getEnvironmentName = (env = (0, exports.allProcessEnv)())=>{
    /**
     * Order is important; more than one of these env vars may be set, so ensure
     * that we check the most specific, most reliable env vars first.
     */ return env[consts_js_1.envKeys.InngestEnvironment] || env[consts_js_1.envKeys.BranchName] || env[consts_js_1.envKeys.VercelBranch] || env[consts_js_1.envKeys.NetlifyBranch] || env[consts_js_1.envKeys.CloudflarePagesBranch] || env[consts_js_1.envKeys.RenderBranch] || env[consts_js_1.envKeys.RailwayBranch];
};
exports.getEnvironmentName = getEnvironmentName;
const processEnv = (key)=>{
    return (0, exports.allProcessEnv)()[key];
};
exports.processEnv = processEnv;
/**
 * allProcessEnv returns the current process environment variables, or an empty
 * object if they cannot be read, making sure we support environments other than
 * Node such as Deno, too.
 *
 * Using this ensures we don't dangerously access `process.env` in environments
 * where it may not be defined, such as Deno or the browser.
 */ const allProcessEnv = ()=>{
    // Node, or Node-like environments
    try {
        // eslint-disable-next-line @inngest/internal/process-warn
        if ("TURBOPACK compile-time truthy", 1) {
            // eslint-disable-next-line @inngest/internal/process-warn
            return process.env;
        }
    } catch (_err) {
    // noop
    }
    // Deno
    try {
        const env = Deno.env.toObject();
        if (env) {
            return env;
        }
    } catch (_err) {
    // noop
    }
    // Netlify
    try {
        const env = Netlify.env.toObject();
        if (env) {
            return env;
        }
    } catch (_err) {
    // noop
    }
    return {};
};
exports.allProcessEnv = allProcessEnv;
/**
 * Generate a standardised set of headers based on input and environment
 * variables.
 *
 *
 */ const inngestHeaders = (opts)=>{
    var _a;
    const sdkVersion = `inngest-js:v${version_js_1.version}`;
    const headers = {
        "Content-Type": "application/json",
        "User-Agent": sdkVersion,
        [consts_js_1.headerKeys.SdkVersion]: sdkVersion
    };
    if (opts === null || opts === void 0 ? void 0 : opts.framework) {
        headers[consts_js_1.headerKeys.Framework] = opts.framework;
    }
    if (opts === null || opts === void 0 ? void 0 : opts.expectedServerKind) {
        headers[consts_js_1.headerKeys.InngestExpectedServerKind] = opts.expectedServerKind;
    }
    const env = Object.assign(Object.assign({}, (0, exports.allProcessEnv)()), opts === null || opts === void 0 ? void 0 : opts.env);
    const inngestEnv = (opts === null || opts === void 0 ? void 0 : opts.inngestEnv) || (0, exports.getEnvironmentName)(env);
    if (inngestEnv) {
        headers[consts_js_1.headerKeys.Environment] = inngestEnv;
    }
    const platform = (0, exports.getPlatformName)(env);
    if (platform) {
        headers[consts_js_1.headerKeys.Platform] = platform;
    }
    return Object.assign(Object.assign(Object.assign({}, headers), (_a = opts === null || opts === void 0 ? void 0 : opts.client) === null || _a === void 0 ? void 0 : _a["headers"]), opts === null || opts === void 0 ? void 0 : opts.extras);
};
exports.inngestHeaders = inngestHeaders;
/**
 * A set of checks that, given an environment, will return `true` if the current
 * environment is running on the platform with the given name.
 */ const platformChecks = {
    /**
     * Vercel Edge Functions don't have access to environment variables unless
     * they are explicitly referenced in the top level code, but they do have a
     * global `EdgeRuntime` variable set that we can use to detect this.
     */ vercel: (env)=>env[consts_js_1.envKeys.IsVercel] === "1" || typeof EdgeRuntime === "string",
    netlify: (env)=>env[consts_js_1.envKeys.IsNetlify] === "true",
    "cloudflare-pages": (env)=>env[consts_js_1.envKeys.IsCloudflarePages] === "1",
    render: (env)=>env[consts_js_1.envKeys.IsRender] === "true",
    railway: (env)=>Boolean(env[consts_js_1.envKeys.RailwayEnvironment])
};
/**
 * A set of checks that, given an environment, will return `true` if the current
 * environment and platform supports streaming responses back to Inngest.
 *
 * Streaming capability is both framework and platform-based. Frameworks are
 * supported in serve handlers, and platforms are checked here.
 *
 * As such, this record declares which platforms we explicitly support for
 * streaming and is used by {@link platformSupportsStreaming}.
 */ const streamingChecks = {
    /**
     * "Vercel supports streaming for Serverless Functions, Edge Functions, and
     * React Server Components in Next.js projects."
     *
     * In practice, however, there are many reports of streaming not working as
     * expected on Serverless Functions, so we resort to only allowing streaming
     * for Edge Functions here.
     *
     * See {@link https://vercel.com/docs/frameworks/nextjs#streaming}
     */ vercel: (_framework, _env)=>typeof EdgeRuntime === "string",
    "cloudflare-pages": ()=>true
};
const getPlatformName = (env)=>{
    return Object.keys(platformChecks).find((key)=>{
        return platformChecks[key](env);
    });
};
exports.getPlatformName = getPlatformName;
/**
 * Returns `true` if we believe the current environment supports streaming
 * responses back to Inngest.
 *
 * We run a check directly related to the platform we believe we're running on,
 * usually based on environment variables.
 */ const platformSupportsStreaming = (framework, env = (0, exports.allProcessEnv)())=>{
    var _a, _b;
    return (_b = (_a = streamingChecks[(0, exports.getPlatformName)(env)]) === null || _a === void 0 ? void 0 : _a.call(streamingChecks, framework, env)) !== null && _b !== void 0 ? _b : false;
};
exports.platformSupportsStreaming = platformSupportsStreaming;
/**
 * A unique symbol used to mark a custom fetch implementation. We wrap the
 * implementations to provide some extra control when handling errors.
 */ const CUSTOM_FETCH_MARKER = Symbol("Custom fetch implementation");
/**
 * Given a potential fetch function, return the fetch function to use based on
 * this and the environment.
 */ const getFetch = (givenFetch)=>{
    /**
     * If we've explicitly been given a fetch function, use that.
     */ if (givenFetch) {
        if (CUSTOM_FETCH_MARKER in givenFetch) {
            return givenFetch;
        }
        /**
         * We wrap the given fetch function to provide some extra control when
         * handling errors.
         */ const customFetch = async (...args)=>{
            var _a;
            try {
                return await givenFetch(...args);
            } catch (err) {
                /**
                 * Capture warnings that are not simple fetch failures and highlight
                 * them for the user.
                 *
                 * We also use this opportunity to log the causing error, as code higher
                 * up the stack will likely abstract this.
                 */ if (!(err instanceof Error) || !((_a = err.message) === null || _a === void 0 ? void 0 : _a.startsWith("fetch failed"))) {
                    console.warn("A request failed when using a custom fetch implementation; this may be a misconfiguration. Make sure that your fetch client is correctly bound to the global scope.");
                    console.error(err);
                }
                throw err;
            }
        };
        /**
         * Mark the custom fetch implementation so that we can identify it later, in
         * addition to adding some runtime properties to it to make it seem as much
         * like the original fetch as possible.
         */ Object.defineProperties(customFetch, {
            [CUSTOM_FETCH_MARKER]: {},
            name: {
                value: givenFetch.name
            },
            length: {
                value: givenFetch.length
            }
        });
        return customFetch;
    }
    /**
     * Browser or Node 18+
     */ try {
        if (typeof globalThis !== "undefined" && "fetch" in globalThis) {
            return fetch.bind(globalThis);
        }
    } catch (err) {
    // no-op
    }
    /**
     * Existing polyfilled fetch
     */ if (typeof fetch !== "undefined") {
        return fetch;
    }
    /**
     * Environments where fetch cannot be found and must be polyfilled
     */ // eslint-disable-next-line @typescript-eslint/no-var-requires
    return __turbopack_context__.r("[project]/node_modules/.pnpm/cross-fetch@4.1.0/node_modules/cross-fetch/dist/node-ponyfill.js [app-route] (ecmascript)");
};
exports.getFetch = getFetch;
/**
 * If `Response` isn't included in this environment, it's probably an earlier
 * Node env that isn't already polyfilling. This function returns either the
 * native `Response` or a polyfilled one.
 */ const getResponse = ()=>{
    if (typeof Response !== "undefined") {
        return Response;
    }
    // eslint-disable-next-line @typescript-eslint/no-unsafe-return, @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-var-requires
    return __turbopack_context__.r("[project]/node_modules/.pnpm/cross-fetch@4.1.0/node_modules/cross-fetch/dist/node-ponyfill.js [app-route] (ecmascript)").Response;
};
exports.getResponse = getResponse;
/**
 * Given an unknown value, try to parse it as a `boolean`. Useful for parsing
 * environment variables that could be a selection of different values such as
 * `"true"`, `"1"`.
 *
 * If the value could not be confidently parsed as a `boolean` or was seen to be
 * `undefined`, this function returns `undefined`.
 */ const parseAsBoolean = (value)=>{
    if (typeof value === "boolean") {
        return value;
    }
    if (typeof value === "number") {
        return Boolean(value);
    }
    if (typeof value === "string") {
        const trimmed = value.trim().toLowerCase();
        if (trimmed === "undefined") {
            return undefined;
        }
        if ([
            "true",
            "1"
        ].includes(trimmed)) {
            return true;
        }
        return false;
    }
    return undefined;
};
exports.parseAsBoolean = parseAsBoolean; //# sourceMappingURL=env.js.map
}}),
"[project]/node_modules/.pnpm/inngest@3.32.5_express@4.21.2_next@15.3.4_@opentelemetry+api@1.9.0_react-dom@19.2.0_rea_302ab31fd2a599b814fb517e8771719b/node_modules/inngest/helpers/promises.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var __await = this && this.__await || function(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
};
var __asyncGenerator = this && this.__asyncGenerator || function(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i[Symbol.asyncIterator] = function() {
        return this;
    }, i;
    "TURBOPACK unreachable";
    function awaitReturn(f) {
        return function(v) {
            return Promise.resolve(v).then(f, reject);
        };
    }
    function verb(n, f) {
        if (g[n]) {
            i[n] = function(v) {
                return new Promise(function(a, b) {
                    q.push([
                        n,
                        v,
                        a,
                        b
                    ]) > 1 || resume(n, v);
                });
            };
            if (f) i[n] = f(i[n]);
        }
    }
    function resume(n, v) {
        try {
            step(g[n](v));
        } catch (e) {
            settle(q[0][3], e);
        }
    }
    function step(r) {
        r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
    }
    function fulfill(value) {
        resume("next", value);
    }
    function reject(value) {
        resume("throw", value);
    }
    function settle(f, v) {
        if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
    }
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.retryWithBackoff = exports.resolveNextTick = exports.runAsPromise = exports.createTimeoutPromise = exports.createDeferredPromiseWithStack = exports.createDeferredPromise = exports.resolveAfterPending = exports.createFrozenPromise = void 0;
/**
 * Some environments don't allow access to the global queueMicrotask(). While we
 * had assumed this was only true for those powered by earlier versions of Node
 * (<14) that we don't officially support, Vercel's Edge Functions also obscure
 * the function in dev, even though the platform it's based on (Cloudflare
 * Workers) appropriately exposes it. Even worse, production Vercel Edge
 * Functions can see the function, but it immediately blows up the function when
 * used.
 *
 * Therefore, we can fall back to a reasonable alternative of
 * `Promise.resolve().then(fn)` instead. This _may_ be slightly slower in modern
 * environments, but at least we can still work in these environments.
 */ const shimQueueMicrotask = (callback)=>{
    void Promise.resolve().then(callback);
};
/**
 * A helper function to create a `Promise` that will never settle.
 *
 * It purposefully creates no references to `resolve` or `reject` so that the
 * returned `Promise` will remain unsettled until it falls out of scope and is
 * garbage collected.
 *
 * This should be used within transient closures to fake asynchronous action, so
 * long as it's guaranteed that they will fall out of scope.
 */ const createFrozenPromise = ()=>{
    return new Promise(()=>undefined);
};
exports.createFrozenPromise = createFrozenPromise;
/**
 * Returns a Promise that resolves after the current event loop's microtasks
 * have finished, but before the next event loop tick.
 */ const resolveAfterPending = (count = 10)=>{
    /**
     * This uses a brute force implementation that will continue to enqueue
     * microtasks 10 times before resolving. This is to ensure that the microtask
     * queue is drained, even if the microtask queue is being manipulated by other
     * code.
     *
     * While this still doesn't guarantee that the microtask queue is drained,
     * it's our best bet for giving other non-controlled promises a chance to
     * resolve before we continue without resorting to falling in to the next
     * tick.
     */ return new Promise((resolve)=>{
        let i = 0;
        const iterate = ()=>{
            shimQueueMicrotask(()=>{
                if (i++ > count) {
                    return resolve();
                }
                iterate();
            });
        };
        iterate();
    });
};
exports.resolveAfterPending = resolveAfterPending;
/**
 * Creates and returns Promise that can be resolved or rejected with the
 * returned `resolve` and `reject` functions.
 *
 * Resolving or rejecting the function will return a new set of Promise control
 * functions. These can be ignored if the original Promise is all that's needed.
 */ const createDeferredPromise = ()=>{
    let resolve;
    let reject;
    const promise = new Promise((_resolve, _reject)=>{
        resolve = (value)=>{
            _resolve(value);
            return (0, exports.createDeferredPromise)();
        };
        reject = (reason)=>{
            _reject(reason);
            return (0, exports.createDeferredPromise)();
        };
    });
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    return {
        promise,
        resolve: resolve,
        reject: reject
    };
};
exports.createDeferredPromise = createDeferredPromise;
/**
 * Creates and returns a deferred Promise that can be resolved or rejected with
 * the returned `resolve` and `reject` functions.
 *
 * For each Promise resolved or rejected this way, this will also keep a stack
 * of all unhandled Promises, resolved or rejected.
 *
 * Once a Promise is read, it is removed from the stack.
 */ const createDeferredPromiseWithStack = ()=>{
    const settledPromises = [];
    let rotateQueue = ()=>{};
    const results = function() {
        return __asyncGenerator(this, arguments, function*() {
            while(true){
                const next = settledPromises.shift();
                if (next) {
                    yield yield __await(next);
                } else {
                    yield __await(new Promise((resolve)=>{
                        rotateQueue = resolve;
                    }));
                }
            }
        });
    }();
    const shimDeferredPromise = (deferred)=>{
        const originalResolve = deferred.resolve;
        const originalReject = deferred.reject;
        deferred.resolve = (value)=>{
            settledPromises.push(deferred.promise);
            rotateQueue();
            return shimDeferredPromise(originalResolve(value));
        };
        deferred.reject = (reason)=>{
            settledPromises.push(deferred.promise);
            rotateQueue();
            return shimDeferredPromise(originalReject(reason));
        };
        return deferred;
    };
    const deferred = shimDeferredPromise((0, exports.createDeferredPromise)());
    return {
        deferred,
        results
    };
};
exports.createDeferredPromiseWithStack = createDeferredPromiseWithStack;
/**
 * Creates a Promise that will resolve after the given duration, along with
 * methods to start, clear, and reset the timeout.
 */ const createTimeoutPromise = (duration)=>{
    const { promise, resolve } = (0, exports.createDeferredPromise)();
    let timeout;
    // eslint-disable-next-line prefer-const
    let ret;
    const start = ()=>{
        if (timeout) return ret;
        timeout = setTimeout(()=>{
            resolve();
        }, duration);
        return ret;
    };
    const clear = ()=>{
        clearTimeout(timeout);
        timeout = undefined;
    };
    const reset = ()=>{
        clear();
        return start();
    };
    ret = Object.assign(promise, {
        start,
        clear,
        reset
    });
    return ret;
};
exports.createTimeoutPromise = createTimeoutPromise;
/**
 * Take any function and safely promisify such that both synchronous and
 * asynchronous errors are caught and returned as a rejected Promise.
 *
 * The passed `fn` can be undefined to support functions that may conditionally
 * be defined.
 */ // eslint-disable-next-line @typescript-eslint/no-explicit-any
const runAsPromise = (fn)=>{
    // eslint-disable-next-line @typescript-eslint/no-unsafe-return
    return Promise.resolve().then(fn);
};
exports.runAsPromise = runAsPromise;
/**
 * Returns a Promise that resolve after the current event loop tick.
 */ const resolveNextTick = ()=>{
    return new Promise((resolve)=>setTimeout(resolve));
};
exports.resolveNextTick = resolveNextTick;
const retryWithBackoff = async (fn, opts)=>{
    var _a;
    const maxAttempts = (opts === null || opts === void 0 ? void 0 : opts.maxAttempts) || 5;
    const baseDelay = (_a = opts === null || opts === void 0 ? void 0 : opts.baseDelay) !== null && _a !== void 0 ? _a : 100;
    for(let attempt = 1; attempt <= maxAttempts; attempt++){
        try {
            return await fn();
        } catch (err) {
            if (attempt >= maxAttempts) {
                throw err;
            }
            const jitter = Math.random() * baseDelay;
            const delay = baseDelay * Math.pow(2, attempt - 1) + jitter;
            await new Promise((resolve)=>setTimeout(resolve, delay));
        }
    }
    throw new Error("Max retries reached; this should be unreachable.");
};
exports.retryWithBackoff = retryWithBackoff; //# sourceMappingURL=promises.js.map
}}),
"[project]/node_modules/.pnpm/inngest@3.32.5_express@4.21.2_next@15.3.4_@opentelemetry+api@1.9.0_react-dom@19.2.0_rea_302ab31fd2a599b814fb517e8771719b/node_modules/inngest/middleware/logger.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ProxyLogger = exports.DefaultLogger = void 0;
class DefaultLogger {
    info(...args) {
        console.info(...args);
    }
    warn(...args) {
        console.warn(...args);
    }
    error(...args) {
        console.error(...args);
    }
    debug(...args) {
        console.debug(...args);
    }
}
exports.DefaultLogger = DefaultLogger;
/**
 * ProxyLogger aims to provide a thin wrapper on user's provided logger.
 * It's expected to be turned on and off based on the function execution
 * context, so it doesn't result in duplicated logging.
 *
 * And also attempt to allow enough time for the logger to flush all logs.
 *
 * @public
 */ class ProxyLogger {
    constructor(logger){
        this.enabled = false;
        this.logger = logger;
    }
    info(...args) {
        if (!this.enabled) return;
        this.logger.info(...args);
    }
    warn(...args) {
        if (!this.enabled) return;
        this.logger.warn(...args);
    }
    error(...args) {
        if (!this.enabled) return;
        this.logger.error(...args);
    }
    debug(...args) {
        // there are loggers that don't implement "debug" by default
        if (!this.enabled || !(typeof this.logger.debug === "function")) return;
        this.logger.debug(...args);
    }
    enable() {
        this.enabled = true;
    }
    disable() {
        this.enabled = false;
    }
    async flush() {
        // Allow 1s for the provided logger to handle flushing since the ones that do
        // flushing usually has some kind of timeout of up to 1s.
        //
        // TODO:
        // This should only happen when using a serverless environment because it's very
        // costly from the compute perspective.
        // server runtimes should just let the logger do their thing since most of them
        // should have already figured what to do in those environments, be it threading or
        // something else.
        if (this.logger.constructor.name !== DefaultLogger.name) {
            await new Promise((resolve)=>{
                setTimeout(()=>resolve(null), 1000);
            });
        }
    }
}
exports.ProxyLogger = ProxyLogger; //# sourceMappingURL=logger.js.map
}}),
"[project]/node_modules/.pnpm/inngest@3.32.5_express@4.21.2_next@15.3.4_@opentelemetry+api@1.9.0_react-dom@19.2.0_rea_302ab31fd2a599b814fb517e8771719b/node_modules/inngest/helpers/functions.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.fetchAllFnData = exports.parseFnData = exports.undefinedToNull = exports.waterfall = exports.cacheFn = void 0;
const zod_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/zod@3.22.5/node_modules/zod/lib/index.js [app-route] (ecmascript)");
const schema_js_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/inngest@3.32.5_express@4.21.2_next@15.3.4_@opentelemetry+api@1.9.0_react-dom@19.2.0_rea_302ab31fd2a599b814fb517e8771719b/node_modules/inngest/api/schema.js [app-route] (ecmascript)");
const InngestExecution_js_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/inngest@3.32.5_express@4.21.2_next@15.3.4_@opentelemetry+api@1.9.0_react-dom@19.2.0_rea_302ab31fd2a599b814fb517e8771719b/node_modules/inngest/components/execution/InngestExecution.js [app-route] (ecmascript)");
const types_js_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/inngest@3.32.5_express@4.21.2_next@15.3.4_@opentelemetry+api@1.9.0_react-dom@19.2.0_rea_302ab31fd2a599b814fb517e8771719b/node_modules/inngest/types.js [app-route] (ecmascript)");
const errors_js_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/inngest@3.32.5_express@4.21.2_next@15.3.4_@opentelemetry+api@1.9.0_react-dom@19.2.0_rea_302ab31fd2a599b814fb517e8771719b/node_modules/inngest/helpers/errors.js [app-route] (ecmascript)");
/**
 * Wraps a function with a cache. When the returned function is run, it will
 * cache the result and return it on subsequent calls.
 */ // eslint-disable-next-line @typescript-eslint/no-explicit-any
const cacheFn = (fn)=>{
    const key = "value";
    const cache = new Map();
    return (...args)=>{
        if (!cache.has(key)) {
            // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
            cache.set(key, fn(...args));
        }
        return cache.get(key);
    };
};
exports.cacheFn = cacheFn;
/**
 * Given an array of functions, return a new function that will run each
 * function in series and return the result of the final function. Regardless of
 * if the functions are synchronous or asynchronous, they'll be made into an
 * async promise chain.
 *
 * If an error is thrown, the waterfall will stop and return the error.
 *
 * Because this needs to support both sync and async functions, it only allows
 * functions that accept a single argument.
 */ // eslint-disable-next-line @typescript-eslint/no-explicit-any
const waterfall = (fns, /**
 * A function that transforms the result of each function in the waterfall,
 * ready for the next function.
 *
 * Will not be called on the final function.
 */ // eslint-disable-next-line @typescript-eslint/no-explicit-any
transform)=>{
    return (...args)=>{
        const chain = fns.reduce(async (acc, fn)=>{
            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
            const prev = await acc;
            const output = await fn(prev);
            if (transform) {
                // eslint-disable-next-line @typescript-eslint/no-unsafe-return
                return await transform(prev, output);
            }
            if (typeof output === "undefined") {
                // eslint-disable-next-line @typescript-eslint/no-unsafe-return
                return prev;
            }
            return output;
        }, Promise.resolve(args[0]));
        return chain;
    };
};
exports.waterfall = waterfall;
/**
 * Given a value `v`, return `v` if it's not undefined, otherwise return `null`.
 */ const undefinedToNull = (v)=>{
    const isUndefined = typeof v === "undefined";
    return isUndefined ? null : v;
};
exports.undefinedToNull = undefinedToNull;
const fnDataVersionSchema = zod_1.z.object({
    version: zod_1.z.literal(-1).or(zod_1.z.literal(0)).or(zod_1.z.literal(1)).or(zod_1.z.literal(2)).optional().transform((v)=>{
        if (typeof v === "undefined") {
            console.debug(`No request version specified by executor; defaulting to v${InngestExecution_js_1.PREFERRED_EXECUTION_VERSION}`);
            return InngestExecution_js_1.PREFERRED_EXECUTION_VERSION;
        }
        return v === -1 ? InngestExecution_js_1.PREFERRED_EXECUTION_VERSION : v;
    })
});
const parseFnData = (data)=>{
    let version;
    try {
        ({ version } = fnDataVersionSchema.parse(data));
        const versionHandlers = {
            [InngestExecution_js_1.ExecutionVersion.V0]: ()=>Object.assign({
                    version: InngestExecution_js_1.ExecutionVersion.V0
                }, zod_1.z.object({
                    event: zod_1.z.record(zod_1.z.any()),
                    events: zod_1.z.array(zod_1.z.record(zod_1.z.any())).default([]),
                    steps: schema_js_1.stepsSchemas[InngestExecution_js_1.ExecutionVersion.V0],
                    ctx: zod_1.z.object({
                        run_id: zod_1.z.string(),
                        attempt: zod_1.z.number().default(0),
                        stack: zod_1.z.object({
                            stack: zod_1.z.array(zod_1.z.string()).nullable().transform((v)=>Array.isArray(v) ? v : []),
                            current: zod_1.z.number()
                        }).passthrough().optional().nullable()
                    }).optional().nullable(),
                    use_api: zod_1.z.boolean().default(false)
                }).parse(data)),
            [InngestExecution_js_1.ExecutionVersion.V1]: ()=>Object.assign({
                    version: InngestExecution_js_1.ExecutionVersion.V1
                }, zod_1.z.object({
                    event: zod_1.z.record(zod_1.z.any()),
                    events: zod_1.z.array(zod_1.z.record(zod_1.z.any())).default([]),
                    steps: schema_js_1.stepsSchemas[InngestExecution_js_1.ExecutionVersion.V1],
                    ctx: zod_1.z.object({
                        run_id: zod_1.z.string(),
                        attempt: zod_1.z.number().default(0),
                        disable_immediate_execution: zod_1.z.boolean().default(false),
                        use_api: zod_1.z.boolean().default(false),
                        stack: zod_1.z.object({
                            stack: zod_1.z.array(zod_1.z.string()).nullable().transform((v)=>Array.isArray(v) ? v : []),
                            current: zod_1.z.number()
                        }).passthrough().optional().nullable()
                    }).optional().nullable()
                }).parse(data)),
            [InngestExecution_js_1.ExecutionVersion.V2]: ()=>Object.assign({
                    version: InngestExecution_js_1.ExecutionVersion.V2
                }, zod_1.z.object({
                    event: zod_1.z.record(zod_1.z.any()),
                    events: zod_1.z.array(zod_1.z.record(zod_1.z.any())).default([]),
                    steps: schema_js_1.stepsSchemas[InngestExecution_js_1.ExecutionVersion.V2],
                    ctx: zod_1.z.object({
                        run_id: zod_1.z.string(),
                        attempt: zod_1.z.number().default(0),
                        disable_immediate_execution: zod_1.z.boolean().default(false),
                        use_api: zod_1.z.boolean().default(false),
                        stack: zod_1.z.object({
                            stack: zod_1.z.array(zod_1.z.string()).nullable().transform((v)=>Array.isArray(v) ? v : []),
                            current: zod_1.z.number()
                        }).passthrough().optional().nullable()
                    }).optional().nullable()
                }).parse(data))
        };
        return versionHandlers[version]();
    } catch (err) {
        throw new Error(parseFailureErr(err));
    }
};
exports.parseFnData = parseFnData;
const fetchAllFnData = async ({ data, api, version })=>{
    var _a, _b, _c, _d;
    const result = Object.assign({}, data);
    try {
        if (result.version === InngestExecution_js_1.ExecutionVersion.V0 && result.use_api || result.version === InngestExecution_js_1.ExecutionVersion.V1 && ((_a = result.ctx) === null || _a === void 0 ? void 0 : _a.use_api)) {
            if (!((_b = result.ctx) === null || _b === void 0 ? void 0 : _b.run_id)) {
                return (0, types_js_1.err)((0, errors_js_1.prettyError)({
                    whatHappened: "failed to attempt retrieving data from API",
                    consequences: "function execution can't continue",
                    why: "run_id is missing from context",
                    stack: true
                }));
            }
            const [evtResp, stepResp] = await Promise.all([
                api.getRunBatch(result.ctx.run_id),
                api.getRunSteps(result.ctx.run_id, version)
            ]);
            if (evtResp.ok) {
                result.events = evtResp.value;
            } else {
                return (0, types_js_1.err)((0, errors_js_1.prettyError)({
                    whatHappened: "failed to retrieve list of events",
                    consequences: "function execution can't continue",
                    why: (_c = evtResp.error) === null || _c === void 0 ? void 0 : _c.error,
                    stack: true
                }));
            }
            if (stepResp.ok) {
                result.steps = stepResp.value;
            } else {
                return (0, types_js_1.err)((0, errors_js_1.prettyError)({
                    whatHappened: "failed to retrieve steps for function run",
                    consequences: "function execution can't continue",
                    why: (_d = stepResp.error) === null || _d === void 0 ? void 0 : _d.error,
                    stack: true
                }));
            }
        }
        return (0, types_js_1.ok)(result);
    } catch (error) {
        // print it out for now.
        // move to something like protobuf so we don't have to deal with this
        console.error(error);
        return (0, types_js_1.err)(parseFailureErr(error));
    }
};
exports.fetchAllFnData = fetchAllFnData;
const parseFailureErr = (err)=>{
    let why;
    if (err instanceof zod_1.ZodError) {
        why = err.toString();
    }
    return (0, errors_js_1.prettyError)({
        whatHappened: "Failed to parse data from executor.",
        consequences: "Function execution can't continue.",
        toFixNow: "Make sure that your API is set up to parse incoming request bodies as JSON, like body-parser for Express (https://expressjs.com/en/resources/middleware/body-parser.html).",
        stack: true,
        why
    });
}; //# sourceMappingURL=functions.js.map
}}),
"[project]/node_modules/.pnpm/inngest@3.32.5_express@4.21.2_next@15.3.4_@opentelemetry+api@1.9.0_react-dom@19.2.0_rea_302ab31fd2a599b814fb517e8771719b/node_modules/inngest/components/InngestMiddleware.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.getHookStack = exports.InngestMiddleware = void 0;
const functions_js_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/inngest@3.32.5_express@4.21.2_next@15.3.4_@opentelemetry+api@1.9.0_react-dom@19.2.0_rea_302ab31fd2a599b814fb517e8771719b/node_modules/inngest/helpers/functions.js [app-route] (ecmascript)");
/**
 * A middleware that can be registered with Inngest to hook into various
 * lifecycles of the SDK and affect input and output of Inngest functionality.
 *
 * See {@link https://innge.st/middleware}
 *
 * @example
 *
 * ```ts
 * export const inngest = new Inngest({
 *   middleware: [
 *     new InngestMiddleware({
 *       name: "My Middleware",
 *       init: () => {
 *         // ...
 *       }
 *     })
 *   ]
 * });
 * ```
 *
 * @public
 */ class InngestMiddleware {
    constructor({ name, init }){
        this.name = name;
        this.init = init;
    }
}
exports.InngestMiddleware = InngestMiddleware;
/**
 * Given some middleware and an entrypoint, runs the initializer for the given
 * `key` and returns functions that will pass arguments through a stack of each
 * given hook in a middleware's lifecycle.
 *
 * Lets the middleware initialize before starting.
 */ const getHookStack = async (/**
 * The stack of middleware that will be used to run hooks.
 */ middleware, /**
 * The hook type to initialize.
 */ key, /**
 * Arguments for the initial hook.
 */ arg, transforms)=>{
    // Wait for middleware to initialize
    const mwStack = await middleware;
    // Step through each middleware and get the hook for the given key
    const keyFns = mwStack.reduce((acc, mw)=>{
        const fn = mw[key];
        if (fn) {
            return [
                ...acc,
                fn
            ];
        }
        return acc;
    }, []);
    // Run each hook found in sequence and collect the results
    const hooksRegistered = await keyFns.reduce(async (acc, fn)=>{
        // eslint-disable-next-line @typescript-eslint/no-unsafe-return
        return [
            ...await acc,
            await fn(arg)
        ];
    }, Promise.resolve([]));
    // Prepare the return object - mutating this instead of using reduce as it
    // results in cleaner code.
    const ret = {};
    // Step through each hook result and create a waterfall joining each key
    for (const hook of hooksRegistered){
        const hookKeys = Object.keys(hook);
        for (const key of hookKeys){
            let fns = [
                hook[key]
            ];
            const existingWaterfall = ret[key];
            if (existingWaterfall) {
                fns = [
                    existingWaterfall,
                    hook[key]
                ];
            }
            const transform = transforms[key];
            ret[key] = (0, functions_js_1.waterfall)(fns, transform);
        }
    }
    // Cache each function in the stack to ensure each can only be called once
    for (const k of Object.keys(ret)){
        const key = k;
        ret[key] = (0, functions_js_1.cacheFn)(ret[key]);
    }
    return ret;
};
exports.getHookStack = getHookStack; //# sourceMappingURL=InngestMiddleware.js.map
}}),
"[project]/node_modules/.pnpm/inngest@3.32.5_express@4.21.2_next@15.3.4_@opentelemetry+api@1.9.0_react-dom@19.2.0_rea_302ab31fd2a599b814fb517e8771719b/node_modules/inngest/components/InngestFunctionReference.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.referenceFunction = exports.InngestFunctionReference = void 0;
/**
 * A reference to an `InngestFunction` that can be used to represent both local
 * and remote functions without pulling in the full function definition (i.e.
 * dependencies).
 *
 * These references can be invoked in the same manner as a regular
 * `InngestFunction`.
 *
 * To create a reference function, use the {@link referenceFunction} helper.
 *
 * @public
 */ class InngestFunctionReference {
    constructor(opts){
        this.opts = opts;
    }
}
exports.InngestFunctionReference = InngestFunctionReference;
/**
 * Create a reference to an `InngestFunction` that can be used to represent both
 * local and remote functions without pulling in the full function definition
 * (i.e. dependencies).
 *
 * These references can be invoked in the same manner as a regular
 * `InngestFunction`.
 *
 * @public
 */ const referenceFunction = ({ functionId, appId })=>{
    return new InngestFunctionReference({
        functionId,
        appId
    });
};
exports.referenceFunction = referenceFunction; //# sourceMappingURL=InngestFunctionReference.js.map
}}),
"[project]/node_modules/.pnpm/inngest@3.32.5_express@4.21.2_next@15.3.4_@opentelemetry+api@1.9.0_react-dom@19.2.0_rea_302ab31fd2a599b814fb517e8771719b/node_modules/inngest/components/InngestStepTools.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.invokePayloadSchema = exports.createStepTools = exports.STEP_INDEXING_SUFFIX = exports.getStepOptions = void 0;
const ai_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/@inngest+ai@0.1.2/node_modules/@inngest/ai/dist/index.js [app-route] (ecmascript)");
const zod_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/zod@3.22.5/node_modules/zod/lib/index.js [app-route] (ecmascript)");
const consts_js_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/inngest@3.32.5_express@4.21.2_next@15.3.4_@opentelemetry+api@1.9.0_react-dom@19.2.0_rea_302ab31fd2a599b814fb517e8771719b/node_modules/inngest/helpers/consts.js [app-route] (ecmascript)");
const strings_js_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/inngest@3.32.5_express@4.21.2_next@15.3.4_@opentelemetry+api@1.9.0_react-dom@19.2.0_rea_302ab31fd2a599b814fb517e8771719b/node_modules/inngest/helpers/strings.js [app-route] (ecmascript)");
const types_js_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/inngest@3.32.5_express@4.21.2_next@15.3.4_@opentelemetry+api@1.9.0_react-dom@19.2.0_rea_302ab31fd2a599b814fb517e8771719b/node_modules/inngest/types.js [app-route] (ecmascript)");
const InngestFunction_js_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/inngest@3.32.5_express@4.21.2_next@15.3.4_@opentelemetry+api@1.9.0_react-dom@19.2.0_rea_302ab31fd2a599b814fb517e8771719b/node_modules/inngest/components/InngestFunction.js [app-route] (ecmascript)");
const InngestFunctionReference_js_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/inngest@3.32.5_express@4.21.2_next@15.3.4_@opentelemetry+api@1.9.0_react-dom@19.2.0_rea_302ab31fd2a599b814fb517e8771719b/node_modules/inngest/components/InngestFunctionReference.js [app-route] (ecmascript)");
const getStepOptions = (options)=>{
    if (typeof options === "string") {
        return {
            id: options
        };
    }
    return options;
};
exports.getStepOptions = getStepOptions;
/**
 * Suffix used to namespace steps that are automatically indexed.
 */ exports.STEP_INDEXING_SUFFIX = ":";
/**
 * Create a new set of step function tools ready to be used in a step function.
 * This function should be run and a fresh set of tools provided every time a
 * function is run.
 *
 * An op stack (function state) is passed in as well as some mutable properties
 * that the tools can use to submit a new op.
 */ const createStepTools = (client, execution, stepHandler)=>{
    /**
     * A local helper used to create tools that can be used to submit an op.
     *
     * When using this function, a generic type should be provided which is the
     * function signature exposed to the user.
     */ // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const createTool = (/**
     * A function that returns an ID for this op. This is used to ensure that
     * the op stack is correctly filled, submitted, and retrieved with the same
     * ID.
     *
     * It is passed the arguments passed by the user.
     *
     * Most simple tools will likely only need to define this.
     */ matchOp, opts)=>{
        return async (...args)=>{
            const parsedArgs = args;
            return stepHandler({
                args: parsedArgs,
                matchOp,
                opts
            });
        };
    };
    /**
     * Create a new step run tool that can be used to run a step function using
     * `step.run()` as a shim.
     */ const createStepRun = (/**
     * The sub-type of this step tool, exposed via `opts.type` when the op is
     * reported.
     */ type)=>{
        return createTool(({ id, name }, _fn, ...input)=>{
            const opts = Object.assign(Object.assign({}, input.length ? {
                input
            } : {}), type ? {
                type
            } : {});
            return Object.assign({
                id,
                op: types_js_1.StepOpCode.StepPlanned,
                name: id,
                displayName: name !== null && name !== void 0 ? name : id
            }, Object.keys(opts).length ? {
                opts
            } : {});
        }, {
            // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
            fn: (_, fn, ...input)=>fn(...input)
        });
    };
    /**
     * Define the set of tools the user has access to for their step functions.
     *
     * Each key is the function name and is expected to run `createTool` and pass
     * a generic type for that function as it will appear in the user's code.
     */ const tools = {
        /**
         * Send one or many events to Inngest. Should always be used in place of
         * `inngest.send()` to ensure that the event send is successfully retried
         * and not sent multiple times due to memoisation.
         *
         * @example
         * ```ts
         * await step.sendEvent("emit-user-creation", {
         *   name: "app/user.created",
         *   data: { id: 123 },
         * });
         *
         * await step.sendEvent("emit-user-updates", [
         *   {
         *     name: "app/user.created",
         *     data: { id: 123 },
         *   },
         *   {
         *     name: "app/user.feed.created",
         *     data: { id: 123 },
         *   },
         * ]);
         * ```
         *
         * Returns a promise that will resolve once the event has been sent.
         */ sendEvent: createTool(({ id, name })=>{
            return {
                id,
                op: types_js_1.StepOpCode.StepPlanned,
                name: "sendEvent",
                displayName: name !== null && name !== void 0 ? name : id
            };
        }, {
            fn: (idOrOptions, payload)=>{
                return client["_send"]({
                    payload,
                    headers: execution["options"]["headers"]
                });
            }
        }),
        /**
         * Wait for a particular event to be received before continuing. When the
         * event is received, it will be returned.
         *
         * You can also provide options to control the particular event that is
         * received, for example to ensure that a user ID matches between two
         * events, or to only wait a maximum amount of time before giving up and
         * returning `null` instead of any event data.
         */ waitForEvent: createTool(({ id, name }, /**
         * Options to control the event we're waiting for.
         */ opts)=>{
            const matchOpts = {
                timeout: (0, strings_js_1.timeStr)(typeof opts === "string" ? opts : opts.timeout)
            };
            if (typeof opts !== "string") {
                if (opts === null || opts === void 0 ? void 0 : opts.match) {
                    matchOpts.if = `event.${opts.match} == async.${opts.match}`;
                } else if (opts === null || opts === void 0 ? void 0 : opts.if) {
                    matchOpts.if = opts.if;
                }
            }
            return {
                id,
                op: types_js_1.StepOpCode.WaitForEvent,
                name: opts.event,
                opts: matchOpts,
                displayName: name !== null && name !== void 0 ? name : id
            };
        }),
        /**
         * Use this tool to run business logic. Each call to `run` will be retried
         * individually, meaning you can compose complex workflows that safely
         * retry dependent asynchronous actions.
         *
         * The function you pass to `run` will be called only when this "step" is to
         * be executed and can be synchronous or asynchronous.
         *
         * In either case, the return value of the function will be the return value
         * of the `run` tool, meaning you can return and reason about return data
         * for next steps.
         */ run: createStepRun(),
        /**
         * AI tooling for running AI models and other AI-related tasks.
         */ ai: {
            /**
             * Use this tool to have Inngest make your AI calls. Useful for agentic workflows.
             *
             * Input is also tracked for this tool, meaning you can pass input to the
             * function and it will be displayed and editable in the UI.
             */ infer: createTool(({ id, name }, options)=>{
                var _a, _b;
                const modelCopy = Object.assign({}, options.model);
                // Allow the model to mutate options and body for this call
                (_b = (_a = options.model).onCall) === null || _b === void 0 ? void 0 : _b.call(_a, modelCopy, options.body);
                return {
                    id,
                    op: types_js_1.StepOpCode.AiGateway,
                    displayName: name !== null && name !== void 0 ? name : id,
                    opts: {
                        type: "step.ai.infer",
                        url: modelCopy.url,
                        headers: modelCopy.headers,
                        auth_key: modelCopy.authKey,
                        format: modelCopy.format,
                        body: options.body
                    }
                };
            }),
            /**
             * Use this tool to wrap AI models and other AI-related tasks. Each call
             * to `wrap` will be retried individually, meaning you can compose complex
             * workflows that safely retry dependent asynchronous actions.
             *
             * Input is also tracked for this tool, meaning you can pass input to the
             * function and it will be displayed and editable in the UI.
             */ wrap: createStepRun("step.ai.wrap"),
            /**
             * Models for AI inference and other AI-related tasks.
             */ models: {
                /**
                 * Create an OpenAI model using the OpenAI chat format.
                 *
                 * By default it targets the `https://api.openai.com/v1/` base URL.
                 */ openai: ai_1.openai,
                /**
                 * Create a Gemini model using the OpenAI chat format.
                 *
                 * By default it targets the `https://generativelanguage.googleapis.com/v1beta/`
                 * base URL.
                 */ gemini: ai_1.gemini
            }
        },
        /**
         * Wait a specified amount of time before continuing.
         *
         * The time to wait can be specified using a `number` of milliseconds or an
         * `ms`-compatible time string like `"1 hour"`, `"30 mins"`, or `"2.5d"`.
         *
         * {@link https://npm.im/ms}
         *
         * To wait until a particular date, use `sleepUntil` instead.
         */ sleep: createTool(({ id, name }, time)=>{
            /**
             * The presence of this operation in the returned stack indicates that the
             * sleep is over and we should continue execution.
             */ return {
                id,
                op: types_js_1.StepOpCode.Sleep,
                name: (0, strings_js_1.timeStr)(time),
                displayName: name !== null && name !== void 0 ? name : id
            };
        }),
        /**
         * Wait until a particular date before continuing by passing a `Date`.
         *
         * To wait for a particular amount of time from now, always use `sleep`
         * instead.
         */ sleepUntil: createTool(({ id, name }, time)=>{
            const date = typeof time === "string" ? new Date(time) : time;
            /**
             * The presence of this operation in the returned stack indicates that the
             * sleep is over and we should continue execution.
             */ try {
                return {
                    id,
                    op: types_js_1.StepOpCode.Sleep,
                    name: date.toISOString(),
                    displayName: name !== null && name !== void 0 ? name : id
                };
            } catch (err) {
                /**
                 * If we're here, it's because the date is invalid. We'll throw a custom
                 * error here to standardise this response.
                 */ // TODO PrettyError
                console.warn("Invalid date or date string passed to sleepUntil;", err);
                // TODO PrettyError
                throw new Error(`Invalid date or date string passed to sleepUntil: ${time.toString()}`);
            }
        }),
        /**
         * Invoke a passed Inngest `function` with the given `data`. Returns the
         * result of the returned value of the function or `null` if the function
         * does not return a value.
         *
         * A string ID can also be passed to reference functions outside of the
         * current app.
         */ invoke: createTool(({ id, name }, invokeOpts)=>{
            // Create a discriminated union to operate on based on the input types
            // available for this tool.
            const optsSchema = exports.invokePayloadSchema.extend({
                timeout: zod_1.z.union([
                    zod_1.z.number(),
                    zod_1.z.string(),
                    zod_1.z.date()
                ]).optional()
            });
            const parsedFnOpts = optsSchema.extend({
                _type: zod_1.z.literal("fullId").optional().default("fullId"),
                function: zod_1.z.string().min(1)
            }).or(optsSchema.extend({
                _type: zod_1.z.literal("fnInstance").optional().default("fnInstance"),
                function: zod_1.z.instanceof(InngestFunction_js_1.InngestFunction)
            })).or(optsSchema.extend({
                _type: zod_1.z.literal("refInstance").optional().default("refInstance"),
                function: zod_1.z.instanceof(InngestFunctionReference_js_1.InngestFunctionReference)
            })).safeParse(invokeOpts);
            if (!parsedFnOpts.success) {
                throw new Error(`Invalid invocation options passed to invoke; must include either a function or functionId.`);
            }
            const { _type, function: fn, data, user, v, timeout } = parsedFnOpts.data;
            const payload = {
                data,
                user,
                v
            };
            const opts = {
                payload,
                function_id: "",
                timeout: typeof timeout === "undefined" ? undefined : (0, strings_js_1.timeStr)(timeout)
            };
            switch(_type){
                case "fnInstance":
                    opts.function_id = fn.id(fn["client"].id);
                    break;
                case "fullId":
                    console.warn(`${consts_js_1.logPrefix} Invoking function with \`function: string\` is deprecated and will be removed in v4.0.0; use an imported function or \`referenceFunction()\` instead. See https://innge.st/ts-referencing-functions`);
                    opts.function_id = fn;
                    break;
                case "refInstance":
                    opts.function_id = [
                        fn.opts.appId || client.id,
                        fn.opts.functionId
                    ].filter(Boolean).join("-");
                    break;
            }
            return {
                id,
                op: types_js_1.StepOpCode.InvokeFunction,
                displayName: name !== null && name !== void 0 ? name : id,
                opts
            };
        })
    };
    return tools;
};
exports.createStepTools = createStepTools;
/**
 * The event payload portion of the options for `step.invoke()`. This does not
 * include non-payload options like `timeout` or the function to invoke.
 */ exports.invokePayloadSchema = zod_1.z.object({
    data: zod_1.z.record(zod_1.z.any()).optional(),
    user: zod_1.z.record(zod_1.z.any()).optional(),
    v: zod_1.z.string().optional()
}); //# sourceMappingURL=InngestStepTools.js.map
}}),
"[project]/node_modules/.pnpm/inngest@3.32.5_express@4.21.2_next@15.3.4_@opentelemetry+api@1.9.0_react-dom@19.2.0_rea_302ab31fd2a599b814fb517e8771719b/node_modules/inngest/components/RetryAfterError.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.RetryAfterError = void 0;
const ms_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/.pnpm/ms@2.1.3/node_modules/ms/index.js [app-route] (ecmascript)"));
/**
 * An error that, when thrown, indicates to Inngest that the function should be
 * retried after a given amount of time.
 *
 * A `message` must be provided, as well as a `retryAfter` parameter, which can
 * be a `number` of milliseconds, an `ms`-compatible time string, or a `Date`.
 *
 * An optional `cause` can be provided to provide more context to the error.
 *
 * @public
 */ class RetryAfterError extends Error {
    constructor(message, /**
     * The time after which the function should be retried. Represents either a
     * number of milliseconds or a RFC3339 date.
     */ retryAfter, options){
        super(message);
        if (retryAfter instanceof Date) {
            this.retryAfter = retryAfter.toISOString();
        } else {
            const seconds = `${Math.ceil((typeof retryAfter === "string" ? (0, ms_1.default)(retryAfter) : retryAfter) / 1000)}`;
            if (!isFinite(Number(seconds))) {
                throw new Error("retryAfter must be a number of milliseconds, a ms-compatible string, or a Date");
            }
            this.retryAfter = seconds;
        }
        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
        this.cause = options === null || options === void 0 ? void 0 : options.cause;
    }
}
exports.RetryAfterError = RetryAfterError; //# sourceMappingURL=RetryAfterError.js.map
}}),
"[project]/node_modules/.pnpm/inngest@3.32.5_express@4.21.2_next@15.3.4_@opentelemetry+api@1.9.0_react-dom@19.2.0_rea_302ab31fd2a599b814fb517e8771719b/node_modules/inngest/components/execution/v0.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var __rest = this && this.__rest || function(s, e) {
    var t = {};
    for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function") for(var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++){
        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
    }
    return t;
};
var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports._internals = exports.V0InngestExecution = exports.createV0InngestExecution = void 0;
const canonicalize_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/.pnpm/canonicalize@1.0.8/node_modules/canonicalize/lib/canonicalize.js [app-route] (ecmascript)"));
const hash_js_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash.js [app-route] (ecmascript)");
const zod_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/zod@3.22.5/node_modules/zod/lib/index.js [app-route] (ecmascript)");
const errors_js_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/inngest@3.32.5_express@4.21.2_next@15.3.4_@opentelemetry+api@1.9.0_react-dom@19.2.0_rea_302ab31fd2a599b814fb517e8771719b/node_modules/inngest/helpers/errors.js [app-route] (ecmascript)");
const functions_js_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/inngest@3.32.5_express@4.21.2_next@15.3.4_@opentelemetry+api@1.9.0_react-dom@19.2.0_rea_302ab31fd2a599b814fb517e8771719b/node_modules/inngest/helpers/functions.js [app-route] (ecmascript)");
const promises_js_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/inngest@3.32.5_express@4.21.2_next@15.3.4_@opentelemetry+api@1.9.0_react-dom@19.2.0_rea_302ab31fd2a599b814fb517e8771719b/node_modules/inngest/helpers/promises.js [app-route] (ecmascript)");
const types_js_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/inngest@3.32.5_express@4.21.2_next@15.3.4_@opentelemetry+api@1.9.0_react-dom@19.2.0_rea_302ab31fd2a599b814fb517e8771719b/node_modules/inngest/types.js [app-route] (ecmascript)");
const InngestMiddleware_js_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/inngest@3.32.5_express@4.21.2_next@15.3.4_@opentelemetry+api@1.9.0_react-dom@19.2.0_rea_302ab31fd2a599b814fb517e8771719b/node_modules/inngest/components/InngestMiddleware.js [app-route] (ecmascript)");
const InngestStepTools_js_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/inngest@3.32.5_express@4.21.2_next@15.3.4_@opentelemetry+api@1.9.0_react-dom@19.2.0_rea_302ab31fd2a599b814fb517e8771719b/node_modules/inngest/components/InngestStepTools.js [app-route] (ecmascript)");
const NonRetriableError_js_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/inngest@3.32.5_express@4.21.2_next@15.3.4_@opentelemetry+api@1.9.0_react-dom@19.2.0_rea_302ab31fd2a599b814fb517e8771719b/node_modules/inngest/components/NonRetriableError.js [app-route] (ecmascript)");
const RetryAfterError_js_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/inngest@3.32.5_express@4.21.2_next@15.3.4_@opentelemetry+api@1.9.0_react-dom@19.2.0_rea_302ab31fd2a599b814fb517e8771719b/node_modules/inngest/components/RetryAfterError.js [app-route] (ecmascript)");
const InngestExecution_js_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/inngest@3.32.5_express@4.21.2_next@15.3.4_@opentelemetry+api@1.9.0_react-dom@19.2.0_rea_302ab31fd2a599b814fb517e8771719b/node_modules/inngest/components/execution/InngestExecution.js [app-route] (ecmascript)");
const createV0InngestExecution = (options)=>{
    return new V0InngestExecution(options);
};
exports.createV0InngestExecution = createV0InngestExecution;
class V0InngestExecution extends InngestExecution_js_1.InngestExecution {
    constructor(options){
        super(options);
        this.userFnToRun = this.getUserFnToRun();
        this.state = this.createExecutionState();
        this.fnArg = this.createFnArg();
    }
    start() {
        var _a;
        this.debug("starting V0 execution");
        return (_a = this.execution) !== null && _a !== void 0 ? _a : this.execution = this._start().then((result)=>{
            this.debug("result:", result);
            return result;
        });
    }
    async _start() {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x;
        this.state.hooks = await this.initializeMiddleware();
        try {
            await this.transformInput();
            await ((_b = (_a = this.state.hooks).beforeMemoization) === null || _b === void 0 ? void 0 : _b.call(_a));
            if (this.state.opStack.length === 0 && !this.options.requestedRunStep) {
                await ((_d = (_c = this.state.hooks).afterMemoization) === null || _d === void 0 ? void 0 : _d.call(_c));
                await ((_f = (_e = this.state.hooks).beforeExecution) === null || _f === void 0 ? void 0 : _f.call(_e));
            }
            const userFnPromise = (0, promises_js_1.runAsPromise)(()=>this.userFnToRun(this.fnArg));
            let pos = -1;
            do {
                if (pos >= 0) {
                    if (!this.options.requestedRunStep && pos === this.state.opStack.length - 1) {
                        await ((_h = (_g = this.state.hooks).afterMemoization) === null || _h === void 0 ? void 0 : _h.call(_g));
                        await ((_k = (_j = this.state.hooks).beforeExecution) === null || _k === void 0 ? void 0 : _k.call(_j));
                    }
                    this.state.tickOps = {};
                    const incomingOp = this.state.opStack[pos];
                    this.state.currentOp = this.state.allFoundOps[incomingOp.id];
                    if (!this.state.currentOp) {
                        /**
                         * We're trying to resume the function, but we can't find where to go.
                         *
                         * This means that either the function has changed or there are async
                         * actions in-between steps that we haven't noticed in previous
                         * executions.
                         *
                         * Whichever the case, this is bad and we can't continue in this
                         * undefined state.
                         */ throw new NonRetriableError_js_1.NonRetriableError((0, errors_js_1.prettyError)({
                            whatHappened: " Your function was stopped from running",
                            why: "We couldn't resume your function's state because it may have changed since the run started or there are async actions in-between steps that we haven't noticed in previous executions.",
                            consequences: "Continuing to run the function may result in unexpected behaviour, so we've stopped your function to ensure nothing unexpected happened!",
                            toFixNow: "Ensure that your function is either entirely step-based or entirely non-step-based, by either wrapping all asynchronous logic in `step.run()` calls or by removing all `step.*()` calls.",
                            otherwise: "For more information on why step functions work in this manner, see https://www.inngest.com/docs/functions/multi-step#gotchas",
                            stack: true,
                            code: errors_js_1.ErrCode.NON_DETERMINISTIC_FUNCTION
                        }));
                    }
                    this.state.currentOp.fulfilled = true;
                    if (typeof incomingOp.data !== "undefined") {
                        this.state.currentOp.resolve(incomingOp.data);
                    } else {
                        this.state.currentOp.reject(incomingOp.error);
                    }
                }
                await (0, promises_js_1.resolveAfterPending)();
                this.state.reset();
                pos++;
            }while (pos < this.state.opStack.length)
            await ((_m = (_l = this.state.hooks).afterMemoization) === null || _m === void 0 ? void 0 : _m.call(_l));
            const discoveredOps = Object.values(this.state.tickOps).map(tickOpToOutgoing);
            const runStep = this.options.requestedRunStep || this.getEarlyExecRunStep(discoveredOps);
            if (runStep) {
                const userFnOp = this.state.allFoundOps[runStep];
                const stepToRun = userFnOp === null || userFnOp === void 0 ? void 0 : userFnOp.fn;
                if (!stepToRun) {
                    throw new Error(`Bad stack; executor requesting to run unknown step "${runStep}"`);
                }
                const outgoingUserFnOp = Object.assign(Object.assign({}, tickOpToOutgoing(userFnOp)), {
                    op: types_js_1.StepOpCode.Step
                });
                await ((_p = (_o = this.state.hooks).beforeExecution) === null || _p === void 0 ? void 0 : _p.call(_o));
                this.state.executingStep = true;
                const result = await (0, promises_js_1.runAsPromise)(stepToRun).finally(()=>{
                    this.state.executingStep = false;
                }).catch(async (error)=>{
                    return await this.transformOutput({
                        error
                    }, outgoingUserFnOp);
                }).then(async (data)=>{
                    var _a, _b;
                    await ((_b = (_a = this.state.hooks) === null || _a === void 0 ? void 0 : _a.afterExecution) === null || _b === void 0 ? void 0 : _b.call(_a));
                    return await this.transformOutput({
                        data
                    }, outgoingUserFnOp);
                });
                const { type: _type } = result, rest = __rest(result, [
                    "type"
                ]);
                return {
                    type: "step-ran",
                    ctx: this.fnArg,
                    ops: this.ops,
                    step: Object.assign(Object.assign({}, outgoingUserFnOp), rest)
                };
            }
            if (!discoveredOps.length) {
                const fnRet = await Promise.race([
                    userFnPromise.then((data)=>({
                            type: "complete",
                            data
                        })),
                    (0, promises_js_1.resolveNextTick)().then(()=>({
                            type: "incomplete"
                        }))
                ]);
                if (fnRet.type === "complete") {
                    await ((_r = (_q = this.state.hooks).afterExecution) === null || _r === void 0 ? void 0 : _r.call(_q));
                    const allOpsFulfilled = Object.values(this.state.allFoundOps).every((op)=>{
                        return op.fulfilled;
                    });
                    if (allOpsFulfilled) {
                        return await this.transformOutput({
                            data: fnRet.data
                        });
                    }
                } else if (!this.state.hasUsedTools) {
                    this.state.nonStepFnDetected = true;
                    const data = await userFnPromise;
                    await ((_t = (_s = this.state.hooks).afterExecution) === null || _t === void 0 ? void 0 : _t.call(_s));
                    return await this.transformOutput({
                        data
                    });
                } else {
                    const hasOpsPending = Object.values(this.state.allFoundOps).some((op)=>{
                        return op.fulfilled === false;
                    });
                    if (!hasOpsPending) {
                        throw new NonRetriableError_js_1.NonRetriableError((0, errors_js_1.functionStoppedRunningErr)(errors_js_1.ErrCode.ASYNC_DETECTED_AFTER_MEMOIZATION));
                    }
                }
            }
            await ((_v = (_u = this.state.hooks).afterExecution) === null || _v === void 0 ? void 0 : _v.call(_u));
            return {
                type: "steps-found",
                ctx: this.fnArg,
                ops: this.ops,
                steps: discoveredOps
            };
        } catch (error) {
            return await this.transformOutput({
                error
            });
        } finally{
            await ((_x = (_w = this.state.hooks).beforeResponse) === null || _x === void 0 ? void 0 : _x.call(_w));
        }
    }
    async initializeMiddleware() {
        const ctx = this.options.data;
        const hooks = await (0, InngestMiddleware_js_1.getHookStack)(this.options.fn["middleware"], "onFunctionRun", {
            ctx,
            fn: this.options.fn,
            steps: Object.values(this.options.stepState),
            reqArgs: this.options.reqArgs
        }, {
            transformInput: (prev, output)=>{
                return {
                    ctx: Object.assign(Object.assign({}, prev.ctx), output === null || output === void 0 ? void 0 : output.ctx),
                    fn: this.options.fn,
                    steps: prev.steps.map((step, i)=>{
                        var _a;
                        return Object.assign(Object.assign({}, step), (_a = output === null || output === void 0 ? void 0 : output.steps) === null || _a === void 0 ? void 0 : _a[i]);
                    }),
                    reqArgs: prev.reqArgs
                };
            },
            transformOutput: (prev, output)=>{
                return {
                    result: Object.assign(Object.assign({}, prev.result), output === null || output === void 0 ? void 0 : output.result),
                    step: prev.step
                };
            }
        });
        return hooks;
    }
    createExecutionState() {
        const state = {
            allFoundOps: {},
            tickOps: {},
            tickOpHashes: {},
            currentOp: undefined,
            hasUsedTools: false,
            reset: ()=>{
                state.tickOpHashes = {};
                state.allFoundOps = Object.assign(Object.assign({}, state.allFoundOps), state.tickOps);
            },
            nonStepFnDetected: false,
            executingStep: false,
            opStack: this.options.stepCompletionOrder.reduce((acc, stepId)=>{
                const stepState = this.options.stepState[stepId];
                if (!stepState) {
                    return acc;
                }
                return [
                    ...acc,
                    stepState
                ];
            }, [])
        };
        return state;
    }
    get ops() {
        return Object.fromEntries(Object.entries(this.state.allFoundOps).map(([id, op])=>[
                id,
                {
                    id: op.id,
                    rawArgs: op.rawArgs,
                    data: op.data,
                    error: op.error,
                    fulfilled: op.fulfilled,
                    seen: true
                }
            ]));
    }
    getUserFnToRun() {
        if (!this.options.isFailureHandler) {
            return this.options.fn["fn"];
        }
        if (!this.options.fn["onFailureFn"]) {
            /**
             * Somehow, we've ended up detecting that this is a failure handler but
             * doesn't have an `onFailure` function. This should never happen.
             */ throw new Error("Cannot find function `onFailure` handler");
        }
        // TODO: Review; inferred types results in an `any` here!
        return this.options.fn["onFailureFn"];
    }
    createFnArg() {
        var _a, _b, _c, _d;
        // Start referencing everything
        this.state.tickOps = this.state.allFoundOps;
        /**
         * Create a unique hash of an operation using only a subset of the operation's
         * properties; will never use `data` and will guarantee the order of the
         * object so we don't rely on individual tools for that.
         *
         * If the operation already contains an ID, the current ID will be used
         * instead, so that users can provide their own IDs.
         */ const hashOp = (/**
         * The op to generate a hash from. We only use a subset of the op's
         * properties when creating the hash.
         */ op)=>{
            var _a, _b, _c, _d;
            /**
             * It's difficult for v0 to understand whether or not an op has
             * historically contained a custom ID, as all step usage now require them.
             *
             * For this reason, we make the assumption that steps in v0 do not have a
             * custom ID and generate one for them as we would in all recommendations
             * and examples.
             */ const obj = {
                parent: (_b = (_a = this.state.currentOp) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : null,
                op: op.op,
                name: op.name,
                // Historically, no v0 runs could have options for `step.run()` call,
                // but this object can be specified in future versions.
                //
                // For this purpose, we change this to always use `null` if the op is
                // that of a `step.run()`.
                opts: op.op === types_js_1.StepOpCode.StepPlanned ? null : (_c = op.opts) !== null && _c !== void 0 ? _c : null
            };
            const collisionHash = exports._internals.hashData(obj);
            const pos = this.state.tickOpHashes[collisionHash] = ((_d = this.state.tickOpHashes[collisionHash]) !== null && _d !== void 0 ? _d : -1) + 1;
            return Object.assign(Object.assign({}, op), {
                id: exports._internals.hashData(Object.assign({
                    pos
                }, obj))
            });
        };
        const stepHandler = ({ args, matchOp, opts })=>{
            if (this.state.nonStepFnDetected) {
                throw new NonRetriableError_js_1.NonRetriableError((0, errors_js_1.functionStoppedRunningErr)(errors_js_1.ErrCode.STEP_USED_AFTER_ASYNC));
            }
            if (this.state.executingStep) {
                throw new NonRetriableError_js_1.NonRetriableError((0, errors_js_1.prettyError)({
                    whatHappened: "Your function was stopped from running",
                    why: "We detected that you have nested `step.*` tooling.",
                    consequences: "Nesting `step.*` tooling is not supported.",
                    stack: true,
                    toFixNow: "Make sure you're not using `step.*` tooling inside of other `step.*` tooling. If you need to compose steps together, you can create a new async function and call it from within your step function, or use promise chaining.",
                    otherwise: "For more information on step functions with Inngest, see https://www.inngest.com/docs/functions/multi-step",
                    code: errors_js_1.ErrCode.NESTING_STEPS
                }));
            }
            this.state.hasUsedTools = true;
            const stepOptions = (0, InngestStepTools_js_1.getStepOptions)(args[0]);
            const opId = hashOp(matchOp(stepOptions, ...args.slice(1)));
            return new Promise((resolve, reject)=>{
                this.state.tickOps[opId.id] = Object.assign(Object.assign(Object.assign({}, opId), (opts === null || opts === void 0 ? void 0 : opts.fn) ? {
                    fn: ()=>{
                        var _a;
                        return (_a = opts.fn) === null || _a === void 0 ? void 0 : _a.call(opts, ...args);
                    }
                } : {}), {
                    rawArgs: args,
                    resolve,
                    reject,
                    fulfilled: false
                });
            });
        };
        const step = (0, InngestStepTools_js_1.createStepTools)(this.options.client, this, stepHandler);
        let fnArg = Object.assign(Object.assign({}, this.options.data), {
            step
        });
        if (this.options.isFailureHandler) {
            const eventData = zod_1.z.object({
                error: types_js_1.jsonErrorSchema
            }).parse((_a = fnArg.event) === null || _a === void 0 ? void 0 : _a.data);
            fnArg = Object.assign(Object.assign({}, fnArg), {
                error: (0, errors_js_1.deserializeError)(eventData.error)
            });
        }
        return (_d = (_c = (_b = this.options).transformCtx) === null || _c === void 0 ? void 0 : _c.call(_b, fnArg)) !== null && _d !== void 0 ? _d : fnArg;
    }
    /**
     * Using middleware, transform input before running.
     */ async transformInput() {
        var _a, _b;
        const inputMutations = await ((_b = (_a = this.state.hooks) === null || _a === void 0 ? void 0 : _a.transformInput) === null || _b === void 0 ? void 0 : _b.call(_a, {
            ctx: Object.assign({}, this.fnArg),
            steps: Object.values(this.options.stepState),
            fn: this.options.fn,
            reqArgs: this.options.reqArgs
        }));
        if (inputMutations === null || inputMutations === void 0 ? void 0 : inputMutations.ctx) {
            this.fnArg = inputMutations.ctx;
        }
        if (inputMutations === null || inputMutations === void 0 ? void 0 : inputMutations.steps) {
            this.state.opStack = [
                ...inputMutations.steps
            ];
        }
    }
    getEarlyExecRunStep(ops) {
        if (ops.length !== 1) return;
        const op = ops[0];
        if (op && op.op === types_js_1.StepOpCode.StepPlanned) {
            return op.id;
        }
    }
    /**
     * Using middleware, transform output before returning.
     */ async transformOutput(dataOrError, step) {
        var _a, _b, _c, _d;
        const output = Object.assign({}, dataOrError);
        if (typeof output.error !== "undefined") {
            output.data = (0, errors_js_1.serializeError)(output.error);
        }
        const transformedOutput = await ((_b = (_a = this.state.hooks) === null || _a === void 0 ? void 0 : _a.transformOutput) === null || _b === void 0 ? void 0 : _b.call(_a, {
            result: Object.assign({}, output),
            step
        }));
        const { data, error } = Object.assign(Object.assign({}, output), transformedOutput === null || transformedOutput === void 0 ? void 0 : transformedOutput.result);
        if (!step) {
            await ((_d = (_c = this.state.hooks) === null || _c === void 0 ? void 0 : _c.finished) === null || _d === void 0 ? void 0 : _d.call(_c, {
                result: Object.assign({}, typeof error !== "undefined" ? {
                    error
                } : {
                    data
                })
            }));
        }
        if (typeof error !== "undefined") {
            /**
             * Ensure we give middleware the chance to decide on retriable behaviour
             * by looking at the error returned from output transformation.
             */ let retriable = !(error instanceof NonRetriableError_js_1.NonRetriableError);
            if (retriable && error instanceof RetryAfterError_js_1.RetryAfterError) {
                retriable = error.retryAfter;
            }
            const serializedError = (0, errors_js_1.serializeError)(error);
            return {
                type: "function-rejected",
                ctx: this.fnArg,
                ops: this.ops,
                error: serializedError,
                retriable
            };
        }
        return {
            type: "function-resolved",
            ctx: this.fnArg,
            ops: this.ops,
            data: (0, functions_js_1.undefinedToNull)(data)
        };
    }
}
exports.V0InngestExecution = V0InngestExecution;
const tickOpToOutgoing = (op)=>{
    return {
        op: op.op,
        id: op.id,
        name: op.name,
        opts: op.opts
    };
};
const hashData = (op)=>{
    return (0, hash_js_1.sha1)().update((0, canonicalize_1.default)(op)).digest("hex");
};
/**
 * Exported for testing.
 */ exports._internals = {
    hashData
}; //# sourceMappingURL=v0.js.map
}}),
"[project]/node_modules/.pnpm/inngest@3.32.5_express@4.21.2_next@15.3.4_@opentelemetry+api@1.9.0_react-dom@19.2.0_rea_302ab31fd2a599b814fb517e8771719b/node_modules/inngest/components/StepError.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.StepError = void 0;
const errors_js_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/inngest@3.32.5_express@4.21.2_next@15.3.4_@opentelemetry+api@1.9.0_react-dom@19.2.0_rea_302ab31fd2a599b814fb517e8771719b/node_modules/inngest/helpers/errors.js [app-route] (ecmascript)");
const types_js_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/inngest@3.32.5_express@4.21.2_next@15.3.4_@opentelemetry+api@1.9.0_react-dom@19.2.0_rea_302ab31fd2a599b814fb517e8771719b/node_modules/inngest/types.js [app-route] (ecmascript)");
/**
 * An error that represents a step exhausting all retries and failing. This is
 * thrown by an Inngest step if it fails.
 *
 * It's synonymous with an `Error`, with the addition of the `stepId` that
 * failed.
 *
 * @public
 */ class StepError extends Error {
    constructor(/**
     * The ID of the step that failed.
     */ stepId, err){
        var _a;
        const parsedErr = types_js_1.jsonErrorSchema.parse(err);
        super(parsedErr.message);
        this.stepId = stepId;
        this.name = parsedErr.name;
        this.stepId = stepId;
        // Don't show the internal stack trace if we don't have one.
        this.stack = (_a = parsedErr.stack) !== null && _a !== void 0 ? _a : undefined;
        // Try setting the cause if we have one
        this.cause = parsedErr.cause ? (0, errors_js_1.deserializeError)(parsedErr.cause) : undefined;
    }
}
exports.StepError = StepError; //# sourceMappingURL=StepError.js.map
}}),
"[project]/node_modules/.pnpm/inngest@3.32.5_express@4.21.2_next@15.3.4_@opentelemetry+api@1.9.0_react-dom@19.2.0_rea_302ab31fd2a599b814fb517e8771719b/node_modules/inngest/components/execution/als.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = this && this.__importStar || function() {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o) {
            var ar = [];
            for(var k in o)if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
            for(var k = ownKeys(mod), i = 0; i < k.length; i++)if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
    };
}();
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.getAsyncLocalStorage = exports.getAsyncCtx = void 0;
/**
 * A local-only symbol used as a key in global state to store the async local
 * storage instance.
 */ const alsSymbol = Symbol.for("inngest:als");
/**
 * Retrieve the async context for the current execution.
 */ const getAsyncCtx = async ()=>{
    return (0, exports.getAsyncLocalStorage)().then((als)=>als.getStore());
};
exports.getAsyncCtx = getAsyncCtx;
/**
 * Get a singleton instance of `AsyncLocalStorage` used to store and retrieve
 * async context for the current execution.
 */ const getAsyncLocalStorage = async ()=>{
    var _a;
    var _b;
    (_a = (_b = globalThis)[alsSymbol]) !== null && _a !== void 0 ? _a : _b[alsSymbol] = new Promise(// eslint-disable-next-line @typescript-eslint/no-misused-promises, no-async-promise-executor
    async (resolve)=>{
        try {
            const { AsyncLocalStorage } = await Promise.resolve().then(()=>__importStar(__turbopack_context__.r("[externals]/node:async_hooks [external] (node:async_hooks, cjs)")));
            resolve(new AsyncLocalStorage());
        } catch (err) {
            console.warn("node:async_hooks is not supported in this runtime. Experimental async context is disabled.");
            resolve({
                getStore: ()=>undefined,
                run: (_, fn)=>fn()
            });
        }
    });
    return globalThis[alsSymbol];
};
exports.getAsyncLocalStorage = getAsyncLocalStorage; //# sourceMappingURL=als.js.map
}}),
"[project]/node_modules/.pnpm/inngest@3.32.5_express@4.21.2_next@15.3.4_@opentelemetry+api@1.9.0_react-dom@19.2.0_rea_302ab31fd2a599b814fb517e8771719b/node_modules/inngest/components/execution/v1.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var __asyncValues = this && this.__asyncValues || function(o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
        return this;
    }, i);
    "TURBOPACK unreachable";
    function verb(n) {
        i[n] = o[n] && function(v) {
            return new Promise(function(resolve, reject) {
                v = o[n](v), settle(resolve, reject, v.done, v.value);
            });
        };
    }
    function settle(resolve, reject, d, v) {
        Promise.resolve(v).then(function(v) {
            resolve({
                value: v,
                done: d
            });
        }, reject);
    }
};
var __await = this && this.__await || function(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
};
var __asyncGenerator = this && this.__asyncGenerator || function(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i[Symbol.asyncIterator] = function() {
        return this;
    }, i;
    "TURBOPACK unreachable";
    function awaitReturn(f) {
        return function(v) {
            return Promise.resolve(v).then(f, reject);
        };
    }
    function verb(n, f) {
        if (g[n]) {
            i[n] = function(v) {
                return new Promise(function(a, b) {
                    q.push([
                        n,
                        v,
                        a,
                        b
                    ]) > 1 || resume(n, v);
                });
            };
            if (f) i[n] = f(i[n]);
        }
    }
    function resume(n, v) {
        try {
            step(g[n](v));
        } catch (e) {
            settle(q[0][3], e);
        }
    }
    function step(r) {
        r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
    }
    function fulfill(value) {
        resume("next", value);
    }
    function reject(value) {
        resume("throw", value);
    }
    function settle(f, v) {
        if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
    }
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports._internals = exports.createV1InngestExecution = void 0;
const hash_js_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash.js [app-route] (ecmascript)");
const zod_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/zod@3.22.5/node_modules/zod/lib/index.js [app-route] (ecmascript)");
const consts_js_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/inngest@3.32.5_express@4.21.2_next@15.3.4_@opentelemetry+api@1.9.0_react-dom@19.2.0_rea_302ab31fd2a599b814fb517e8771719b/node_modules/inngest/helpers/consts.js [app-route] (ecmascript)");
const errors_js_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/inngest@3.32.5_express@4.21.2_next@15.3.4_@opentelemetry+api@1.9.0_react-dom@19.2.0_rea_302ab31fd2a599b814fb517e8771719b/node_modules/inngest/helpers/errors.js [app-route] (ecmascript)");
const functions_js_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/inngest@3.32.5_express@4.21.2_next@15.3.4_@opentelemetry+api@1.9.0_react-dom@19.2.0_rea_302ab31fd2a599b814fb517e8771719b/node_modules/inngest/helpers/functions.js [app-route] (ecmascript)");
const promises_js_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/inngest@3.32.5_express@4.21.2_next@15.3.4_@opentelemetry+api@1.9.0_react-dom@19.2.0_rea_302ab31fd2a599b814fb517e8771719b/node_modules/inngest/helpers/promises.js [app-route] (ecmascript)");
const types_js_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/inngest@3.32.5_express@4.21.2_next@15.3.4_@opentelemetry+api@1.9.0_react-dom@19.2.0_rea_302ab31fd2a599b814fb517e8771719b/node_modules/inngest/types.js [app-route] (ecmascript)");
const InngestMiddleware_js_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/inngest@3.32.5_express@4.21.2_next@15.3.4_@opentelemetry+api@1.9.0_react-dom@19.2.0_rea_302ab31fd2a599b814fb517e8771719b/node_modules/inngest/components/InngestMiddleware.js [app-route] (ecmascript)");
const InngestStepTools_js_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/inngest@3.32.5_express@4.21.2_next@15.3.4_@opentelemetry+api@1.9.0_react-dom@19.2.0_rea_302ab31fd2a599b814fb517e8771719b/node_modules/inngest/components/InngestStepTools.js [app-route] (ecmascript)");
const NonRetriableError_js_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/inngest@3.32.5_express@4.21.2_next@15.3.4_@opentelemetry+api@1.9.0_react-dom@19.2.0_rea_302ab31fd2a599b814fb517e8771719b/node_modules/inngest/components/NonRetriableError.js [app-route] (ecmascript)");
const RetryAfterError_js_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/inngest@3.32.5_express@4.21.2_next@15.3.4_@opentelemetry+api@1.9.0_react-dom@19.2.0_rea_302ab31fd2a599b814fb517e8771719b/node_modules/inngest/components/RetryAfterError.js [app-route] (ecmascript)");
const StepError_js_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/inngest@3.32.5_express@4.21.2_next@15.3.4_@opentelemetry+api@1.9.0_react-dom@19.2.0_rea_302ab31fd2a599b814fb517e8771719b/node_modules/inngest/components/StepError.js [app-route] (ecmascript)");
const InngestExecution_js_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/inngest@3.32.5_express@4.21.2_next@15.3.4_@opentelemetry+api@1.9.0_react-dom@19.2.0_rea_302ab31fd2a599b814fb517e8771719b/node_modules/inngest/components/execution/InngestExecution.js [app-route] (ecmascript)");
const als_js_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/inngest@3.32.5_express@4.21.2_next@15.3.4_@opentelemetry+api@1.9.0_react-dom@19.2.0_rea_302ab31fd2a599b814fb517e8771719b/node_modules/inngest/components/execution/als.js [app-route] (ecmascript)");
const createV1InngestExecution = (options)=>{
    return new V1InngestExecution(options);
};
exports.createV1InngestExecution = createV1InngestExecution;
class V1InngestExecution extends InngestExecution_js_1.InngestExecution {
    constructor(options){
        super(options);
        this.timeoutDuration = 1000 * 10;
        this.userFnToRun = this.getUserFnToRun();
        this.state = this.createExecutionState();
        this.fnArg = this.createFnArg();
        this.checkpointHandlers = this.createCheckpointHandlers();
        this.initializeTimer(this.state);
        this.debug("created new V1 execution for run;", this.options.requestedRunStep ? `wanting to run step "${this.options.requestedRunStep}"` : "discovering steps");
        this.debug("existing state keys:", Object.keys(this.state.stepState));
    }
    /**
     * Idempotently start the execution of the user's function.
     */ start() {
        if (!this.execution) {
            this.debug("starting V1 execution");
            this.execution = (0, als_js_1.getAsyncLocalStorage)().then((als)=>{
                return als.run({
                    ctx: this.fnArg
                }, async ()=>{
                    return this._start().then((result)=>{
                        this.debug("result:", result);
                        return result;
                    });
                });
            });
        }
        return this.execution;
    }
    /**
     * Starts execution of the user's function and the core loop.
     */ async _start() {
        var _a, e_1, _b, _c;
        var _d, _e;
        try {
            const allCheckpointHandler = this.getCheckpointHandler("");
            this.state.hooks = await this.initializeMiddleware();
            await this.startExecution();
            try {
                for(var _f = true, _g = __asyncValues(this.state.loop), _h; _h = await _g.next(), _a = _h.done, !_a; _f = true){
                    _c = _h.value;
                    _f = false;
                    const checkpoint = _c;
                    await allCheckpointHandler(checkpoint);
                    const handler = this.getCheckpointHandler(checkpoint.type);
                    const result = await handler(checkpoint);
                    if (result) {
                        return result;
                    }
                }
            } catch (e_1_1) {
                e_1 = {
                    error: e_1_1
                };
            } finally{
                try {
                    if (!_f && !_a && (_b = _g.return)) await _b.call(_g);
                } finally{
                    if (e_1) throw e_1.error;
                }
            }
        } catch (error) {
            return await this.transformOutput({
                error
            });
        } finally{
            void this.state.loop.return();
            await ((_e = (_d = this.state.hooks) === null || _d === void 0 ? void 0 : _d.beforeResponse) === null || _e === void 0 ? void 0 : _e.call(_d));
        }
        /**
         * If we're here, the generator somehow finished without returning a value.
         * This should never happen.
         */ throw new Error("Core loop finished without returning a value");
    }
    /**
     * Creates a handler for every checkpoint type, defining what to do when we
     * reach that checkpoint in the core loop.
     */ createCheckpointHandlers() {
        return {
            /**
             * Run for all checkpoints. Best used for logging or common actions.
             * Use other handlers to return values and interrupt the core loop.
             */ "": (checkpoint)=>{
                this.debug("checkpoint:", checkpoint);
            },
            /**
             * The user's function has completed and returned a value.
             */ "function-resolved": async (checkpoint)=>{
                return await this.transformOutput({
                    data: checkpoint.data
                });
            },
            /**
             * The user's function has thrown an error.
             */ "function-rejected": async (checkpoint)=>{
                return await this.transformOutput({
                    error: checkpoint.error
                });
            },
            /**
             * We've found one or more steps. Here we may want to run a step or report
             * them back to Inngest.
             */ "steps-found": async ({ steps })=>{
                const stepResult = await this.tryExecuteStep(steps);
                if (stepResult) {
                    const transformResult = await this.transformOutput(stepResult);
                    /**
                     * Transforming output will always return either function rejection or
                     * resolution. In most cases, this can be immediately returned, but in
                     * this particular case we want to handle it differently.
                     */ if (transformResult.type === "function-resolved") {
                        return {
                            type: "step-ran",
                            ctx: transformResult.ctx,
                            ops: transformResult.ops,
                            step: exports._internals.hashOp(Object.assign(Object.assign({}, stepResult), {
                                data: transformResult.data
                            }))
                        };
                    } else if (transformResult.type === "function-rejected") {
                        return {
                            type: "step-ran",
                            ctx: transformResult.ctx,
                            ops: transformResult.ops,
                            step: exports._internals.hashOp(Object.assign(Object.assign({}, stepResult), {
                                error: transformResult.error
                            })),
                            retriable: transformResult.retriable
                        };
                    }
                    return transformResult;
                }
                const newSteps = await this.filterNewSteps(Array.from(this.state.steps.values()));
                if (newSteps) {
                    return {
                        type: "steps-found",
                        ctx: this.fnArg,
                        ops: this.ops,
                        steps: newSteps
                    };
                }
            },
            /**
             * While trying to find a step that Inngest has told us to run, we've
             * timed out or have otherwise decided that it doesn't exist.
             */ "step-not-found": ({ step })=>{
                return {
                    type: "step-not-found",
                    ctx: this.fnArg,
                    ops: this.ops,
                    step
                };
            }
        };
    }
    getCheckpointHandler(type) {
        return this.checkpointHandlers[type];
    }
    async tryExecuteStep(steps) {
        var _a;
        const hashedStepIdToRun = this.options.requestedRunStep || this.getEarlyExecRunStep(steps);
        if (!hashedStepIdToRun) {
            return;
        }
        const step = steps.find((step)=>step.hashedId === hashedStepIdToRun && step.fn);
        if (step) {
            return await this.executeStep(step);
        }
        /**
         * Ensure we reset the timeout if we have a requested run step but couldn't
         * find it, but also that we don't reset if we found and executed it.
         */ void ((_a = this.timeout) === null || _a === void 0 ? void 0 : _a.reset());
    }
    /**
     * Given a list of outgoing ops, decide if we can execute an op early and
     * return the ID of the step to execute if we can.
     */ getEarlyExecRunStep(steps) {
        /**
         * We may have been disabled due to parallelism, in which case we can't
         * immediately execute unless explicitly requested.
         */ if (this.options.disableImmediateExecution) return;
        const unfulfilledSteps = steps.filter((step)=>!step.fulfilled);
        if (unfulfilledSteps.length !== 1) return;
        const op = unfulfilledSteps[0];
        if (op && op.op === types_js_1.StepOpCode.StepPlanned) {
            return op.hashedId;
        }
    }
    async filterNewSteps(foundSteps) {
        var _a, _b, _c, _d, _e, _f;
        if (this.options.requestedRunStep) {
            return;
        }
        /**
         * Gather any steps that aren't memoized and report them.
         */ const newSteps = foundSteps.filter((step)=>!step.fulfilled);
        if (!newSteps.length) {
            return;
        }
        /**
         * Warn if we've found new steps but haven't yet seen all previous
         * steps. This may indicate that step presence isn't determinate.
         */ let knownSteps = 0;
        for (const step of foundSteps){
            if (step.fulfilled) {
                knownSteps++;
            }
        }
        const foundAllCompletedSteps = this.state.stepsToFulfill === knownSteps;
        if (!foundAllCompletedSteps) {
            // TODO Tag
            console.warn((0, errors_js_1.prettyError)({
                type: "warn",
                whatHappened: "Function may be indeterminate",
                why: "We found new steps before seeing all previous steps, which may indicate that the function is non-deterministic.",
                consequences: "This may cause unexpected behaviour as Inngest executes your function.",
                reassurance: "This is expected if a function is updated in the middle of a run, but may indicate a bug if not."
            }));
        }
        /**
         * We're finishing up; let's trigger the last of the hooks.
         */ await ((_b = (_a = this.state.hooks) === null || _a === void 0 ? void 0 : _a.afterMemoization) === null || _b === void 0 ? void 0 : _b.call(_a));
        await ((_d = (_c = this.state.hooks) === null || _c === void 0 ? void 0 : _c.beforeExecution) === null || _d === void 0 ? void 0 : _d.call(_c));
        await ((_f = (_e = this.state.hooks) === null || _e === void 0 ? void 0 : _e.afterExecution) === null || _f === void 0 ? void 0 : _f.call(_e));
        const stepList = newSteps.map((step)=>({
                displayName: step.displayName,
                op: step.op,
                id: step.hashedId,
                name: step.name,
                opts: step.opts
            }));
        /**
         * We also run `onSendEvent` middleware hooks against `step.invoke()` steps
         * to ensure that their `data` is transformed correctly.
         */ return await this.transformNewSteps(stepList);
    }
    /**
     * Using middleware, transform any newly-found steps before returning them to
     * an Inngest Server.
     */ async transformNewSteps(steps) {
        return Promise.all(steps.map(async (step)=>{
            var _a, _b, _c, _d, _e, _f, _g;
            if (step.op !== types_js_1.StepOpCode.InvokeFunction) {
                return step;
            }
            const onSendEventHooks = await (0, InngestMiddleware_js_1.getHookStack)(this.options.fn["middleware"], "onSendEvent", undefined, {
                transformInput: (prev, output)=>{
                    return Object.assign(Object.assign({}, prev), output);
                },
                transformOutput: (prev, output)=>{
                    return {
                        result: Object.assign(Object.assign({}, prev.result), output === null || output === void 0 ? void 0 : output.result)
                    };
                }
            });
            /**
             * For each event being sent, create a new `onSendEvent` hook stack to
             * process it. We do this as middleware hooks are intended to run once
             * during each lifecycle (onFunctionRun or onSendEvent) and here, a hook
             * is run for every single event.
             *
             * This is done because a developer can use this hook to filter out
             * events entirely; if we batch all of the events together, we can't
             * tell which ones were filtered out if we're processing >1 invocation
             * here.
             */ const transformedPayload = await ((_a = onSendEventHooks.transformInput) === null || _a === void 0 ? void 0 : _a.call(onSendEventHooks, {
                payloads: [
                    Object.assign(Object.assign({}, (_c = (_b = step.opts) === null || _b === void 0 ? void 0 : _b.payload) !== null && _c !== void 0 ? _c : {}), {
                        name: consts_js_1.internalEvents.FunctionInvoked
                    })
                ]
            }));
            const newPayload = InngestStepTools_js_1.invokePayloadSchema.parse((_e = (_d = transformedPayload === null || transformedPayload === void 0 ? void 0 : transformedPayload.payloads) === null || _d === void 0 ? void 0 : _d[0]) !== null && _e !== void 0 ? _e : {});
            return Object.assign(Object.assign({}, step), {
                opts: Object.assign(Object.assign({}, step.opts), {
                    payload: Object.assign(Object.assign({}, (_g = (_f = step.opts) === null || _f === void 0 ? void 0 : _f.payload) !== null && _g !== void 0 ? _g : {}), newPayload)
                })
            });
        }));
    }
    async executeStep({ id, name, opts, fn, displayName }) {
        var _a, _b, _c, _d, _e;
        (_a = this.timeout) === null || _a === void 0 ? void 0 : _a.clear();
        await ((_c = (_b = this.state.hooks) === null || _b === void 0 ? void 0 : _b.afterMemoization) === null || _c === void 0 ? void 0 : _c.call(_b));
        await ((_e = (_d = this.state.hooks) === null || _d === void 0 ? void 0 : _d.beforeExecution) === null || _e === void 0 ? void 0 : _e.call(_d));
        const outgoingOp = {
            id,
            op: types_js_1.StepOpCode.StepRun,
            name,
            opts,
            displayName
        };
        this.state.executingStep = outgoingOp;
        this.debug(`executing step "${id}"`);
        return (0, promises_js_1.runAsPromise)(fn)// eslint-disable-next-line @typescript-eslint/no-misused-promises
        .finally(async ()=>{
            var _a, _b;
            await ((_b = (_a = this.state.hooks) === null || _a === void 0 ? void 0 : _a.afterExecution) === null || _b === void 0 ? void 0 : _b.call(_a));
        }).then((data)=>{
            return Object.assign(Object.assign({}, outgoingOp), {
                data
            });
        }).catch((error)=>{
            return Object.assign(Object.assign({}, outgoingOp), {
                op: types_js_1.StepOpCode.StepError,
                // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
                error
            });
        });
    }
    /**
     * Starts execution of the user's function, including triggering checkpoints
     * and middleware hooks where appropriate.
     */ async startExecution() {
        var _a, _b, _c, _d, _e, _f, _g;
        /**
         * Mutate input as neccessary based on middleware.
         */ await this.transformInput();
        /**
         * Start the timer to time out the run if needed.
         */ void ((_a = this.timeout) === null || _a === void 0 ? void 0 : _a.start());
        await ((_c = (_b = this.state.hooks) === null || _b === void 0 ? void 0 : _b.beforeMemoization) === null || _c === void 0 ? void 0 : _c.call(_b));
        /**
         * If we had no state to begin with, immediately end the memoization phase.
         */ if (this.state.allStateUsed()) {
            await ((_e = (_d = this.state.hooks) === null || _d === void 0 ? void 0 : _d.afterMemoization) === null || _e === void 0 ? void 0 : _e.call(_d));
            await ((_g = (_f = this.state.hooks) === null || _f === void 0 ? void 0 : _f.beforeExecution) === null || _g === void 0 ? void 0 : _g.call(_f));
        }
        /**
         * Trigger the user's function.
         */ (0, promises_js_1.runAsPromise)(()=>this.userFnToRun(this.fnArg))// eslint-disable-next-line @typescript-eslint/no-misused-promises
        .finally(async ()=>{
            var _a, _b, _c, _d, _e, _f;
            await ((_b = (_a = this.state.hooks) === null || _a === void 0 ? void 0 : _a.afterMemoization) === null || _b === void 0 ? void 0 : _b.call(_a));
            await ((_d = (_c = this.state.hooks) === null || _c === void 0 ? void 0 : _c.beforeExecution) === null || _d === void 0 ? void 0 : _d.call(_c));
            await ((_f = (_e = this.state.hooks) === null || _e === void 0 ? void 0 : _e.afterExecution) === null || _f === void 0 ? void 0 : _f.call(_e));
        }).then((data)=>{
            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
            this.state.setCheckpoint({
                type: "function-resolved",
                data
            });
        }).catch((error)=>{
            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
            this.state.setCheckpoint({
                type: "function-rejected",
                error
            });
        });
    }
    /**
     * Using middleware, transform input before running.
     */ async transformInput() {
        var _a, _b;
        const inputMutations = await ((_b = (_a = this.state.hooks) === null || _a === void 0 ? void 0 : _a.transformInput) === null || _b === void 0 ? void 0 : _b.call(_a, {
            ctx: Object.assign({}, this.fnArg),
            steps: Object.values(this.state.stepState),
            fn: this.options.fn,
            reqArgs: this.options.reqArgs
        }));
        if (inputMutations === null || inputMutations === void 0 ? void 0 : inputMutations.ctx) {
            this.fnArg = inputMutations.ctx;
        }
        if (inputMutations === null || inputMutations === void 0 ? void 0 : inputMutations.steps) {
            this.state.stepState = Object.fromEntries(inputMutations.steps.map((step)=>[
                    step.id,
                    step
                ]));
        }
    }
    /**
     * Using middleware, transform output before returning.
     */ async transformOutput(dataOrError) {
        var _a, _b, _c, _d;
        const output = Object.assign({}, dataOrError);
        /**
         * If we've been given an error and it's one that we just threw from a step,
         * we should return a `NonRetriableError` to stop execution.
         */ if (typeof output.error !== "undefined") {
            output.data = (0, errors_js_1.serializeError)(output.error);
        }
        const isStepExecution = Boolean(this.state.executingStep);
        const transformedOutput = await ((_b = (_a = this.state.hooks) === null || _a === void 0 ? void 0 : _a.transformOutput) === null || _b === void 0 ? void 0 : _b.call(_a, {
            result: Object.assign({}, output),
            step: this.state.executingStep
        }));
        const { data, error } = Object.assign(Object.assign({}, output), transformedOutput === null || transformedOutput === void 0 ? void 0 : transformedOutput.result);
        if (!isStepExecution) {
            await ((_d = (_c = this.state.hooks) === null || _c === void 0 ? void 0 : _c.finished) === null || _d === void 0 ? void 0 : _d.call(_c, {
                result: Object.assign({}, typeof error !== "undefined" ? {
                    error
                } : {
                    data
                })
            }));
        }
        if (typeof error !== "undefined") {
            /**
             * Ensure we give middleware the chance to decide on retriable behaviour
             * by looking at the error returned from output transformation.
             */ let retriable = !(error instanceof NonRetriableError_js_1.NonRetriableError || error instanceof StepError_js_1.StepError);
            if (retriable && error instanceof RetryAfterError_js_1.RetryAfterError) {
                retriable = error.retryAfter;
            }
            const serializedError = (0, errors_js_1.minifyPrettyError)((0, errors_js_1.serializeError)(error));
            return {
                type: "function-rejected",
                ctx: this.fnArg,
                ops: this.ops,
                error: serializedError,
                retriable
            };
        }
        return {
            type: "function-resolved",
            ctx: this.fnArg,
            ops: this.ops,
            data: (0, functions_js_1.undefinedToNull)(data)
        };
    }
    createExecutionState() {
        const d = (0, promises_js_1.createDeferredPromiseWithStack)();
        let checkpointResolve = d.deferred.resolve;
        const checkpointResults = d.results;
        const loop = function(cleanUp) {
            return __asyncGenerator(this, arguments, function*() {
                try {
                    while(true){
                        const res = (yield __await(checkpointResults.next())).value;
                        if (res) {
                            yield yield __await(res);
                        }
                    }
                } finally{
                    cleanUp === null || cleanUp === void 0 ? void 0 : cleanUp();
                }
            });
        }(()=>{
            var _a;
            (_a = this.timeout) === null || _a === void 0 ? void 0 : _a.clear();
            void checkpointResults.return();
        });
        const stepsToFulfill = Object.keys(this.options.stepState).length;
        const state = {
            stepState: this.options.stepState,
            stepsToFulfill,
            steps: new Map(),
            loop,
            hasSteps: Boolean(stepsToFulfill),
            stepCompletionOrder: [
                ...this.options.stepCompletionOrder
            ],
            remainingStepsToBeSeen: new Set(this.options.stepCompletionOrder),
            setCheckpoint: (checkpoint)=>{
                ({ resolve: checkpointResolve } = checkpointResolve(checkpoint));
            },
            allStateUsed: ()=>{
                return this.state.remainingStepsToBeSeen.size === 0;
            }
        };
        return state;
    }
    get ops() {
        return Object.fromEntries(this.state.steps);
    }
    createFnArg() {
        var _a, _b, _c, _d;
        const step = this.createStepTools();
        let fnArg = Object.assign(Object.assign({}, this.options.data), {
            step
        });
        /**
         * Handle use of the `onFailure` option by deserializing the error.
         */ if (this.options.isFailureHandler) {
            const eventData = zod_1.z.object({
                error: types_js_1.jsonErrorSchema
            }).parse((_a = fnArg.event) === null || _a === void 0 ? void 0 : _a.data);
            fnArg = Object.assign(Object.assign({}, fnArg), {
                error: (0, errors_js_1.deserializeError)(eventData.error)
            });
        }
        return (_d = (_c = (_b = this.options).transformCtx) === null || _c === void 0 ? void 0 : _c.call(_b, fnArg)) !== null && _d !== void 0 ? _d : fnArg;
    }
    createStepTools() {
        /**
         * A list of steps that have been found and are being rolled up before being
         * reported to the core loop.
         */ const foundStepsToReport = new Map();
        /**
         * A map of the subset of found steps to report that have not yet been
         * handled. Used for fast access to steps that need to be handled in order.
         */ const unhandledFoundStepsToReport = new Map();
        /**
         * A map of the latest sequential step indexes found for each step ID. Used
         * to ensure that we don't index steps in parallel.
         *
         * Note that these must be sequential; if we've seen or assigned `a:1`,
         * `a:2` and `a:4`, the latest sequential step index is `2`.
         *
         */ const expectedNextStepIndexes = new Map();
        /**
         * An ordered list of step IDs that have yet to be handled in this
         * execution. Used to ensure that we handle steps in the order they were
         * found and based on the `stepCompletionOrder` in this execution's state.
         */ const remainingStepCompletionOrder = this.state.stepCompletionOrder.slice();
        /**
         * A promise that's used to ensure that step reporting cannot be run more than
         * once in a given asynchronous time span.
         */ let foundStepsReportPromise;
        /**
         * A promise that's used to represent middleware hooks running before
         * execution.
         */ let beforeExecHooksPromise;
        /**
         * A flag used to ensure that we only warn about parallel indexing once per
         * execution to avoid spamming the console.
         */ let warnOfParallelIndexing = false;
        /**
         * Counts the number of times we've extended this tick.
         */ let tickExtensionCount = 0;
        /**
         * Given a colliding step ID, maybe warn the user about parallel indexing.
         */ const maybeWarnOfParallelIndexing = (collisionId)=>{
            if (warnOfParallelIndexing) {
                return;
            }
            const stepExists = this.state.steps.has(collisionId);
            if (stepExists) {
                const stepFoundThisTick = foundStepsToReport.has(collisionId);
                if (!stepFoundThisTick) {
                    warnOfParallelIndexing = true;
                    console.warn((0, errors_js_1.prettyError)({
                        type: "warn",
                        whatHappened: "We detected that you have multiple steps with the same ID.",
                        code: errors_js_1.ErrCode.AUTOMATIC_PARALLEL_INDEXING,
                        why: `This can happen if you're using the same ID for multiple steps across different chains of parallel work. We found the issue with step "${collisionId}".`,
                        reassurance: "Your function is still running, though it may exhibit unexpected behaviour.",
                        consequences: "Using the same IDs across parallel chains of work can cause unexpected behaviour.",
                        toFixNow: "We recommend using a unique ID for each step, especially those happening in parallel."
                    }));
                }
            }
        };
        /**
         * A helper used to report steps to the core loop. Used after adding an item
         * to `foundStepsToReport`.
         */ const reportNextTick = ()=>{
            // Being explicit instead of using `??=` to appease TypeScript.
            if (foundStepsReportPromise) {
                return;
            }
            let extensionPromise;
            if (++tickExtensionCount >= 10) {
                tickExtensionCount = 0;
                extensionPromise = new Promise((resolve)=>setTimeout(resolve));
            } else {
                extensionPromise = (0, promises_js_1.resolveAfterPending)();
            }
            foundStepsReportPromise = extensionPromise/**
                 * Ensure that we wait for this promise to resolve before continuing.
                 *
                 * The groups in which steps are reported can affect how we detect some
                 * more complex determinism issues like parallel indexing. This promise
                 * can represent middleware hooks being run early, in the middle of
                 * ingesting steps to report.
                 *
                 * Because of this, it's important we wait for this middleware to resolve
                 * before continuing to report steps to ensure that all steps have a
                 * chance to be reported throughout this asynchronous action.
                 */ .then(()=>beforeExecHooksPromise).then(()=>{
                var _a;
                foundStepsReportPromise = undefined;
                for(let i = 0; i < remainingStepCompletionOrder.length; i++){
                    const nextStepId = remainingStepCompletionOrder[i];
                    if (!nextStepId) {
                        continue;
                    }
                    const handled = (_a = unhandledFoundStepsToReport.get(nextStepId)) === null || _a === void 0 ? void 0 : _a.handle();
                    if (handled) {
                        remainingStepCompletionOrder.splice(i, 1);
                        unhandledFoundStepsToReport.delete(nextStepId);
                        return void reportNextTick();
                    }
                }
                // If we've handled no steps in this "tick," roll up everything we've
                // found and report it.
                const steps = [
                    ...foundStepsToReport.values()
                ];
                foundStepsToReport.clear();
                unhandledFoundStepsToReport.clear();
                return void this.state.setCheckpoint({
                    type: "steps-found",
                    steps: steps
                });
            });
        };
        /**
         * A helper used to push a step to the list of steps to report.
         */ const pushStepToReport = (step)=>{
            foundStepsToReport.set(step.id, step);
            unhandledFoundStepsToReport.set(step.hashedId, step);
            reportNextTick();
        };
        const stepHandler = async ({ args, matchOp, opts })=>{
            var _a, _b, _c, _d;
            await beforeExecHooksPromise;
            const stepOptions = (0, InngestStepTools_js_1.getStepOptions)(args[0]);
            const opId = matchOp(stepOptions, ...args.slice(1));
            if (this.state.executingStep) {
                /**
                 * If a step is found after asynchronous actions during another step's
                 * execution, everything is fine. The problem here is if we've found
                 * that a step nested inside another a step, which is something we don't
                 * support at the time of writing.
                 *
                 * In this case, we could use something like Async Hooks to understand
                 * how the step is being triggered, though this isn't available in all
                 * environments.
                 *
                 * Therefore, we'll only show a warning here to indicate that this is
                 * potentially an issue.
                 */ console.warn((0, errors_js_1.prettyError)({
                    whatHappened: `We detected that you have nested \`step.*\` tooling in \`${(_a = opId.displayName) !== null && _a !== void 0 ? _a : opId.id}\``,
                    consequences: "Nesting `step.*` tooling is not supported.",
                    type: "warn",
                    reassurance: "It's possible to see this warning if steps are separated by regular asynchronous calls, which is fine.",
                    stack: true,
                    toFixNow: "Make sure you're not using `step.*` tooling inside of other `step.*` tooling. If you need to compose steps together, you can create a new async function and call it from within your step function, or use promise chaining.",
                    code: errors_js_1.ErrCode.NESTING_STEPS
                }));
            }
            if (this.state.steps.has(opId.id)) {
                const originalId = opId.id;
                maybeWarnOfParallelIndexing(originalId);
                const expectedNextIndex = (_b = expectedNextStepIndexes.get(originalId)) !== null && _b !== void 0 ? _b : 1;
                for(let i = expectedNextIndex;; i++){
                    const newId = originalId + InngestStepTools_js_1.STEP_INDEXING_SUFFIX + i;
                    if (!this.state.steps.has(newId)) {
                        expectedNextStepIndexes.set(originalId, i + 1);
                        opId.id = newId;
                        break;
                    }
                }
            }
            const { promise, resolve, reject } = (0, promises_js_1.createDeferredPromise)();
            const hashedId = exports._internals.hashId(opId.id);
            const stepState = this.state.stepState[hashedId];
            let isFulfilled = false;
            if (stepState) {
                stepState.seen = true;
                this.state.remainingStepsToBeSeen.delete(hashedId);
                if (typeof stepState.input === "undefined") {
                    isFulfilled = true;
                }
            }
            let extraOpts;
            let fnArgs = [
                ...args
            ];
            if (typeof (stepState === null || stepState === void 0 ? void 0 : stepState.input) !== "undefined" && Array.isArray(stepState.input)) {
                switch(opId.op){
                    // `step.run()` has its function input affected
                    case types_js_1.StepOpCode.StepPlanned:
                        {
                            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
                            fnArgs = [
                                ...args.slice(0, 2),
                                ...stepState.input
                            ];
                            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
                            extraOpts = {
                                input: [
                                    ...stepState.input
                                ]
                            };
                            break;
                        }
                    // `step.ai.infer()` has its body affected
                    case types_js_1.StepOpCode.AiGateway:
                        {
                            extraOpts = {
                                body: Object.assign(Object.assign({}, typeof ((_c = opId.opts) === null || _c === void 0 ? void 0 : _c.body) === "object" ? Object.assign({}, opId.opts.body) : {}), stepState.input[0])
                            };
                            break;
                        }
                }
            }
            const step = Object.assign(Object.assign({}, opId), {
                opts: Object.assign(Object.assign({}, opId.opts), extraOpts),
                rawArgs: fnArgs,
                hashedId,
                input: stepState === null || stepState === void 0 ? void 0 : stepState.input,
                // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
                fn: (opts === null || opts === void 0 ? void 0 : opts.fn) ? ()=>{
                    var _a;
                    return (_a = opts.fn) === null || _a === void 0 ? void 0 : _a.call(opts, ...fnArgs);
                } : undefined,
                promise,
                fulfilled: isFulfilled,
                hasStepState: Boolean(stepState),
                displayName: (_d = opId.displayName) !== null && _d !== void 0 ? _d : opId.id,
                handled: false,
                handle: ()=>{
                    if (step.handled) {
                        return false;
                    }
                    step.handled = true;
                    if (isFulfilled && stepState) {
                        stepState.fulfilled = true;
                        // For some execution scenarios such as testing, `data`, `error`,
                        // and `input` may be `Promises`. This could also be the case for
                        // future middleware applications. For this reason, we'll make sure
                        // the values are fully resolved before continuing.
                        void Promise.all([
                            stepState.data,
                            stepState.error,
                            stepState.input
                        ]).then(()=>{
                            if (typeof stepState.data !== "undefined") {
                                resolve(stepState.data);
                            } else {
                                this.state.recentlyRejectedStepError = new StepError_js_1.StepError(opId.id, stepState.error);
                                reject(this.state.recentlyRejectedStepError);
                            }
                        });
                    }
                    return true;
                }
            });
            this.state.steps.set(opId.id, step);
            this.state.hasSteps = true;
            pushStepToReport(step);
            /**
             * If this is the last piece of state we had, we've now finished
             * memoizing.
             */ if (!beforeExecHooksPromise && this.state.allStateUsed()) {
                await (beforeExecHooksPromise = (async ()=>{
                    var _a, _b, _c, _d;
                    await ((_b = (_a = this.state.hooks) === null || _a === void 0 ? void 0 : _a.afterMemoization) === null || _b === void 0 ? void 0 : _b.call(_a));
                    await ((_d = (_c = this.state.hooks) === null || _c === void 0 ? void 0 : _c.beforeExecution) === null || _d === void 0 ? void 0 : _d.call(_c));
                })());
            }
            return promise;
        };
        return (0, InngestStepTools_js_1.createStepTools)(this.options.client, this, stepHandler);
    }
    getUserFnToRun() {
        if (!this.options.isFailureHandler) {
            return this.options.fn["fn"];
        }
        if (!this.options.fn["onFailureFn"]) {
            /**
             * Somehow, we've ended up detecting that this is a failure handler but
             * doesn't have an `onFailure` function. This should never happen.
             */ throw new Error("Cannot find function `onFailure` handler");
        }
        return this.options.fn["onFailureFn"];
    }
    initializeTimer(state) {
        if (!this.options.requestedRunStep) {
            return;
        }
        this.timeout = (0, promises_js_1.createTimeoutPromise)(this.timeoutDuration);
        void this.timeout.then(async ()=>{
            var _a, _b, _c, _d, _e, _f;
            await ((_b = (_a = this.state.hooks) === null || _a === void 0 ? void 0 : _a.afterMemoization) === null || _b === void 0 ? void 0 : _b.call(_a));
            await ((_d = (_c = this.state.hooks) === null || _c === void 0 ? void 0 : _c.beforeExecution) === null || _d === void 0 ? void 0 : _d.call(_c));
            await ((_f = (_e = this.state.hooks) === null || _e === void 0 ? void 0 : _e.afterExecution) === null || _f === void 0 ? void 0 : _f.call(_e));
            state.setCheckpoint({
                type: "step-not-found",
                step: {
                    id: this.options.requestedRunStep,
                    op: types_js_1.StepOpCode.StepNotFound
                }
            });
        });
    }
    async initializeMiddleware() {
        const ctx = this.options.data;
        const hooks = await (0, InngestMiddleware_js_1.getHookStack)(this.options.fn["middleware"], "onFunctionRun", {
            ctx,
            fn: this.options.fn,
            steps: Object.values(this.options.stepState),
            reqArgs: this.options.reqArgs
        }, {
            transformInput: (prev, output)=>{
                return {
                    ctx: Object.assign(Object.assign({}, prev.ctx), output === null || output === void 0 ? void 0 : output.ctx),
                    fn: this.options.fn,
                    steps: prev.steps.map((step, i)=>{
                        var _a;
                        return Object.assign(Object.assign({}, step), (_a = output === null || output === void 0 ? void 0 : output.steps) === null || _a === void 0 ? void 0 : _a[i]);
                    }),
                    reqArgs: prev.reqArgs
                };
            },
            transformOutput: (prev, output)=>{
                return {
                    result: Object.assign(Object.assign({}, prev.result), output === null || output === void 0 ? void 0 : output.result),
                    step: prev.step
                };
            }
        });
        return hooks;
    }
}
const hashId = (id)=>{
    return (0, hash_js_1.sha1)().update(id).digest("hex");
};
const hashOp = (op)=>{
    return Object.assign(Object.assign({}, op), {
        id: hashId(op.id)
    });
};
/**
 * Exported for testing.
 */ exports._internals = {
    hashOp,
    hashId
}; //# sourceMappingURL=v1.js.map
}}),
"[project]/node_modules/.pnpm/inngest@3.32.5_express@4.21.2_next@15.3.4_@opentelemetry+api@1.9.0_react-dom@19.2.0_rea_302ab31fd2a599b814fb517e8771719b/node_modules/inngest/components/execution/v2.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var __asyncValues = this && this.__asyncValues || function(o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
        return this;
    }, i);
    "TURBOPACK unreachable";
    function verb(n) {
        i[n] = o[n] && function(v) {
            return new Promise(function(resolve, reject) {
                v = o[n](v), settle(resolve, reject, v.done, v.value);
            });
        };
    }
    function settle(resolve, reject, d, v) {
        Promise.resolve(v).then(function(v) {
            resolve({
                value: v,
                done: d
            });
        }, reject);
    }
};
var __await = this && this.__await || function(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
};
var __asyncGenerator = this && this.__asyncGenerator || function(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i[Symbol.asyncIterator] = function() {
        return this;
    }, i;
    "TURBOPACK unreachable";
    function awaitReturn(f) {
        return function(v) {
            return Promise.resolve(v).then(f, reject);
        };
    }
    function verb(n, f) {
        if (g[n]) {
            i[n] = function(v) {
                return new Promise(function(a, b) {
                    q.push([
                        n,
                        v,
                        a,
                        b
                    ]) > 1 || resume(n, v);
                });
            };
            if (f) i[n] = f(i[n]);
        }
    }
    function resume(n, v) {
        try {
            step(g[n](v));
        } catch (e) {
            settle(q[0][3], e);
        }
    }
    function step(r) {
        r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
    }
    function fulfill(value) {
        resume("next", value);
    }
    function reject(value) {
        resume("throw", value);
    }
    function settle(f, v) {
        if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
    }
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports._internals = exports.createV2InngestExecution = void 0;
const hash_js_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash.js [app-route] (ecmascript)");
const zod_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/zod@3.22.5/node_modules/zod/lib/index.js [app-route] (ecmascript)");
const consts_js_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/inngest@3.32.5_express@4.21.2_next@15.3.4_@opentelemetry+api@1.9.0_react-dom@19.2.0_rea_302ab31fd2a599b814fb517e8771719b/node_modules/inngest/helpers/consts.js [app-route] (ecmascript)");
const errors_js_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/inngest@3.32.5_express@4.21.2_next@15.3.4_@opentelemetry+api@1.9.0_react-dom@19.2.0_rea_302ab31fd2a599b814fb517e8771719b/node_modules/inngest/helpers/errors.js [app-route] (ecmascript)");
const functions_js_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/inngest@3.32.5_express@4.21.2_next@15.3.4_@opentelemetry+api@1.9.0_react-dom@19.2.0_rea_302ab31fd2a599b814fb517e8771719b/node_modules/inngest/helpers/functions.js [app-route] (ecmascript)");
const promises_js_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/inngest@3.32.5_express@4.21.2_next@15.3.4_@opentelemetry+api@1.9.0_react-dom@19.2.0_rea_302ab31fd2a599b814fb517e8771719b/node_modules/inngest/helpers/promises.js [app-route] (ecmascript)");
const types_js_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/inngest@3.32.5_express@4.21.2_next@15.3.4_@opentelemetry+api@1.9.0_react-dom@19.2.0_rea_302ab31fd2a599b814fb517e8771719b/node_modules/inngest/types.js [app-route] (ecmascript)");
const InngestMiddleware_js_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/inngest@3.32.5_express@4.21.2_next@15.3.4_@opentelemetry+api@1.9.0_react-dom@19.2.0_rea_302ab31fd2a599b814fb517e8771719b/node_modules/inngest/components/InngestMiddleware.js [app-route] (ecmascript)");
const InngestStepTools_js_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/inngest@3.32.5_express@4.21.2_next@15.3.4_@opentelemetry+api@1.9.0_react-dom@19.2.0_rea_302ab31fd2a599b814fb517e8771719b/node_modules/inngest/components/InngestStepTools.js [app-route] (ecmascript)");
const NonRetriableError_js_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/inngest@3.32.5_express@4.21.2_next@15.3.4_@opentelemetry+api@1.9.0_react-dom@19.2.0_rea_302ab31fd2a599b814fb517e8771719b/node_modules/inngest/components/NonRetriableError.js [app-route] (ecmascript)");
const RetryAfterError_js_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/inngest@3.32.5_express@4.21.2_next@15.3.4_@opentelemetry+api@1.9.0_react-dom@19.2.0_rea_302ab31fd2a599b814fb517e8771719b/node_modules/inngest/components/RetryAfterError.js [app-route] (ecmascript)");
const StepError_js_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/inngest@3.32.5_express@4.21.2_next@15.3.4_@opentelemetry+api@1.9.0_react-dom@19.2.0_rea_302ab31fd2a599b814fb517e8771719b/node_modules/inngest/components/StepError.js [app-route] (ecmascript)");
const InngestExecution_js_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/inngest@3.32.5_express@4.21.2_next@15.3.4_@opentelemetry+api@1.9.0_react-dom@19.2.0_rea_302ab31fd2a599b814fb517e8771719b/node_modules/inngest/components/execution/InngestExecution.js [app-route] (ecmascript)");
const als_js_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/inngest@3.32.5_express@4.21.2_next@15.3.4_@opentelemetry+api@1.9.0_react-dom@19.2.0_rea_302ab31fd2a599b814fb517e8771719b/node_modules/inngest/components/execution/als.js [app-route] (ecmascript)");
const createV2InngestExecution = (options)=>{
    return new V2InngestExecution(options);
};
exports.createV2InngestExecution = createV2InngestExecution;
class V2InngestExecution extends InngestExecution_js_1.InngestExecution {
    constructor(options){
        super(options);
        this.timeoutDuration = 1000 * 10;
        this.userFnToRun = this.getUserFnToRun();
        this.state = this.createExecutionState();
        this.fnArg = this.createFnArg();
        this.checkpointHandlers = this.createCheckpointHandlers();
        this.initializeTimer(this.state);
        this.debug("created new V2 execution for run;", this.options.requestedRunStep ? `wanting to run step "${this.options.requestedRunStep}"` : "discovering steps");
        this.debug("existing state keys:", Object.keys(this.state.stepState));
    }
    /**
     * Idempotently start the execution of the user's function.
     */ start() {
        if (!this.execution) {
            this.debug("starting V2 execution");
            this.execution = (0, als_js_1.getAsyncLocalStorage)().then((als)=>{
                return als.run({
                    ctx: this.fnArg
                }, async ()=>{
                    return this._start().then((result)=>{
                        this.debug("result:", result);
                        return result;
                    });
                });
            });
        }
        return this.execution;
    }
    /**
     * Starts execution of the user's function and the core loop.
     */ async _start() {
        var _a, e_1, _b, _c;
        var _d, _e;
        try {
            const allCheckpointHandler = this.getCheckpointHandler("");
            this.state.hooks = await this.initializeMiddleware();
            await this.startExecution();
            try {
                for(var _f = true, _g = __asyncValues(this.state.loop), _h; _h = await _g.next(), _a = _h.done, !_a; _f = true){
                    _c = _h.value;
                    _f = false;
                    const checkpoint = _c;
                    await allCheckpointHandler(checkpoint);
                    const handler = this.getCheckpointHandler(checkpoint.type);
                    const result = await handler(checkpoint);
                    if (result) {
                        return result;
                    }
                }
            } catch (e_1_1) {
                e_1 = {
                    error: e_1_1
                };
            } finally{
                try {
                    if (!_f && !_a && (_b = _g.return)) await _b.call(_g);
                } finally{
                    if (e_1) throw e_1.error;
                }
            }
        } catch (error) {
            return await this.transformOutput({
                error
            });
        } finally{
            void this.state.loop.return();
            await ((_e = (_d = this.state.hooks) === null || _d === void 0 ? void 0 : _d.beforeResponse) === null || _e === void 0 ? void 0 : _e.call(_d));
        }
        /**
         * If we're here, the generator somehow finished without returning a value.
         * This should never happen.
         */ throw new Error("Core loop finished without returning a value");
    }
    /**
     * Creates a handler for every checkpoint type, defining what to do when we
     * reach that checkpoint in the core loop.
     */ createCheckpointHandlers() {
        return {
            /**
             * Run for all checkpoints. Best used for logging or common actions.
             * Use other handlers to return values and interrupt the core loop.
             */ "": (checkpoint)=>{
                this.debug("checkpoint:", checkpoint);
            },
            /**
             * The user's function has completed and returned a value.
             */ "function-resolved": async (checkpoint)=>{
                return await this.transformOutput({
                    data: checkpoint.data
                });
            },
            /**
             * The user's function has thrown an error.
             */ "function-rejected": async (checkpoint)=>{
                return await this.transformOutput({
                    error: checkpoint.error
                });
            },
            /**
             * We've found one or more steps. Here we may want to run a step or report
             * them back to Inngest.
             */ "steps-found": async ({ steps })=>{
                const stepResult = await this.tryExecuteStep(steps);
                if (stepResult) {
                    const transformResult = await this.transformOutput(stepResult);
                    /**
                     * Transforming output will always return either function rejection or
                     * resolution. In most cases, this can be immediately returned, but in
                     * this particular case we want to handle it differently.
                     */ if (transformResult.type === "function-resolved") {
                        return {
                            type: "step-ran",
                            ctx: transformResult.ctx,
                            ops: transformResult.ops,
                            step: exports._internals.hashOp(Object.assign(Object.assign({}, stepResult), {
                                data: transformResult.data
                            }))
                        };
                    } else if (transformResult.type === "function-rejected") {
                        return {
                            type: "step-ran",
                            ctx: transformResult.ctx,
                            ops: transformResult.ops,
                            step: exports._internals.hashOp(Object.assign(Object.assign({}, stepResult), {
                                error: transformResult.error
                            })),
                            retriable: transformResult.retriable
                        };
                    }
                    return transformResult;
                }
                const newSteps = await this.filterNewSteps(Array.from(this.state.steps.values()));
                if (newSteps) {
                    return {
                        type: "steps-found",
                        ctx: this.fnArg,
                        ops: this.ops,
                        steps: newSteps
                    };
                }
            },
            /**
             * While trying to find a step that Inngest has told us to run, we've
             * timed out or have otherwise decided that it doesn't exist.
             */ "step-not-found": ({ step })=>{
                return {
                    type: "step-not-found",
                    ctx: this.fnArg,
                    ops: this.ops,
                    step
                };
            }
        };
    }
    getCheckpointHandler(type) {
        return this.checkpointHandlers[type];
    }
    async tryExecuteStep(steps) {
        var _a;
        const hashedStepIdToRun = this.options.requestedRunStep || this.getEarlyExecRunStep(steps);
        if (!hashedStepIdToRun) {
            return;
        }
        const step = steps.find((step)=>step.hashedId === hashedStepIdToRun && step.fn);
        if (step) {
            return await this.executeStep(step);
        }
        /**
         * Ensure we reset the timeout if we have a requested run step but couldn't
         * find it, but also that we don't reset if we found and executed it.
         */ void ((_a = this.timeout) === null || _a === void 0 ? void 0 : _a.reset());
    }
    /**
     * Given a list of outgoing ops, decide if we can execute an op early and
     * return the ID of the step to execute if we can.
     */ getEarlyExecRunStep(steps) {
        /**
         * We may have been disabled due to parallelism, in which case we can't
         * immediately execute unless explicitly requested.
         */ if (this.options.disableImmediateExecution) return;
        const unfulfilledSteps = steps.filter((step)=>!step.fulfilled);
        if (unfulfilledSteps.length !== 1) return;
        const op = unfulfilledSteps[0];
        if (op && op.op === types_js_1.StepOpCode.StepPlanned) {
            return op.hashedId;
        }
    }
    async filterNewSteps(foundSteps) {
        var _a, _b, _c, _d, _e, _f;
        if (this.options.requestedRunStep) {
            return;
        }
        /**
         * Gather any steps that aren't memoized and report them.
         */ const newSteps = foundSteps.filter((step)=>!step.fulfilled);
        if (!newSteps.length) {
            return;
        }
        /**
         * Warn if we've found new steps but haven't yet seen all previous
         * steps. This may indicate that step presence isn't determinate.
         */ let knownSteps = 0;
        for (const step of foundSteps){
            if (step.fulfilled) {
                knownSteps++;
            }
        }
        const foundAllCompletedSteps = this.state.stepsToFulfill === knownSteps;
        if (!foundAllCompletedSteps) {
            // TODO Tag
            console.warn((0, errors_js_1.prettyError)({
                type: "warn",
                whatHappened: "Function may be indeterminate",
                why: "We found new steps before seeing all previous steps, which may indicate that the function is non-deterministic.",
                consequences: "This may cause unexpected behaviour as Inngest executes your function.",
                reassurance: "This is expected if a function is updated in the middle of a run, but may indicate a bug if not."
            }));
        }
        /**
         * We're finishing up; let's trigger the last of the hooks.
         */ await ((_b = (_a = this.state.hooks) === null || _a === void 0 ? void 0 : _a.afterMemoization) === null || _b === void 0 ? void 0 : _b.call(_a));
        await ((_d = (_c = this.state.hooks) === null || _c === void 0 ? void 0 : _c.beforeExecution) === null || _d === void 0 ? void 0 : _d.call(_c));
        await ((_f = (_e = this.state.hooks) === null || _e === void 0 ? void 0 : _e.afterExecution) === null || _f === void 0 ? void 0 : _f.call(_e));
        const stepList = newSteps.map((step)=>({
                displayName: step.displayName,
                op: step.op,
                id: step.hashedId,
                name: step.name,
                opts: step.opts
            }));
        /**
         * We also run `onSendEvent` middleware hooks against `step.invoke()` steps
         * to ensure that their `data` is transformed correctly.
         */ return await this.transformNewSteps(stepList);
    }
    /**
     * Using middleware, transform any newly-found steps before returning them to
     * an Inngest Server.
     */ async transformNewSteps(steps) {
        return Promise.all(steps.map(async (step)=>{
            var _a, _b, _c, _d, _e, _f, _g;
            if (step.op !== types_js_1.StepOpCode.InvokeFunction) {
                return step;
            }
            const onSendEventHooks = await (0, InngestMiddleware_js_1.getHookStack)(this.options.fn["middleware"], "onSendEvent", undefined, {
                transformInput: (prev, output)=>{
                    return Object.assign(Object.assign({}, prev), output);
                },
                transformOutput: (prev, output)=>{
                    return {
                        result: Object.assign(Object.assign({}, prev.result), output === null || output === void 0 ? void 0 : output.result)
                    };
                }
            });
            /**
             * For each event being sent, create a new `onSendEvent` hook stack to
             * process it. We do this as middleware hooks are intended to run once
             * during each lifecycle (onFunctionRun or onSendEvent) and here, a hook
             * is run for every single event.
             *
             * This is done because a developer can use this hook to filter out
             * events entirely; if we batch all of the events together, we can't
             * tell which ones were filtered out if we're processing >1 invocation
             * here.
             */ const transformedPayload = await ((_a = onSendEventHooks.transformInput) === null || _a === void 0 ? void 0 : _a.call(onSendEventHooks, {
                payloads: [
                    Object.assign(Object.assign({}, (_c = (_b = step.opts) === null || _b === void 0 ? void 0 : _b.payload) !== null && _c !== void 0 ? _c : {}), {
                        name: consts_js_1.internalEvents.FunctionInvoked
                    })
                ]
            }));
            const newPayload = InngestStepTools_js_1.invokePayloadSchema.parse((_e = (_d = transformedPayload === null || transformedPayload === void 0 ? void 0 : transformedPayload.payloads) === null || _d === void 0 ? void 0 : _d[0]) !== null && _e !== void 0 ? _e : {});
            return Object.assign(Object.assign({}, step), {
                opts: Object.assign(Object.assign({}, step.opts), {
                    payload: Object.assign(Object.assign({}, (_g = (_f = step.opts) === null || _f === void 0 ? void 0 : _f.payload) !== null && _g !== void 0 ? _g : {}), newPayload)
                })
            });
        }));
    }
    async executeStep({ id, name, opts, fn, displayName }) {
        var _a, _b, _c, _d, _e;
        (_a = this.timeout) === null || _a === void 0 ? void 0 : _a.clear();
        await ((_c = (_b = this.state.hooks) === null || _b === void 0 ? void 0 : _b.afterMemoization) === null || _c === void 0 ? void 0 : _c.call(_b));
        await ((_e = (_d = this.state.hooks) === null || _d === void 0 ? void 0 : _d.beforeExecution) === null || _e === void 0 ? void 0 : _e.call(_d));
        const outgoingOp = {
            id,
            op: types_js_1.StepOpCode.StepRun,
            name,
            opts,
            displayName
        };
        this.state.executingStep = outgoingOp;
        this.debug(`executing step "${id}"`);
        return (0, promises_js_1.runAsPromise)(fn)// eslint-disable-next-line @typescript-eslint/no-misused-promises
        .finally(async ()=>{
            var _a, _b;
            await ((_b = (_a = this.state.hooks) === null || _a === void 0 ? void 0 : _a.afterExecution) === null || _b === void 0 ? void 0 : _b.call(_a));
        }).then((data)=>{
            return Object.assign(Object.assign({}, outgoingOp), {
                data
            });
        }).catch((error)=>{
            return Object.assign(Object.assign({}, outgoingOp), {
                op: types_js_1.StepOpCode.StepError,
                // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
                error
            });
        });
    }
    /**
     * Starts execution of the user's function, including triggering checkpoints
     * and middleware hooks where appropriate.
     */ async startExecution() {
        var _a, _b, _c, _d, _e, _f, _g;
        /**
         * Mutate input as neccessary based on middleware.
         */ await this.transformInput();
        /**
         * Start the timer to time out the run if needed.
         */ void ((_a = this.timeout) === null || _a === void 0 ? void 0 : _a.start());
        await ((_c = (_b = this.state.hooks) === null || _b === void 0 ? void 0 : _b.beforeMemoization) === null || _c === void 0 ? void 0 : _c.call(_b));
        /**
         * If we had no state to begin with, immediately end the memoization phase.
         */ if (this.state.allStateUsed()) {
            await ((_e = (_d = this.state.hooks) === null || _d === void 0 ? void 0 : _d.afterMemoization) === null || _e === void 0 ? void 0 : _e.call(_d));
            await ((_g = (_f = this.state.hooks) === null || _f === void 0 ? void 0 : _f.beforeExecution) === null || _g === void 0 ? void 0 : _g.call(_f));
        }
        /**
         * Trigger the user's function.
         */ (0, promises_js_1.runAsPromise)(()=>this.userFnToRun(this.fnArg))// eslint-disable-next-line @typescript-eslint/no-misused-promises
        .finally(async ()=>{
            var _a, _b, _c, _d, _e, _f;
            await ((_b = (_a = this.state.hooks) === null || _a === void 0 ? void 0 : _a.afterMemoization) === null || _b === void 0 ? void 0 : _b.call(_a));
            await ((_d = (_c = this.state.hooks) === null || _c === void 0 ? void 0 : _c.beforeExecution) === null || _d === void 0 ? void 0 : _d.call(_c));
            await ((_f = (_e = this.state.hooks) === null || _e === void 0 ? void 0 : _e.afterExecution) === null || _f === void 0 ? void 0 : _f.call(_e));
        }).then((data)=>{
            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
            this.state.setCheckpoint({
                type: "function-resolved",
                data
            });
        }).catch((error)=>{
            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
            this.state.setCheckpoint({
                type: "function-rejected",
                error
            });
        });
    }
    /**
     * Using middleware, transform input before running.
     */ async transformInput() {
        var _a, _b;
        const inputMutations = await ((_b = (_a = this.state.hooks) === null || _a === void 0 ? void 0 : _a.transformInput) === null || _b === void 0 ? void 0 : _b.call(_a, {
            ctx: Object.assign({}, this.fnArg),
            steps: Object.values(this.state.stepState),
            fn: this.options.fn,
            reqArgs: this.options.reqArgs
        }));
        if (inputMutations === null || inputMutations === void 0 ? void 0 : inputMutations.ctx) {
            this.fnArg = inputMutations.ctx;
        }
        if (inputMutations === null || inputMutations === void 0 ? void 0 : inputMutations.steps) {
            this.state.stepState = Object.fromEntries(inputMutations.steps.map((step)=>[
                    step.id,
                    step
                ]));
        }
    }
    /**
     * Using middleware, transform output before returning.
     */ async transformOutput(dataOrError) {
        var _a, _b, _c, _d;
        const output = Object.assign({}, dataOrError);
        /**
         * If we've been given an error and it's one that we just threw from a step,
         * we should return a `NonRetriableError` to stop execution.
         */ if (typeof output.error !== "undefined") {
            output.data = (0, errors_js_1.serializeError)(output.error);
        }
        const isStepExecution = Boolean(this.state.executingStep);
        const transformedOutput = await ((_b = (_a = this.state.hooks) === null || _a === void 0 ? void 0 : _a.transformOutput) === null || _b === void 0 ? void 0 : _b.call(_a, {
            result: Object.assign({}, output),
            step: this.state.executingStep
        }));
        const { data, error } = Object.assign(Object.assign({}, output), transformedOutput === null || transformedOutput === void 0 ? void 0 : transformedOutput.result);
        if (!isStepExecution) {
            await ((_d = (_c = this.state.hooks) === null || _c === void 0 ? void 0 : _c.finished) === null || _d === void 0 ? void 0 : _d.call(_c, {
                result: Object.assign({}, typeof error !== "undefined" ? {
                    error
                } : {
                    data
                })
            }));
        }
        if (typeof error !== "undefined") {
            /**
             * Ensure we give middleware the chance to decide on retriable behaviour
             * by looking at the error returned from output transformation.
             */ let retriable = !(error instanceof NonRetriableError_js_1.NonRetriableError || error instanceof StepError_js_1.StepError);
            if (retriable && error instanceof RetryAfterError_js_1.RetryAfterError) {
                retriable = error.retryAfter;
            }
            const serializedError = (0, errors_js_1.minifyPrettyError)((0, errors_js_1.serializeError)(error));
            return {
                type: "function-rejected",
                ctx: this.fnArg,
                ops: this.ops,
                error: serializedError,
                retriable
            };
        }
        return {
            type: "function-resolved",
            ctx: this.fnArg,
            ops: this.ops,
            data: (0, functions_js_1.undefinedToNull)(data)
        };
    }
    createExecutionState() {
        const d = (0, promises_js_1.createDeferredPromiseWithStack)();
        let checkpointResolve = d.deferred.resolve;
        const checkpointResults = d.results;
        const loop = function(cleanUp) {
            return __asyncGenerator(this, arguments, function*() {
                try {
                    while(true){
                        const res = (yield __await(checkpointResults.next())).value;
                        if (res) {
                            yield yield __await(res);
                        }
                    }
                } finally{
                    cleanUp === null || cleanUp === void 0 ? void 0 : cleanUp();
                }
            });
        }(()=>{
            var _a;
            (_a = this.timeout) === null || _a === void 0 ? void 0 : _a.clear();
            void checkpointResults.return();
        });
        const stepsToFulfill = Object.keys(this.options.stepState).length;
        const state = {
            stepState: this.options.stepState,
            stepsToFulfill,
            steps: new Map(),
            loop,
            hasSteps: Boolean(stepsToFulfill),
            stepCompletionOrder: [
                ...this.options.stepCompletionOrder
            ],
            remainingStepsToBeSeen: new Set(this.options.stepCompletionOrder),
            setCheckpoint: (checkpoint)=>{
                ({ resolve: checkpointResolve } = checkpointResolve(checkpoint));
            },
            allStateUsed: ()=>{
                return this.state.remainingStepsToBeSeen.size === 0;
            }
        };
        return state;
    }
    get ops() {
        return Object.fromEntries(this.state.steps);
    }
    createFnArg() {
        var _a, _b, _c, _d;
        const step = this.createStepTools();
        let fnArg = Object.assign(Object.assign({}, this.options.data), {
            step
        });
        /**
         * Handle use of the `onFailure` option by deserializing the error.
         */ if (this.options.isFailureHandler) {
            const eventData = zod_1.z.object({
                error: types_js_1.jsonErrorSchema
            }).parse((_a = fnArg.event) === null || _a === void 0 ? void 0 : _a.data);
            fnArg = Object.assign(Object.assign({}, fnArg), {
                error: (0, errors_js_1.deserializeError)(eventData.error)
            });
        }
        return (_d = (_c = (_b = this.options).transformCtx) === null || _c === void 0 ? void 0 : _c.call(_b, fnArg)) !== null && _d !== void 0 ? _d : fnArg;
    }
    createStepTools() {
        /**
         * A list of steps that have been found and are being rolled up before being
         * reported to the core loop.
         */ const foundStepsToReport = new Map();
        /**
         * A map of the subset of found steps to report that have not yet been
         * handled. Used for fast access to steps that need to be handled in order.
         */ const unhandledFoundStepsToReport = new Map();
        /**
         * A map of the latest sequential step indexes found for each step ID. Used
         * to ensure that we don't index steps in parallel.
         *
         * Note that these must be sequential; if we've seen or assigned `a:1`,
         * `a:2` and `a:4`, the latest sequential step index is `2`.
         *
         */ const expectedNextStepIndexes = new Map();
        /**
         * A promise that's used to ensure that step reporting cannot be run more than
         * once in a given asynchronous time span.
         */ let foundStepsReportPromise;
        /**
         * A promise that's used to represent middleware hooks running before
         * execution.
         */ let beforeExecHooksPromise;
        /**
         * A helper used to report steps to the core loop. Used after adding an item
         * to `foundStepsToReport`.
         */ const reportNextTick = ()=>{
            // Being explicit instead of using `??=` to appease TypeScript.
            if (foundStepsReportPromise) {
                return;
            }
            foundStepsReportPromise = new Promise((resolve)=>setImmediate(resolve))/**
                 * Ensure that we wait for this promise to resolve before continuing.
                 *
                 * The groups in which steps are reported can affect how we detect some
                 * more complex determinism issues like parallel indexing. This promise
                 * can represent middleware hooks being run early, in the middle of
                 * ingesting steps to report.
                 *
                 * Because of this, it's important we wait for this middleware to resolve
                 * before continuing to report steps to ensure that all steps have a
                 * chance to be reported throughout this asynchronous action.
                 */ .then(()=>beforeExecHooksPromise).then(()=>{
                foundStepsReportPromise = undefined;
                for (const [hashedId, step] of unhandledFoundStepsToReport){
                    if (step.handle()) {
                        unhandledFoundStepsToReport.delete(hashedId);
                        if (step.fulfilled) {
                            foundStepsToReport.delete(step.id);
                        }
                    }
                }
                if (foundStepsToReport.size) {
                    const steps = [
                        ...foundStepsToReport.values()
                    ];
                    foundStepsToReport.clear();
                    return void this.state.setCheckpoint({
                        type: "steps-found",
                        steps: steps
                    });
                }
            });
        };
        /**
         * A helper used to push a step to the list of steps to report.
         */ const pushStepToReport = (step)=>{
            foundStepsToReport.set(step.id, step);
            unhandledFoundStepsToReport.set(step.hashedId, step);
            reportNextTick();
        };
        const stepHandler = async ({ args, matchOp, opts })=>{
            var _a, _b, _c, _d;
            await beforeExecHooksPromise;
            const stepOptions = (0, InngestStepTools_js_1.getStepOptions)(args[0]);
            const opId = matchOp(stepOptions, ...args.slice(1));
            if (this.state.executingStep) {
                /**
                 * If a step is found after asynchronous actions during another step's
                 * execution, everything is fine. The problem here is if we've found
                 * that a step nested inside another a step, which is something we don't
                 * support at the time of writing.
                 *
                 * In this case, we could use something like Async Hooks to understand
                 * how the step is being triggered, though this isn't available in all
                 * environments.
                 *
                 * Therefore, we'll only show a warning here to indicate that this is
                 * potentially an issue.
                 */ console.warn((0, errors_js_1.prettyError)({
                    whatHappened: `We detected that you have nested \`step.*\` tooling in \`${(_a = opId.displayName) !== null && _a !== void 0 ? _a : opId.id}\``,
                    consequences: "Nesting `step.*` tooling is not supported.",
                    type: "warn",
                    reassurance: "It's possible to see this warning if steps are separated by regular asynchronous calls, which is fine.",
                    stack: true,
                    toFixNow: "Make sure you're not using `step.*` tooling inside of other `step.*` tooling. If you need to compose steps together, you can create a new async function and call it from within your step function, or use promise chaining.",
                    code: errors_js_1.ErrCode.NESTING_STEPS
                }));
            }
            if (this.state.steps.has(opId.id)) {
                const originalId = opId.id;
                const expectedNextIndex = (_b = expectedNextStepIndexes.get(originalId)) !== null && _b !== void 0 ? _b : 1;
                for(let i = expectedNextIndex;; i++){
                    const newId = originalId + InngestStepTools_js_1.STEP_INDEXING_SUFFIX + i;
                    if (!this.state.steps.has(newId)) {
                        expectedNextStepIndexes.set(originalId, i + 1);
                        opId.id = newId;
                        break;
                    }
                }
            }
            const { promise, resolve, reject } = (0, promises_js_1.createDeferredPromise)();
            const hashedId = exports._internals.hashId(opId.id);
            const stepState = this.state.stepState[hashedId];
            let isFulfilled = false;
            if (stepState) {
                stepState.seen = true;
                this.state.remainingStepsToBeSeen.delete(hashedId);
                if (typeof stepState.input === "undefined") {
                    isFulfilled = true;
                }
            }
            let extraOpts;
            let fnArgs = [
                ...args
            ];
            if (typeof (stepState === null || stepState === void 0 ? void 0 : stepState.input) !== "undefined" && Array.isArray(stepState.input)) {
                switch(opId.op){
                    // `step.run()` has its function input affected
                    case types_js_1.StepOpCode.StepPlanned:
                        {
                            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
                            fnArgs = [
                                ...args.slice(0, 2),
                                ...stepState.input
                            ];
                            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
                            extraOpts = {
                                input: [
                                    ...stepState.input
                                ]
                            };
                            break;
                        }
                    // `step.ai.infer()` has its body affected
                    case types_js_1.StepOpCode.AiGateway:
                        {
                            extraOpts = {
                                body: Object.assign(Object.assign({}, typeof ((_c = opId.opts) === null || _c === void 0 ? void 0 : _c.body) === "object" ? Object.assign({}, opId.opts.body) : {}), stepState.input[0])
                            };
                            break;
                        }
                }
            }
            const step = Object.assign(Object.assign({}, opId), {
                opts: Object.assign(Object.assign({}, opId.opts), extraOpts),
                rawArgs: fnArgs,
                hashedId,
                input: stepState === null || stepState === void 0 ? void 0 : stepState.input,
                // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
                fn: (opts === null || opts === void 0 ? void 0 : opts.fn) ? ()=>{
                    var _a;
                    return (_a = opts.fn) === null || _a === void 0 ? void 0 : _a.call(opts, ...fnArgs);
                } : undefined,
                promise,
                fulfilled: isFulfilled,
                hasStepState: Boolean(stepState),
                displayName: (_d = opId.displayName) !== null && _d !== void 0 ? _d : opId.id,
                handled: false,
                handle: ()=>{
                    if (step.handled) {
                        return false;
                    }
                    step.handled = true;
                    if (isFulfilled && stepState) {
                        stepState.fulfilled = true;
                        // For some execution scenarios such as testing, `data`, `error`,
                        // and `input` may be `Promises`. This could also be the case for
                        // future middleware applications. For this reason, we'll make sure
                        // the values are fully resolved before continuing.
                        void Promise.all([
                            stepState.data,
                            stepState.error,
                            stepState.input
                        ]).then(()=>{
                            if (typeof stepState.data !== "undefined") {
                                resolve(stepState.data);
                            } else {
                                this.state.recentlyRejectedStepError = new StepError_js_1.StepError(opId.id, stepState.error);
                                reject(this.state.recentlyRejectedStepError);
                            }
                        });
                    }
                    return true;
                }
            });
            this.state.steps.set(opId.id, step);
            this.state.hasSteps = true;
            pushStepToReport(step);
            /**
             * If this is the last piece of state we had, we've now finished
             * memoizing.
             */ if (!beforeExecHooksPromise && this.state.allStateUsed()) {
                await (beforeExecHooksPromise = (async ()=>{
                    var _a, _b, _c, _d;
                    await ((_b = (_a = this.state.hooks) === null || _a === void 0 ? void 0 : _a.afterMemoization) === null || _b === void 0 ? void 0 : _b.call(_a));
                    await ((_d = (_c = this.state.hooks) === null || _c === void 0 ? void 0 : _c.beforeExecution) === null || _d === void 0 ? void 0 : _d.call(_c));
                })());
            }
            return promise;
        };
        return (0, InngestStepTools_js_1.createStepTools)(this.options.client, this, stepHandler);
    }
    getUserFnToRun() {
        if (!this.options.isFailureHandler) {
            return this.options.fn["fn"];
        }
        if (!this.options.fn["onFailureFn"]) {
            /**
             * Somehow, we've ended up detecting that this is a failure handler but
             * doesn't have an `onFailure` function. This should never happen.
             */ throw new Error("Cannot find function `onFailure` handler");
        }
        return this.options.fn["onFailureFn"];
    }
    initializeTimer(state) {
        if (!this.options.requestedRunStep) {
            return;
        }
        this.timeout = (0, promises_js_1.createTimeoutPromise)(this.timeoutDuration);
        void this.timeout.then(async ()=>{
            var _a, _b, _c, _d, _e, _f;
            await ((_b = (_a = this.state.hooks) === null || _a === void 0 ? void 0 : _a.afterMemoization) === null || _b === void 0 ? void 0 : _b.call(_a));
            await ((_d = (_c = this.state.hooks) === null || _c === void 0 ? void 0 : _c.beforeExecution) === null || _d === void 0 ? void 0 : _d.call(_c));
            await ((_f = (_e = this.state.hooks) === null || _e === void 0 ? void 0 : _e.afterExecution) === null || _f === void 0 ? void 0 : _f.call(_e));
            state.setCheckpoint({
                type: "step-not-found",
                step: {
                    id: this.options.requestedRunStep,
                    op: types_js_1.StepOpCode.StepNotFound
                }
            });
        });
    }
    async initializeMiddleware() {
        const ctx = this.options.data;
        const hooks = await (0, InngestMiddleware_js_1.getHookStack)(this.options.fn["middleware"], "onFunctionRun", {
            ctx,
            fn: this.options.fn,
            steps: Object.values(this.options.stepState),
            reqArgs: this.options.reqArgs
        }, {
            transformInput: (prev, output)=>{
                return {
                    ctx: Object.assign(Object.assign({}, prev.ctx), output === null || output === void 0 ? void 0 : output.ctx),
                    fn: this.options.fn,
                    steps: prev.steps.map((step, i)=>{
                        var _a;
                        return Object.assign(Object.assign({}, step), (_a = output === null || output === void 0 ? void 0 : output.steps) === null || _a === void 0 ? void 0 : _a[i]);
                    }),
                    reqArgs: prev.reqArgs
                };
            },
            transformOutput: (prev, output)=>{
                return {
                    result: Object.assign(Object.assign({}, prev.result), output === null || output === void 0 ? void 0 : output.result),
                    step: prev.step
                };
            }
        });
        return hooks;
    }
}
const hashId = (id)=>{
    return (0, hash_js_1.sha1)().update(id).digest("hex");
};
const hashOp = (op)=>{
    return Object.assign(Object.assign({}, op), {
        id: hashId(op.id)
    });
};
/**
 * Exported for testing.
 */ exports._internals = {
    hashOp,
    hashId
}; //# sourceMappingURL=v2.js.map
}}),
"[project]/node_modules/.pnpm/inngest@3.32.5_express@4.21.2_next@15.3.4_@opentelemetry+api@1.9.0_react-dom@19.2.0_rea_302ab31fd2a599b814fb517e8771719b/node_modules/inngest/components/InngestFunction.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.InngestFunction = void 0;
const consts_js_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/inngest@3.32.5_express@4.21.2_next@15.3.4_@opentelemetry+api@1.9.0_react-dom@19.2.0_rea_302ab31fd2a599b814fb517e8771719b/node_modules/inngest/helpers/consts.js [app-route] (ecmascript)");
const strings_js_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/inngest@3.32.5_express@4.21.2_next@15.3.4_@opentelemetry+api@1.9.0_react-dom@19.2.0_rea_302ab31fd2a599b814fb517e8771719b/node_modules/inngest/helpers/strings.js [app-route] (ecmascript)");
const InngestExecution_js_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/inngest@3.32.5_express@4.21.2_next@15.3.4_@opentelemetry+api@1.9.0_react-dom@19.2.0_rea_302ab31fd2a599b814fb517e8771719b/node_modules/inngest/components/execution/InngestExecution.js [app-route] (ecmascript)");
const v0_js_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/inngest@3.32.5_express@4.21.2_next@15.3.4_@opentelemetry+api@1.9.0_react-dom@19.2.0_rea_302ab31fd2a599b814fb517e8771719b/node_modules/inngest/components/execution/v0.js [app-route] (ecmascript)");
const v1_js_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/inngest@3.32.5_express@4.21.2_next@15.3.4_@opentelemetry+api@1.9.0_react-dom@19.2.0_rea_302ab31fd2a599b814fb517e8771719b/node_modules/inngest/components/execution/v1.js [app-route] (ecmascript)");
const v2_js_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/inngest@3.32.5_express@4.21.2_next@15.3.4_@opentelemetry+api@1.9.0_react-dom@19.2.0_rea_302ab31fd2a599b814fb517e8771719b/node_modules/inngest/components/execution/v2.js [app-route] (ecmascript)");
/**
 * A stateless Inngest function, wrapping up function configuration and any
 * in-memory steps to run when triggered.
 *
 * This function can be "registered" to create a handler that Inngest can
 * trigger remotely.
 *
 * @public
 */ class InngestFunction {
    /**
     * A stateless Inngest function, wrapping up function configuration and any
     * in-memory steps to run when triggered.
     *
     * This function can be "registered" to create a handler that Inngest can
     * trigger remotely.
     */ constructor(client, /**
     * Options
     */ opts, fn){
        this.client = client;
        this.opts = opts;
        this.fn = fn;
        this.onFailureFn = this.opts.onFailure;
        this.middleware = this.client["initializeMiddleware"](this.opts.middleware, {
            registerInput: {
                fn: this
            },
            prefixStack: this.client["middleware"]
        });
    }
    /**
     * The generated or given ID for this function.
     */ id(prefix) {
        return [
            prefix,
            this.opts.id
        ].filter(Boolean).join("-");
    }
    /**
     * The generated or given ID for this function, prefixed with the app ID. This
     * is used for routing invokes and identifying the function across apps.
     */ get absoluteId() {
        return this.id(this.client.id);
    }
    /**
     * The name of this function as it will appear in the Inngest Cloud UI.
     */ get name() {
        return this.opts.name || this.id();
    }
    /**
     * The description of this function.
     */ get description() {
        return this.opts.description;
    }
    /**
     * Retrieve the Inngest config for this function.
     */ getConfig({ baseUrl, appPrefix, isConnect }) {
        var _a, _b;
        const fnId = this.id(appPrefix);
        const stepUrl = new URL(baseUrl.href);
        stepUrl.searchParams.set(consts_js_1.queryKeys.FnId, fnId);
        stepUrl.searchParams.set(consts_js_1.queryKeys.StepId, InngestFunction.stepId);
        const { retries: attempts, cancelOn, idempotency, batchEvents, rateLimit, throttle, concurrency, debounce, timeouts, priority } = this.opts;
        /**
         * Convert retries into the format required when defining function
         * configuration.
         */ const retries = typeof attempts === "undefined" ? undefined : {
            attempts
        };
        const fn = {
            id: fnId,
            name: this.name,
            triggers: ((_a = this.opts.triggers) !== null && _a !== void 0 ? _a : []).map((trigger)=>{
                if ("event" in trigger) {
                    return {
                        event: trigger.event,
                        expression: trigger.if
                    };
                }
                return {
                    cron: trigger.cron
                };
            }),
            steps: {
                [InngestFunction.stepId]: {
                    id: InngestFunction.stepId,
                    name: InngestFunction.stepId,
                    runtime: {
                        type: isConnect ? "ws" : "http",
                        url: stepUrl.href
                    },
                    retries
                }
            },
            idempotency,
            batchEvents,
            rateLimit,
            throttle,
            concurrency,
            debounce,
            priority,
            timeouts
        };
        if (cancelOn) {
            fn.cancel = cancelOn.map(({ event, timeout, if: ifStr, match })=>{
                const ret = {
                    event
                };
                if (timeout) {
                    ret.timeout = (0, strings_js_1.timeStr)(timeout);
                }
                if (match) {
                    ret.if = `event.${match} == async.${match}`;
                } else if (ifStr) {
                    ret.if = ifStr;
                }
                return ret;
            }, []);
        }
        const config = [
            fn
        ];
        if (this.onFailureFn) {
            const id = `${fn.id}${InngestFunction.failureSuffix}`;
            const name = `${(_b = fn.name) !== null && _b !== void 0 ? _b : fn.id} (failure)`;
            const failureStepUrl = new URL(stepUrl.href);
            failureStepUrl.searchParams.set(consts_js_1.queryKeys.FnId, id);
            config.push({
                id,
                name,
                triggers: [
                    {
                        event: consts_js_1.internalEvents.FunctionFailed,
                        expression: `event.data.function_id == '${fnId}'`
                    }
                ],
                steps: {
                    [InngestFunction.stepId]: {
                        id: InngestFunction.stepId,
                        name: InngestFunction.stepId,
                        runtime: {
                            type: "http",
                            url: failureStepUrl.href
                        },
                        retries: {
                            attempts: 1
                        }
                    }
                }
            });
        }
        return config;
    }
    createExecution(opts) {
        const options = Object.assign({
            client: this.client,
            fn: this
        }, opts.partialOptions);
        const versionHandlers = {
            [InngestExecution_js_1.ExecutionVersion.V2]: ()=>(0, v2_js_1.createV2InngestExecution)(options),
            [InngestExecution_js_1.ExecutionVersion.V1]: ()=>(0, v1_js_1.createV1InngestExecution)(options),
            [InngestExecution_js_1.ExecutionVersion.V0]: ()=>(0, v0_js_1.createV0InngestExecution)(options)
        };
        return versionHandlers[opts.version]();
    }
    shouldOptimizeParallelism() {
        var _a, _b;
        // TODO We should check the commhandler's client instead of this one?
        return (_b = (_a = this.opts.optimizeParallelism) !== null && _a !== void 0 ? _a : this.client["options"].optimizeParallelism) !== null && _b !== void 0 ? _b : false;
    }
}
exports.InngestFunction = InngestFunction;
InngestFunction.stepId = "step";
InngestFunction.failureSuffix = "-failure"; //# sourceMappingURL=InngestFunction.js.map
}}),
"[project]/node_modules/.pnpm/inngest@3.32.5_express@4.21.2_next@15.3.4_@opentelemetry+api@1.9.0_react-dom@19.2.0_rea_302ab31fd2a599b814fb517e8771719b/node_modules/inngest/components/Inngest.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.builtInMiddleware = exports.Inngest = void 0;
const ulidx_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/ulidx@2.4.1/node_modules/ulidx/dist/node/index.cjs [app-route] (ecmascript)");
const api_js_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/inngest@3.32.5_express@4.21.2_next@15.3.4_@opentelemetry+api@1.9.0_react-dom@19.2.0_rea_302ab31fd2a599b814fb517e8771719b/node_modules/inngest/api/api.js [app-route] (ecmascript)");
const consts_js_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/inngest@3.32.5_express@4.21.2_next@15.3.4_@opentelemetry+api@1.9.0_react-dom@19.2.0_rea_302ab31fd2a599b814fb517e8771719b/node_modules/inngest/helpers/consts.js [app-route] (ecmascript)");
const devserver_js_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/inngest@3.32.5_express@4.21.2_next@15.3.4_@opentelemetry+api@1.9.0_react-dom@19.2.0_rea_302ab31fd2a599b814fb517e8771719b/node_modules/inngest/helpers/devserver.js [app-route] (ecmascript)");
const env_js_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/inngest@3.32.5_express@4.21.2_next@15.3.4_@opentelemetry+api@1.9.0_react-dom@19.2.0_rea_302ab31fd2a599b814fb517e8771719b/node_modules/inngest/helpers/env.js [app-route] (ecmascript)");
const errors_js_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/inngest@3.32.5_express@4.21.2_next@15.3.4_@opentelemetry+api@1.9.0_react-dom@19.2.0_rea_302ab31fd2a599b814fb517e8771719b/node_modules/inngest/helpers/errors.js [app-route] (ecmascript)");
const promises_js_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/inngest@3.32.5_express@4.21.2_next@15.3.4_@opentelemetry+api@1.9.0_react-dom@19.2.0_rea_302ab31fd2a599b814fb517e8771719b/node_modules/inngest/helpers/promises.js [app-route] (ecmascript)");
const strings_js_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/inngest@3.32.5_express@4.21.2_next@15.3.4_@opentelemetry+api@1.9.0_react-dom@19.2.0_rea_302ab31fd2a599b814fb517e8771719b/node_modules/inngest/helpers/strings.js [app-route] (ecmascript)");
const logger_js_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/inngest@3.32.5_express@4.21.2_next@15.3.4_@opentelemetry+api@1.9.0_react-dom@19.2.0_rea_302ab31fd2a599b814fb517e8771719b/node_modules/inngest/middleware/logger.js [app-route] (ecmascript)");
const types_js_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/inngest@3.32.5_express@4.21.2_next@15.3.4_@opentelemetry+api@1.9.0_react-dom@19.2.0_rea_302ab31fd2a599b814fb517e8771719b/node_modules/inngest/types.js [app-route] (ecmascript)");
const InngestFunction_js_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/inngest@3.32.5_express@4.21.2_next@15.3.4_@opentelemetry+api@1.9.0_react-dom@19.2.0_rea_302ab31fd2a599b814fb517e8771719b/node_modules/inngest/components/InngestFunction.js [app-route] (ecmascript)");
const InngestMiddleware_js_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/inngest@3.32.5_express@4.21.2_next@15.3.4_@opentelemetry+api@1.9.0_react-dom@19.2.0_rea_302ab31fd2a599b814fb517e8771719b/node_modules/inngest/components/InngestMiddleware.js [app-route] (ecmascript)");
/**
 * A client used to interact with the Inngest API by sending or reacting to
 * events.
 *
 * To provide event typing, see {@link EventSchemas}.
 *
 * ```ts
 * const inngest = new Inngest({ id: "my-app" });
 *
 * // or to provide event typing too
 * const inngest = new Inngest({
 *   id: "my-app",
 *   schemas: new EventSchemas().fromRecord<{
 *     "app/user.created": {
 *       data: { userId: string };
 *     };
 *   }>(),
 * });
 * ```
 *
 * @public
 */ class Inngest {
    get apiBaseUrl() {
        return this._apiBaseUrl;
    }
    get eventBaseUrl() {
        return this._eventBaseUrl;
    }
    get env() {
        var _a;
        return (_a = this.headers[consts_js_1.headerKeys.Environment]) !== null && _a !== void 0 ? _a : null;
    }
    get appVersion() {
        return this._appVersion;
    }
    /**
     * A client used to interact with the Inngest API by sending or reacting to
     * events.
     *
     * To provide event typing, see {@link EventSchemas}.
     *
     * ```ts
     * const inngest = new Inngest({ name: "My App" });
     *
     * // or to provide event typing too
     * const inngest = new Inngest({
     *   name: "My App",
     *   schemas: new EventSchemas().fromRecord<{
     *     "app/user.created": {
     *       data: { userId: string };
     *     };
     *   }>(),
     * });
     * ```
     */ constructor(options){
        /**
         * Inngest event key, used to send events to Inngest Cloud.
         */ this.eventKey = "";
        /**
         * The absolute URL of the Inngest Cloud API.
         */ this.sendEventUrl = new URL(`e/${this.eventKey}`, consts_js_1.defaultInngestEventBaseUrl);
        this.localFns = [];
        this.createFunction = (rawOptions, rawTrigger, handler)=>{
            const fn = this._createFunction(rawOptions, rawTrigger, handler);
            this.localFns.push(fn);
            return fn;
        };
        this._createFunction = (rawOptions, rawTrigger, handler)=>{
            const options = this.sanitizeOptions(rawOptions);
            const triggers = this.sanitizeTriggers(rawTrigger);
            return new InngestFunction_js_1.InngestFunction(this, Object.assign(Object.assign({}, options), {
                triggers
            }), handler);
        };
        this.options = options;
        const { id, fetch, logger = new logger_js_1.DefaultLogger(), middleware, isDev, schemas, appVersion } = this.options;
        if (!id) {
            // TODO PrettyError
            throw new Error("An `id` must be passed to create an Inngest instance.");
        }
        this.id = id;
        this._mode = (0, env_js_1.getMode)({
            explicitMode: typeof isDev === "boolean" ? isDev ? "dev" : "cloud" : undefined
        });
        this.fetch = (0, env_js_1.getFetch)(fetch);
        this.inngestApi = new api_js_1.InngestApi({
            baseUrl: this.apiBaseUrl,
            signingKey: (0, env_js_1.processEnv)(consts_js_1.envKeys.InngestSigningKey) || "",
            signingKeyFallback: (0, env_js_1.processEnv)(consts_js_1.envKeys.InngestSigningKeyFallback),
            fetch: this.fetch,
            mode: this.mode
        });
        this.schemas = schemas;
        this.loadModeEnvVars();
        this.logger = logger;
        this.middleware = this.initializeMiddleware([
            ...exports.builtInMiddleware,
            ...middleware || []
        ]);
        this._appVersion = appVersion;
    }
    /**
     * Set the environment variables for this client. This is useful if you are
     * passed environment variables at runtime instead of as globals and need to
     * update the client with those values as requests come in.
     */ setEnvVars(env = (0, env_js_1.allProcessEnv)()) {
        this.mode = (0, env_js_1.getMode)({
            env,
            client: this
        });
        return this;
    }
    loadModeEnvVars() {
        this._apiBaseUrl = this.options.baseUrl || this.mode["env"][consts_js_1.envKeys.InngestApiBaseUrl] || this.mode["env"][consts_js_1.envKeys.InngestBaseUrl] || this.mode.getExplicitUrl(consts_js_1.defaultInngestApiBaseUrl);
        this._eventBaseUrl = this.options.baseUrl || this.mode["env"][consts_js_1.envKeys.InngestEventApiBaseUrl] || this.mode["env"][consts_js_1.envKeys.InngestBaseUrl] || this.mode.getExplicitUrl(consts_js_1.defaultInngestEventBaseUrl);
        this.setEventKey(this.options.eventKey || this.mode["env"][consts_js_1.envKeys.InngestEventKey] || "");
        this.headers = (0, env_js_1.inngestHeaders)({
            inngestEnv: this.options.env,
            env: this.mode["env"]
        });
        this.inngestApi["mode"] = this.mode;
        this.inngestApi["apiBaseUrl"] = this._apiBaseUrl;
    }
    /**
     * Initialize all passed middleware, running the `register` function on each
     * in sequence and returning the requested hook registrations.
     */ async initializeMiddleware(middleware = [], opts) {
        var _a;
        /**
         * Wait for the prefix stack to run first; do not trigger ours before this
         * is complete.
         */ const prefix = await ((_a = opts === null || opts === void 0 ? void 0 : opts.prefixStack) !== null && _a !== void 0 ? _a : []);
        const stack = middleware.reduce(async (acc, m)=>{
            // Be explicit about waiting for the previous middleware to finish
            const prev = await acc;
            const next = await m.init(Object.assign({
                client: this
            }, opts === null || opts === void 0 ? void 0 : opts.registerInput));
            return [
                ...prev,
                next
            ];
        }, Promise.resolve([]));
        return [
            ...prefix,
            ...await stack
        ];
    }
    get mode() {
        return this._mode;
    }
    set mode(m) {
        this._mode = m;
        this.loadModeEnvVars();
    }
    /**
     * Given a response from Inngest, relay the error to the caller.
     */ async getResponseError(response, foundErr = "Unknown error") {
        let errorMessage = foundErr;
        if (errorMessage === "Unknown error") {
            switch(response.status){
                case 401:
                    errorMessage = "Event key Not Found";
                    break;
                case 400:
                    errorMessage = "Cannot process event payload";
                    break;
                case 403:
                    errorMessage = "Forbidden";
                    break;
                case 404:
                    errorMessage = "Event key not found";
                    break;
                case 406:
                    errorMessage = `${JSON.stringify(await response.json())}`;
                    break;
                case 409:
                case 412:
                    errorMessage = "Event transformation failed";
                    break;
                case 413:
                    errorMessage = "Event payload too large";
                    break;
                case 500:
                    errorMessage = "Internal server error";
                    break;
                default:
                    errorMessage = await response.text();
                    break;
            }
        }
        return new Error(`Inngest API Error: ${response.status} ${errorMessage}`);
    }
    /**
     * Set the event key for this instance of Inngest. This is useful if for some
     * reason the key is not available at time of instantiation or present in the
     * `INNGEST_EVENT_KEY` environment variable.
     */ setEventKey(/**
     * Inngest event key, used to send events to Inngest Cloud. Use this is your
     * key is for some reason not available at time of instantiation or present
     * in the `INNGEST_EVENT_KEY` environment variable.
     */ eventKey) {
        this.eventKey = eventKey || consts_js_1.dummyEventKey;
        this.sendEventUrl = new URL(`e/${this.eventKey}`, this.eventBaseUrl || consts_js_1.defaultInngestEventBaseUrl);
    }
    eventKeySet() {
        return Boolean(this.eventKey) && this.eventKey !== consts_js_1.dummyEventKey;
    }
    /**
     * Send one or many events to Inngest. Takes an entire payload (including
     * name) as each input.
     *
     * ```ts
     * await inngest.send({ name: "app/user.created", data: { id: 123 } });
     * ```
     *
     * Returns a promise that will resolve if the event(s) were sent successfully,
     * else throws with an error explaining what went wrong.
     *
     * If you wish to send an event with custom types (i.e. one that hasn't been
     * generated), make sure to add it when creating your Inngest instance, like
     * so:
     *
     * ```ts
     * const inngest = new Inngest({
     *   name: "My App",
     *   schemas: new EventSchemas().fromRecord<{
     *     "my/event": {
     *       name: "my/event";
     *       data: { bar: string };
     *     };
     *   }>(),
     * });
     * ```
     */ async send(payload, options) {
        const headers = Object.assign({}, (options === null || options === void 0 ? void 0 : options.env) ? {
            [consts_js_1.headerKeys.Environment]: options.env
        } : {});
        return this._send({
            payload,
            headers
        });
    }
    /**
     * Internal method for sending an event, used to allow Inngest internals to
     * further customize the request sent to an Inngest Server.
     */ async _send({ payload, headers }) {
        var _a;
        const hooks = await (0, InngestMiddleware_js_1.getHookStack)(this.middleware, "onSendEvent", undefined, {
            transformInput: (prev, output)=>{
                return Object.assign(Object.assign({}, prev), output);
            },
            transformOutput (prev, output) {
                return {
                    result: Object.assign(Object.assign({}, prev.result), output === null || output === void 0 ? void 0 : output.result)
                };
            }
        });
        let payloads = Array.isArray(payload) ? payload : payload ? [
            payload
        ] : [];
        const inputChanges = await ((_a = hooks.transformInput) === null || _a === void 0 ? void 0 : _a.call(hooks, {
            payloads: [
                ...payloads
            ]
        }));
        if (inputChanges === null || inputChanges === void 0 ? void 0 : inputChanges.payloads) {
            payloads = [
                ...inputChanges.payloads
            ];
        }
        // Ensure that we always add "ts" and "data" fields to events. "ts" is auto-
        // filled by the event server so is safe, and adding here fixes Next.js
        // server action cache issues.
        payloads = payloads.map((p)=>{
            return Object.assign(Object.assign({}, p), {
                // Always generate an idempotency ID for an event for retries
                id: p.id || (0, ulidx_1.ulid)(),
                ts: p.ts || new Date().getTime(),
                // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
                data: p.data || {}
            });
        });
        const applyHookToOutput = async (arg)=>{
            var _a;
            const hookOutput = await ((_a = hooks.transformOutput) === null || _a === void 0 ? void 0 : _a.call(hooks, arg));
            return Object.assign(Object.assign({}, arg.result), hookOutput === null || hookOutput === void 0 ? void 0 : hookOutput.result);
        };
        /**
         * It can be valid for a user to send an empty list of events; if this
         * happens, show a warning that this may not be intended, but don't throw.
         */ if (!payloads.length) {
            console.warn((0, errors_js_1.prettyError)({
                type: "warn",
                whatHappened: "`inngest.send()` called with no events",
                reassurance: "This is not an error, but you may not have intended to do this.",
                consequences: "The returned promise will resolve, but no events have been sent to Inngest.",
                stack: true
            }));
            return await applyHookToOutput({
                result: {
                    ids: []
                }
            });
        }
        // When sending events, check if the dev server is available.  If so, use the
        // dev server.
        let url = this.sendEventUrl.href;
        /**
         * If in prod mode and key is not present, fail now.
         */ if (this.mode.isCloud && !this.eventKeySet()) {
            throw new Error((0, errors_js_1.prettyError)({
                whatHappened: "Failed to send event",
                consequences: "Your event or events were not sent to Inngest.",
                why: "We couldn't find an event key to use to send events to Inngest.",
                toFixNow: errors_js_1.fixEventKeyMissingSteps
            }));
        }
        /**
         * If dev mode has been inferred, try to hit the dev server first to see if
         * it exists. If it does, use it, otherwise fall back to whatever server we
         * have configured.
         *
         * `INNGEST_BASE_URL` is used to set both dev server and prod URLs, so if a
         * user has set this it means they have already chosen a URL to hit.
         */ if (this.mode.isDev && this.mode.isInferred && !this.eventBaseUrl) {
            const devAvailable = await (0, devserver_js_1.devServerAvailable)(consts_js_1.defaultDevServerHost, this.fetch);
            if (devAvailable) {
                url = (0, devserver_js_1.devServerUrl)(consts_js_1.defaultDevServerHost, `e/${this.eventKey}`).href;
            }
        }
        const body = await (0, promises_js_1.retryWithBackoff)(async ()=>{
            let body;
            // We don't need to do fallback auth here because this uses event keys and
            // not signing keys
            const response = await this.fetch(url, {
                method: "POST",
                body: (0, strings_js_1.stringify)(payloads),
                headers: Object.assign(Object.assign({}, this.headers), headers)
            });
            try {
                const rawBody = await response.json();
                body = await types_js_1.sendEventResponseSchema.parseAsync(rawBody);
            } catch (err) {
                throw await this.getResponseError(response);
            }
            if (body.status !== 200 || body.error) {
                throw await this.getResponseError(response, body.error);
            }
            return body;
        }, {
            maxAttempts: 5,
            baseDelay: 100
        });
        return await applyHookToOutput({
            result: {
                ids: body.ids
            }
        });
    }
    get funcs() {
        return this.localFns;
    }
    /**
     * Runtime-only validation.
     */ sanitizeOptions(options) {
        if (Object.prototype.hasOwnProperty.call(options, "fns")) {
            // v2 -> v3 migration warning
            console.warn(`${consts_js_1.logPrefix} InngestFunction: \`fns\` option has been deprecated in v3; use \`middleware\` instead. See https://www.inngest.com/docs/sdk/migration`);
        }
        if (typeof options === "string") {
            // v2 -> v3 runtime migraton warning
            console.warn(`${consts_js_1.logPrefix} InngestFunction: Creating a function with a string as the first argument has been deprecated in v3; pass an object instead. See https://www.inngest.com/docs/sdk/migration`);
            return {
                id: options
            };
        }
        return options;
    }
    /**
     * Runtime-only validation.
     */ sanitizeTriggers(triggers) {
        if (typeof triggers === "string") {
            // v2 -> v3 migration warning
            console.warn(`${consts_js_1.logPrefix} InngestFunction: Creating a function with a string as the second argument has been deprecated in v3; pass an object instead. See https://www.inngest.com/docs/sdk/migration`);
            return [
                {
                    event: triggers
                }
            ];
        }
        if (!Array.isArray(triggers)) {
            return [
                triggers
            ];
        }
        return triggers;
    }
}
exports.Inngest = Inngest;
/**
 * Default middleware that is included in every client, placed after the user's
 * middleware on the client but before function-level middleware.
 *
 * It is defined here to ensure that comments are included in the generated TS
 * definitions. Without this, we infer the stack of built-in middleware without
 * comments, losing a lot of value.
 *
 * If this is moved, please ensure that using this package in another project
 * can correctly access comments on mutated input and output.
 *
 * This return pattern mimics the output of a `satisfies` suffix; it's used as
 * we support versions of TypeScript prior to the introduction of `satisfies`.
 */ exports.builtInMiddleware = ((m)=>m)([
    new InngestMiddleware_js_1.InngestMiddleware({
        name: "Inngest: Logger",
        init ({ client }) {
            return {
                onFunctionRun (arg) {
                    const { ctx } = arg;
                    const metadata = {
                        runID: ctx.runId,
                        eventName: ctx.event.name,
                        functionName: arg.fn.name
                    };
                    let providedLogger = client["logger"];
                    // create a child logger if the provided logger has child logger implementation
                    try {
                        if ("child" in providedLogger) {
                            providedLogger = providedLogger.child(metadata);
                        }
                    } catch (err) {
                        console.error('failed to create "childLogger" with error: ', err);
                    // no-op
                    }
                    const logger = new logger_js_1.ProxyLogger(providedLogger);
                    return {
                        transformInput () {
                            return {
                                ctx: {
                                    /**
                                     * The passed in logger from the user.
                                     * Defaults to a console logger if not provided.
                                     */ logger: logger
                                }
                            };
                        },
                        beforeExecution () {
                            logger.enable();
                        },
                        transformOutput ({ result: { error } }) {
                            if (error) {
                                logger.error(error);
                            }
                        },
                        async beforeResponse () {
                            await logger.flush();
                        }
                    };
                }
            };
        }
    })
]); //# sourceMappingURL=Inngest.js.map
}}),
"[project]/node_modules/.pnpm/inngest@3.32.5_express@4.21.2_next@15.3.4_@opentelemetry+api@1.9.0_react-dom@19.2.0_rea_302ab31fd2a599b814fb517e8771719b/node_modules/inngest/helpers/ServerTiming.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ServerTiming = void 0;
const promises_js_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/inngest@3.32.5_express@4.21.2_next@15.3.4_@opentelemetry+api@1.9.0_react-dom@19.2.0_rea_302ab31fd2a599b814fb517e8771719b/node_modules/inngest/helpers/promises.js [app-route] (ecmascript)");
/**
 * A class to manage timing functions and arbitrary periods of time before
 * generating a `Server-Timing` header for use in HTTP responses.
 *
 * This is a very simple implementation that does not support nested timings or
 * fractions of a millisecond.
 */ class ServerTiming {
    constructor(){
        this.timings = {};
    }
    /**
     * Start a timing. Returns a function that, when called, will stop the timing
     * and add it to the header.
     */ start(name, description) {
        if (!this.timings[name]) {
            this.timings[name] = {
                description: description !== null && description !== void 0 ? description : "",
                timers: []
            };
        }
        const index = this.timings[name].timers.push({
            start: Date.now()
        }) - 1;
        return ()=>{
            const target = this.timings[name];
            if (!target) {
                return console.warn(`Timing "${name}" does not exist`);
            }
            const timer = target.timers[index];
            if (!timer) {
                return console.warn(`Timer ${index} for timing "${name}" does not exist`);
            }
            timer.end = Date.now();
        };
    }
    /**
     * Add a piece of arbitrary, untimed information to the header. Common use
     * cases would be cache misses.
     *
     * @example
     * ```
     * timer.append("cache", "miss");
     * ```
     */ append(key, value) {
        this.timings[key] = {
            description: value,
            timers: []
        };
    }
    /**
     * Wrap a function in a timing. The timing will be stopped and added to the
     * header when the function resolves or rejects.
     *
     * The return value of the function will be returned from this function.
     */ async wrap(name, fn, description) {
        const stop = this.start(name, description);
        try {
            return await (0, promises_js_1.runAsPromise)(fn);
        } finally{
            stop();
        }
    }
    /**
     * Generate the `Server-Timing` header.
     */ getHeader() {
        const entries = Object.entries(this.timings).reduce((acc, [name, { description, timers }])=>{
            /**
             * Ignore timers that had no end.
             */ const hasTimersWithEnd = timers.some((timer)=>timer.end);
            if (!hasTimersWithEnd) {
                return acc;
            }
            const dur = timers.reduce((acc, { start, end })=>{
                if (!start || !end) return acc;
                return acc + (end - start);
            }, 0);
            const entry = [
                name,
                description ? `desc="${description}"` : "",
                dur ? `dur=${dur}` : ""
            ].filter(Boolean).join(";");
            return [
                ...acc,
                entry
            ];
        }, []);
        return entries.join(", ");
    }
}
exports.ServerTiming = ServerTiming; //# sourceMappingURL=ServerTiming.js.map
}}),
"[project]/node_modules/.pnpm/inngest@3.32.5_express@4.21.2_next@15.3.4_@opentelemetry+api@1.9.0_react-dom@19.2.0_rea_302ab31fd2a599b814fb517e8771719b/node_modules/inngest/helpers/enum.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.enumFromValue = void 0;
/**
 * Returns the value of an enum from a string value.
 *
 * If the value given is not a value from the enum, `undefined` is returned.
 */ const enumFromValue = (enumType, value)=>{
    if (Object.values(enumType).includes(value)) {
        return value;
    }
};
exports.enumFromValue = enumFromValue; //# sourceMappingURL=enum.js.map
}}),
"[project]/node_modules/.pnpm/inngest@3.32.5_express@4.21.2_next@15.3.4_@opentelemetry+api@1.9.0_react-dom@19.2.0_rea_302ab31fd2a599b814fb517e8771719b/node_modules/inngest/helpers/stream.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.createStream = void 0;
const strings_js_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/inngest@3.32.5_express@4.21.2_next@15.3.4_@opentelemetry+api@1.9.0_react-dom@19.2.0_rea_302ab31fd2a599b814fb517e8771719b/node_modules/inngest/helpers/strings.js [app-route] (ecmascript)");
/**
 * Creates a {@link ReadableStream} that sends a `value` every `interval`
 * milliseconds as a heartbeat, intended to keep a stream open.
 *
 * Returns the `stream` itself and a `finalize` function that can be used to
 * close the stream and send a final value.
 */ const createStream = (opts)=>{
    var _a, _b;
    /**
     * We need to resolve this promise with both the stream and the `finalize`
     * function, but having them both instantiated synchronously is difficult, as
     * we need access to the stream's internals too.
     *
     * We create this cheeky deferred promise to grab the internal `finalize`
     * value. Be warned that simpler solutions may appear to compile, but fail at
     * runtime due to variables not being assigned; make sure to test your code!
     */ let passFinalize;
    const finalizeP = new Promise((resolve)=>{
        passFinalize = resolve;
    });
    const interval = (_a = opts === null || opts === void 0 ? void 0 : opts.interval) !== null && _a !== void 0 ? _a : 3000;
    const value = (_b = opts === null || opts === void 0 ? void 0 : opts.value) !== null && _b !== void 0 ? _b : " ";
    // eslint-disable-next-line @typescript-eslint/no-misused-promises, no-async-promise-executor
    return new Promise(async (resolve, reject)=>{
        try {
            const stream = new ReadableStream({
                start (controller) {
                    const encoder = new TextEncoder();
                    const heartbeat = setInterval(()=>{
                        controller.enqueue(encoder.encode(value));
                    }, interval);
                    const finalize = (data)=>{
                        clearInterval(heartbeat);
                        // `data` may be a `Promise`. If it is, we need to wait for it to
                        // resolve before sending it. To support this elegantly we'll always
                        // assume it's a promise and handle that case.
                        void Promise.resolve(data).then((resolvedData)=>{
                            controller.enqueue(encoder.encode((0, strings_js_1.stringify)(resolvedData)));
                            controller.close();
                        });
                    };
                    passFinalize(finalize);
                }
            });
            resolve({
                stream,
                finalize: await finalizeP
            });
        } catch (err) {
            reject(err);
        }
    });
};
exports.createStream = createStream; //# sourceMappingURL=stream.js.map
}}),
"[project]/node_modules/.pnpm/inngest@3.32.5_express@4.21.2_next@15.3.4_@opentelemetry+api@1.9.0_react-dom@19.2.0_rea_302ab31fd2a599b814fb517e8771719b/node_modules/inngest/components/InngestCommHandler.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var __classPrivateFieldGet = this && this.__classPrivateFieldGet || function(receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
var _RequestSignature_instances, _RequestSignature_verifySignature;
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.InngestCommHandler = void 0;
const debug_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/.pnpm/debug@4.4.3/node_modules/debug/src/index.js [app-route] (ecmascript)"));
const zod_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/zod@3.22.5/node_modules/zod/lib/index.js [app-route] (ecmascript)");
const ServerTiming_js_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/inngest@3.32.5_express@4.21.2_next@15.3.4_@opentelemetry+api@1.9.0_react-dom@19.2.0_rea_302ab31fd2a599b814fb517e8771719b/node_modules/inngest/helpers/ServerTiming.js [app-route] (ecmascript)");
const consts_js_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/inngest@3.32.5_express@4.21.2_next@15.3.4_@opentelemetry+api@1.9.0_react-dom@19.2.0_rea_302ab31fd2a599b814fb517e8771719b/node_modules/inngest/helpers/consts.js [app-route] (ecmascript)");
const devserver_js_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/inngest@3.32.5_express@4.21.2_next@15.3.4_@opentelemetry+api@1.9.0_react-dom@19.2.0_rea_302ab31fd2a599b814fb517e8771719b/node_modules/inngest/helpers/devserver.js [app-route] (ecmascript)");
const enum_js_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/inngest@3.32.5_express@4.21.2_next@15.3.4_@opentelemetry+api@1.9.0_react-dom@19.2.0_rea_302ab31fd2a599b814fb517e8771719b/node_modules/inngest/helpers/enum.js [app-route] (ecmascript)");
const env_js_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/inngest@3.32.5_express@4.21.2_next@15.3.4_@opentelemetry+api@1.9.0_react-dom@19.2.0_rea_302ab31fd2a599b814fb517e8771719b/node_modules/inngest/helpers/env.js [app-route] (ecmascript)");
const errors_js_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/inngest@3.32.5_express@4.21.2_next@15.3.4_@opentelemetry+api@1.9.0_react-dom@19.2.0_rea_302ab31fd2a599b814fb517e8771719b/node_modules/inngest/helpers/errors.js [app-route] (ecmascript)");
const functions_js_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/inngest@3.32.5_express@4.21.2_next@15.3.4_@opentelemetry+api@1.9.0_react-dom@19.2.0_rea_302ab31fd2a599b814fb517e8771719b/node_modules/inngest/helpers/functions.js [app-route] (ecmascript)");
const net_js_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/inngest@3.32.5_express@4.21.2_next@15.3.4_@opentelemetry+api@1.9.0_react-dom@19.2.0_rea_302ab31fd2a599b814fb517e8771719b/node_modules/inngest/helpers/net.js [app-route] (ecmascript)");
const promises_js_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/inngest@3.32.5_express@4.21.2_next@15.3.4_@opentelemetry+api@1.9.0_react-dom@19.2.0_rea_302ab31fd2a599b814fb517e8771719b/node_modules/inngest/helpers/promises.js [app-route] (ecmascript)");
const stream_js_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/inngest@3.32.5_express@4.21.2_next@15.3.4_@opentelemetry+api@1.9.0_react-dom@19.2.0_rea_302ab31fd2a599b814fb517e8771719b/node_modules/inngest/helpers/stream.js [app-route] (ecmascript)");
const strings_js_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/inngest@3.32.5_express@4.21.2_next@15.3.4_@opentelemetry+api@1.9.0_react-dom@19.2.0_rea_302ab31fd2a599b814fb517e8771719b/node_modules/inngest/helpers/strings.js [app-route] (ecmascript)");
const types_js_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/inngest@3.32.5_express@4.21.2_next@15.3.4_@opentelemetry+api@1.9.0_react-dom@19.2.0_rea_302ab31fd2a599b814fb517e8771719b/node_modules/inngest/types.js [app-route] (ecmascript)");
const version_js_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/inngest@3.32.5_express@4.21.2_next@15.3.4_@opentelemetry+api@1.9.0_react-dom@19.2.0_rea_302ab31fd2a599b814fb517e8771719b/node_modules/inngest/version.js [app-route] (ecmascript)");
const InngestExecution_js_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/inngest@3.32.5_express@4.21.2_next@15.3.4_@opentelemetry+api@1.9.0_react-dom@19.2.0_rea_302ab31fd2a599b814fb517e8771719b/node_modules/inngest/components/execution/InngestExecution.js [app-route] (ecmascript)");
/**
 * A schema for the response from Inngest when registering.
 */ const registerResSchema = zod_1.z.object({
    status: zod_1.z.number().default(200),
    skipped: zod_1.z.boolean().optional().default(false),
    modified: zod_1.z.boolean().optional().default(false),
    error: zod_1.z.string().default("Successfully registered")
});
/**
 * `InngestCommHandler` is a class for handling incoming requests from Inngest (or
 * Inngest's tooling such as the dev server or CLI) and taking appropriate
 * action for any served functions.
 *
 * All handlers (Next.js, RedwoodJS, Remix, Deno Fresh, etc.) are created using
 * this class; the exposed `serve` function will - most commonly - create an
 * instance of `InngestCommHandler` and then return `instance.createHandler()`.
 *
 * See individual parameter details for more information, or see the
 * source code for an existing handler, e.g.
 * {@link https://github.com/inngest/inngest-js/blob/main/src/next.ts}
 *
 * @example
 * ```
 * // my-custom-handler.ts
 * import {
 *   InngestCommHandler,
 *   type ServeHandlerOptions,
 * } from "./components/InngestCommHandler";
 *
 * export const serve = (options: ServeHandlerOptions) => {
 *   const handler = new InngestCommHandler({
 *     frameworkName: "my-custom-handler",
 *     ...options,
 *     handler: (req: Request) => {
 *       return {
 *         body: () => req.json(),
 *         headers: (key) => req.headers.get(key),
 *         method: () => req.method,
 *         url: () => new URL(req.url, `https://${req.headers.get("host") || ""}`),
 *         transformResponse: ({ body, status, headers }) => {
 *           return new Response(body, { status, headers });
 *         },
 *       };
 *     },
 *   });
 *
 *   return handler.createHandler();
 * };
 * ```
 *
 * @public
 */ class InngestCommHandler {
    constructor(options){
        var _a;
        /**
         * A private collection of functions that are being served. This map is used
         * to find and register functions when interacting with Inngest Cloud.
         */ this.fns = {};
        this.env = (0, env_js_1.allProcessEnv)();
        // Set input options directly so we can reference them later
        this._options = options;
        /**
         * v2 -> v3 migration error.
         *
         * If a serve handler is passed a client as the first argument, it'll be
         * spread in to these options. We should be able to detect this by picking
         * up a unique property on the object.
         */ if (Object.prototype.hasOwnProperty.call(options, "eventKey")) {
            throw new Error(`${consts_js_1.logPrefix} You've passed an Inngest client as the first argument to your serve handler. This is no longer supported in v3; please pass the Inngest client as the \`client\` property of an options object instead. See https://www.inngest.com/docs/sdk/migration`);
        }
        this.frameworkName = options.frameworkName;
        this.client = options.client;
        if (options.id) {
            console.warn(`${consts_js_1.logPrefix} The \`id\` serve option is deprecated and will be removed in v4`);
        }
        this.id = options.id || this.client.id;
        this.handler = options.handler;
        /**
         * Provide a hidden option to allow expired signatures to be accepted during
         * testing.
         */ this.allowExpiredSignatures = Boolean(// eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, prefer-rest-params
        (_a = arguments["0"]) === null || _a === void 0 ? void 0 : _a.__testingAllowExpiredSignatures);
        // Ensure we filter any undefined functions in case of missing imports.
        this.rawFns = options.functions.filter(Boolean);
        if (this.rawFns.length !== options.functions.length) {
            // TODO PrettyError
            console.warn(`Some functions passed to serve() are undefined and misconfigured.  Please check your imports.`);
        }
        this.fns = this.rawFns.reduce((acc, fn)=>{
            const configs = fn["getConfig"]({
                baseUrl: new URL("https://example.com"),
                appPrefix: this.id
            });
            const fns = configs.reduce((acc, { id }, index)=>{
                return Object.assign(Object.assign({}, acc), {
                    [id]: {
                        fn,
                        onFailure: Boolean(index)
                    }
                });
            }, {});
            configs.forEach(({ id })=>{
                if (acc[id]) {
                    // TODO PrettyError
                    throw new Error(`Duplicate function ID "${id}"; please change a function's name or provide an explicit ID to avoid conflicts.`);
                }
            });
            return Object.assign(Object.assign({}, acc), fns);
        }, {});
        this.inngestRegisterUrl = new URL("/fn/register", this.apiBaseUrl);
        this.signingKey = options.signingKey;
        this.signingKeyFallback = options.signingKeyFallback;
        this._serveHost = options.serveHost || this.env[consts_js_1.envKeys.InngestServeHost];
        this._servePath = options.servePath || this.env[consts_js_1.envKeys.InngestServePath];
        this.skipSignatureValidation = options.skipSignatureValidation || false;
        const defaultLogLevel = "info";
        this.logLevel = zod_1.z.enum(types_js_1.logLevels).default(defaultLogLevel).catch((ctx)=>{
            this.log("warn", `Unknown log level passed: ${String(ctx.input)}; defaulting to ${defaultLogLevel}`);
            return defaultLogLevel;
        }).parse(options.logLevel || this.env[consts_js_1.envKeys.InngestLogLevel]);
        if (this.logLevel === "debug") {
            /**
             * `debug` is an old library; sometimes its runtime detection doesn't work
             * for newer pairings of framework/runtime.
             *
             * One silly symptom of this is that `Debug()` returns an anonymous
             * function with no extra properties instead of a `Debugger` instance if
             * the wrong code is consumed following a bad detection. This results in
             * the following `.enable()` call failing, so we just try carefully to
             * enable it here.
             */ if (debug_1.default.enable && typeof debug_1.default.enable === "function") {
                debug_1.default.enable(`${consts_js_1.debugPrefix}:*`);
            }
        }
        const defaultStreamingOption = false;
        this.streaming = zod_1.z.union([
            zod_1.z.enum([
                "allow",
                "force"
            ]),
            zod_1.z.literal(false)
        ]).default(defaultStreamingOption).catch((ctx)=>{
            this.log("warn", `Unknown streaming option passed: ${String(ctx.input)}; defaulting to ${String(defaultStreamingOption)}`);
            return defaultStreamingOption;
        }).parse(options.streaming || this.env[consts_js_1.envKeys.InngestStreaming]);
        this.fetch = options.fetch ? (0, env_js_1.getFetch)(options.fetch) : this.client["fetch"];
    }
    /**
     * Get the API base URL for the Inngest API.
     *
     * This is a getter to encourage checking the environment for the API base URL
     * each time it's accessed, as it may change during execution.
     */ get apiBaseUrl() {
        return this._options.baseUrl || this.env[consts_js_1.envKeys.InngestApiBaseUrl] || this.env[consts_js_1.envKeys.InngestBaseUrl] || this.client.apiBaseUrl || consts_js_1.defaultInngestApiBaseUrl;
    }
    /**
     * Get the event API base URL for the Inngest API.
     *
     * This is a getter to encourage checking the environment for the event API
     * base URL each time it's accessed, as it may change during execution.
     */ get eventApiBaseUrl() {
        return this._options.baseUrl || this.env[consts_js_1.envKeys.InngestEventApiBaseUrl] || this.env[consts_js_1.envKeys.InngestBaseUrl] || this.client.eventBaseUrl || consts_js_1.defaultInngestEventBaseUrl;
    }
    /**
     * The host used to access the Inngest serve endpoint, e.g.:
     *
     *     "https://myapp.com"
     *
     * By default, the library will try to infer this using request details such
     * as the "Host" header and request path, but sometimes this isn't possible
     * (e.g. when running in a more controlled environments such as AWS Lambda or
     * when dealing with proxies/redirects).
     *
     * Provide the custom hostname here to ensure that the path is reported
     * correctly when registering functions with Inngest.
     *
     * To also provide a custom path, use `servePath`.
     */ get serveHost() {
        return this._serveHost || this.env[consts_js_1.envKeys.InngestServeHost];
    }
    /**
     * The path to the Inngest serve endpoint. e.g.:
     *
     *     "/some/long/path/to/inngest/endpoint"
     *
     * By default, the library will try to infer this using request details such
     * as the "Host" header and request path, but sometimes this isn't possible
     * (e.g. when running in a more controlled environments such as AWS Lambda or
     * when dealing with proxies/redirects).
     *
     * Provide the custom path (excluding the hostname) here to ensure that the
     * path is reported correctly when registering functions with Inngest.
     *
     * To also provide a custom hostname, use `serveHost`.
     *
     * This is a getter to encourage checking the environment for the serve path
     * each time it's accessed, as it may change during execution.
     */ get servePath() {
        return this._servePath || this.env[consts_js_1.envKeys.InngestServePath];
    }
    get hashedEventKey() {
        if (!this.client["eventKey"] || this.client["eventKey"] === consts_js_1.dummyEventKey) {
            return undefined;
        }
        return (0, strings_js_1.hashEventKey)(this.client["eventKey"]);
    }
    // hashedSigningKey creates a sha256 checksum of the signing key with the
    // same signing key prefix.
    get hashedSigningKey() {
        if (!this.signingKey) {
            return undefined;
        }
        return (0, strings_js_1.hashSigningKey)(this.signingKey);
    }
    get hashedSigningKeyFallback() {
        if (!this.signingKeyFallback) {
            return undefined;
        }
        return (0, strings_js_1.hashSigningKey)(this.signingKeyFallback);
    }
    /**
     * Returns a `boolean` representing whether this handler will stream responses
     * or not. Takes into account the user's preference and the platform's
     * capabilities.
     */ async shouldStream(actions) {
        const rawProbe = await actions.queryStringWithDefaults("testing for probe", consts_js_1.queryKeys.Probe);
        if (rawProbe !== undefined) {
            return false;
        }
        // We must be able to stream responses to continue.
        if (!actions.transformStreamingResponse) {
            return false;
        }
        // If the user has forced streaming, we should always stream.
        if (this.streaming === "force") {
            return true;
        }
        // If the user has allowed streaming, we should stream if the platform
        // supports it.
        return this.streaming === "allow" && (0, env_js_1.platformSupportsStreaming)(this.frameworkName, this.env);
    }
    /**
     * `createHandler` should be used to return a type-equivalent version of the
     * `handler` specified during instantiation.
     *
     * @example
     * ```
     * // my-custom-handler.ts
     * import {
     *   InngestCommHandler,
     *   type ServeHandlerOptions,
     * } from "./components/InngestCommHandler";
     *
     * export const serve = (options: ServeHandlerOptions) => {
     *   const handler = new InngestCommHandler({
     *     frameworkName: "my-custom-handler",
     *     ...options,
     *     handler: (req: Request) => {
     *       return {
     *         body: () => req.json(),
     *         headers: (key) => req.headers.get(key),
     *         method: () => req.method,
     *         url: () => new URL(req.url, `https://${req.headers.get("host") || ""}`),
     *         transformResponse: ({ body, status, headers }) => {
     *           return new Response(body, { status, headers });
     *         },
     *       };
     *     },
     *   });
     *
     *   return handler.createHandler();
     * };
     * ```
     */ createHandler() {
        const handler = async (...args)=>{
            var _a, _b;
            const timer = new ServerTiming_js_1.ServerTiming();
            /**
             * Used for testing, allow setting action overrides externally when
             * calling the handler. Always search the final argument.
             */ const lastArg = args[args.length - 1];
            const actionOverrides = typeof lastArg === "object" && lastArg !== null && "actionOverrides" in lastArg && typeof lastArg["actionOverrides"] === "object" && lastArg["actionOverrides"] !== null ? lastArg["actionOverrides"] : {};
            /**
             * We purposefully `await` the handler, as it could be either sync or
             * async.
             */ const rawActions = Object.assign(Object.assign({}, await timer.wrap("handler", ()=>this.handler(...args)).catch((0, errors_js_1.rethrowError)("Serve handler failed to run"))), actionOverrides);
            /**
             * Map over every `action` in `rawActions` and create a new `actions`
             * object where each function is safely promisified with each access
             * requiring a reason.
             *
             * This helps us provide high quality errors about what's going wrong for
             * each access without having to wrap every access in a try/catch.
             */ const promisifiedActions = Object.entries(rawActions).reduce((acc, [key, value])=>{
                if (typeof value !== "function") {
                    return acc;
                }
                return Object.assign(Object.assign({}, acc), {
                    [key]: (reason, ...args)=>{
                        const errMessage = [
                            `Failed calling \`${key}\` from serve handler`,
                            reason
                        ].filter(Boolean).join(" when ");
                        const fn = ()=>value(...args);
                        return (0, promises_js_1.runAsPromise)(fn).catch((0, errors_js_1.rethrowError)(errMessage)).catch((err)=>{
                            this.log("error", err);
                            throw err;
                        });
                    }
                });
            }, {});
            /**
             * Mapped promisified handlers from userland `serve()` function mixed in
             * with some helpers.
             */ const actions = Object.assign(Object.assign(Object.assign({}, promisifiedActions), {
                queryStringWithDefaults: async (reason, key)=>{
                    var _a;
                    const url = await actions.url(reason);
                    const ret = await ((_a = actions.queryString) === null || _a === void 0 ? void 0 : _a.call(actions, reason, key, url)) || url.searchParams.get(key) || undefined;
                    return ret;
                }
            }), actionOverrides);
            const [env, expectedServerKind] = await Promise.all([
                (_a = actions.env) === null || _a === void 0 ? void 0 : _a.call(actions, "starting to handle request"),
                actions.headers("checking expected server kind", consts_js_1.headerKeys.InngestServerKind)
            ]);
            // Always make sure to merge whatever env we've been given with
            // `process.env`; some platforms may not provide all the necessary
            // environment variables or may use two sources.
            this.env = Object.assign(Object.assign({}, (0, env_js_1.allProcessEnv)()), env);
            const getInngestHeaders = ()=>(0, env_js_1.inngestHeaders)({
                    env: this.env,
                    framework: this.frameworkName,
                    client: this.client,
                    expectedServerKind: expectedServerKind || undefined,
                    extras: {
                        "Server-Timing": timer.getHeader()
                    }
                });
            const assumedMode = (0, env_js_1.getMode)({
                env: this.env,
                client: this.client
            });
            if (assumedMode.isExplicit) {
                this._mode = assumedMode;
            } else {
                const serveIsProd = await ((_b = actions.isProduction) === null || _b === void 0 ? void 0 : _b.call(actions, "starting to handle request"));
                if (typeof serveIsProd === "boolean") {
                    this._mode = new env_js_1.Mode({
                        type: serveIsProd ? "cloud" : "dev",
                        isExplicit: false
                    });
                } else {
                    this._mode = assumedMode;
                }
            }
            this.upsertKeysFromEnv();
            const methodP = actions.method("starting to handle request");
            const headerPromises = [
                consts_js_1.headerKeys.TraceParent,
                consts_js_1.headerKeys.TraceState
            ].map(async (header)=>{
                const value = await actions.headers(`fetching ${header} for forwarding`, header);
                return {
                    header,
                    value
                };
            });
            const contentLength = await actions.headers("checking signature for request", consts_js_1.headerKeys.ContentLength).then((value)=>{
                if (!value) {
                    return undefined;
                }
                return parseInt(value, 10);
            });
            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
            const [signature, method, body] = await Promise.all([
                actions.headers("checking signature for request", consts_js_1.headerKeys.Signature).then((headerSignature)=>{
                    return headerSignature !== null && headerSignature !== void 0 ? headerSignature : undefined;
                }),
                methodP,
                methodP.then((method)=>{
                    if (method === "POST" || method === "PUT") {
                        if (!contentLength) {
                            // Return empty string because req.json() will throw an error.
                            return "";
                        }
                        return actions.body(`checking body for request signing as method is ${method}`);
                    }
                    return "";
                })
            ]);
            const signatureValidation = this.validateSignature(signature, body);
            const headersToForwardP = Promise.all(headerPromises).then((fetchedHeaders)=>{
                return fetchedHeaders.reduce((acc, { header, value })=>{
                    if (value) {
                        acc[header] = value;
                    }
                    return acc;
                }, {});
            });
            const actionRes = timer.wrap("action", ()=>this.handleAction({
                    actions,
                    timer,
                    getInngestHeaders,
                    reqArgs: args,
                    signatureValidation,
                    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
                    body,
                    method,
                    headers: headersToForwardP
                }));
            /**
             * Prepares an action response by merging returned data to provide
             * trailing information such as `Server-Timing` headers.
             *
             * It should always prioritize the headers returned by the action, as they
             * may contain important information such as `Content-Type`.
             */ const prepareActionRes = async (res)=>{
                var _a;
                const headers = Object.assign(Object.assign(Object.assign(Object.assign({}, getInngestHeaders()), await headersToForwardP), res.headers), res.version === null ? {} : {
                    [consts_js_1.headerKeys.RequestVersion]: ((_a = res.version) !== null && _a !== void 0 ? _a : InngestExecution_js_1.PREFERRED_EXECUTION_VERSION).toString()
                });
                let signature;
                try {
                    signature = await signatureValidation.then((result)=>{
                        if (!result.success || !result.keyUsed) {
                            return undefined;
                        }
                        return this.getResponseSignature(result.keyUsed, res.body);
                    });
                } catch (err) {
                    // If we fail to sign, retun a 500 with the error.
                    return Object.assign(Object.assign({}, res), {
                        headers,
                        body: (0, strings_js_1.stringify)((0, errors_js_1.serializeError)(err)),
                        status: 500
                    });
                }
                if (signature) {
                    headers[consts_js_1.headerKeys.Signature] = signature;
                }
                return Object.assign(Object.assign({}, res), {
                    headers
                });
            };
            if (await this.shouldStream(actions)) {
                const method = await actions.method("starting streaming response");
                if (method === "POST") {
                    const { stream, finalize } = await (0, stream_js_1.createStream)();
                    /**
                     * Errors are handled by `handleAction` here to ensure that an
                     * appropriate response is always given.
                     */ void actionRes.then((res)=>{
                        return finalize(prepareActionRes(res));
                    });
                    return timer.wrap("res", ()=>{
                        var _a;
                        return (_a = actions.transformStreamingResponse) === null || _a === void 0 ? void 0 : _a.call(actions, "starting streaming response", {
                            status: 201,
                            headers: getInngestHeaders(),
                            body: stream,
                            version: null
                        });
                    });
                }
            }
            return timer.wrap("res", async ()=>{
                return actionRes.then(prepareActionRes).then((actionRes)=>{
                    // eslint-disable-next-line @typescript-eslint/no-unsafe-return
                    return actions.transformResponse("sending back response", actionRes);
                });
            });
        };
        /**
         * Some platforms check (at runtime) the length of the function being used
         * to handle an endpoint. If this is a variadic function, it will fail that
         * check.
         *
         * Therefore, we expect the arguments accepted to be the same length as the
         * `handler` function passed internally.
         *
         * We also set a name to avoid a common useless name in tracing such as
         * `"anonymous"` or `"bound function"`.
         *
         * https://github.com/getsentry/sentry-javascript/issues/3284
         */ Object.defineProperties(handler, {
            name: {
                value: "InngestHandler"
            },
            length: {
                value: this.handler.length
            }
        });
        return handler;
    }
    get mode() {
        return this._mode;
    }
    set mode(m) {
        this._mode = m;
        if (m) {
            this.client["mode"] = m;
        }
    }
    /**
     * Given a set of functions to check if an action is available from the
     * instance's handler, enact any action that is found.
     *
     * This method can fetch varying payloads of data, but ultimately is the place
     * where _decisions_ are made regarding functionality.
     *
     * For example, if we find that we should be viewing the UI, this function
     * will decide whether the UI should be visible based on the payload it has
     * found (e.g. env vars, options, etc).
     */ async handleAction({ actions, timer, getInngestHeaders, reqArgs, signatureValidation, body, method, headers }) {
        var _a;
        // This is when the request body is completely missing; it does not
        // include an empty body. This commonly happens when the HTTP framework
        // doesn't have body parsing middleware.
        const isMissingBody = body === undefined;
        try {
            let url = await actions.url("starting to handle request");
            if (method === "POST") {
                if (isMissingBody) {
                    this.log("error", "Missing body when executing, possibly due to missing request body middleware");
                    return {
                        status: 500,
                        headers: {
                            "Content-Type": "application/json"
                        },
                        body: (0, strings_js_1.stringify)((0, errors_js_1.serializeError)(new Error("Missing request body when executing, possibly due to missing request body middleware"))),
                        version: undefined
                    };
                }
                const validationResult = await signatureValidation;
                if (!validationResult.success) {
                    return {
                        status: 401,
                        headers: {
                            "Content-Type": "application/json"
                        },
                        body: (0, strings_js_1.stringify)((0, errors_js_1.serializeError)(validationResult.err)),
                        version: undefined
                    };
                }
                const rawProbe = await actions.queryStringWithDefaults("testing for probe", consts_js_1.queryKeys.Probe);
                if (rawProbe) {
                    const probe = (0, enum_js_1.enumFromValue)(consts_js_1.probe, rawProbe);
                    if (!probe) {
                        // If we're here, we've received a probe that we don't recognize.
                        // Fail.
                        return {
                            status: 400,
                            headers: {
                                "Content-Type": "application/json"
                            },
                            body: (0, strings_js_1.stringify)((0, errors_js_1.serializeError)(new Error(`Unknown probe "${rawProbe}"`))),
                            version: undefined
                        };
                    }
                    // Provide actions for every probe available.
                    const probeActions = {
                        [consts_js_1.probe.Trust]: ()=>({
                                status: 200,
                                headers: {
                                    "Content-Type": "application/json"
                                },
                                body: "",
                                version: undefined
                            })
                    };
                    return probeActions[probe]();
                }
                const fnId = await actions.queryStringWithDefaults("processing run request", consts_js_1.queryKeys.FnId);
                if (!fnId) {
                    // TODO PrettyError
                    throw new Error("No function ID found in request");
                }
                const stepId = await actions.queryStringWithDefaults("processing run request", consts_js_1.queryKeys.StepId) || null;
                const { version, result } = this.runStep({
                    functionId: fnId,
                    data: body,
                    stepId,
                    timer,
                    reqArgs,
                    headers: await headers
                });
                const stepOutput = await result;
                /**
                 * Functions can return `undefined`, but we'll always convert this to
                 * `null`, as this is appropriately serializable by JSON.
                 */ const opDataUndefinedToNull = (op)=>{
                    op.data = (0, functions_js_1.undefinedToNull)(op.data);
                    return op;
                };
                const resultHandlers = {
                    "function-rejected": (result)=>{
                        return {
                            status: result.retriable ? 500 : 400,
                            headers: Object.assign({
                                "Content-Type": "application/json",
                                [consts_js_1.headerKeys.NoRetry]: result.retriable ? "false" : "true"
                            }, typeof result.retriable === "string" ? {
                                [consts_js_1.headerKeys.RetryAfter]: result.retriable
                            } : {}),
                            body: (0, strings_js_1.stringify)((0, functions_js_1.undefinedToNull)(result.error)),
                            version
                        };
                    },
                    "function-resolved": (result)=>{
                        return {
                            status: 200,
                            headers: {
                                "Content-Type": "application/json"
                            },
                            body: (0, strings_js_1.stringify)((0, functions_js_1.undefinedToNull)(result.data)),
                            version
                        };
                    },
                    "step-not-found": (result)=>{
                        return {
                            status: 500,
                            headers: {
                                "Content-Type": "application/json",
                                [consts_js_1.headerKeys.NoRetry]: "false"
                            },
                            body: (0, strings_js_1.stringify)({
                                error: `Could not find step "${result.step.displayName || result.step.id}" to run; timed out`
                            }),
                            version
                        };
                    },
                    "step-ran": (result)=>{
                        const step = opDataUndefinedToNull(result.step);
                        return {
                            status: 206,
                            headers: Object.assign({
                                "Content-Type": "application/json"
                            }, typeof result.retriable !== "undefined" ? Object.assign({
                                [consts_js_1.headerKeys.NoRetry]: result.retriable ? "false" : "true"
                            }, typeof result.retriable === "string" ? {
                                [consts_js_1.headerKeys.RetryAfter]: result.retriable
                            } : {}) : {}),
                            body: (0, strings_js_1.stringify)([
                                step
                            ]),
                            version
                        };
                    },
                    "steps-found": (result)=>{
                        const steps = result.steps.map(opDataUndefinedToNull);
                        return {
                            status: 206,
                            headers: {
                                "Content-Type": "application/json"
                            },
                            body: (0, strings_js_1.stringify)(steps),
                            version
                        };
                    }
                };
                const handler = resultHandlers[stepOutput.type];
                try {
                    return await handler(stepOutput);
                } catch (err) {
                    this.log("error", "Error handling execution result", err);
                    throw err;
                }
            }
            // TODO: This feels hacky, so we should probably make it not hacky.
            const env = (_a = getInngestHeaders()[consts_js_1.headerKeys.Environment]) !== null && _a !== void 0 ? _a : null;
            if (method === "GET") {
                return {
                    status: 200,
                    body: (0, strings_js_1.stringify)(await this.introspectionBody({
                        actions,
                        env,
                        signatureValidation,
                        url
                    })),
                    headers: {
                        "Content-Type": "application/json"
                    },
                    version: undefined
                };
            }
            if (method === "PUT") {
                const [deployId, inBandSyncRequested] = await Promise.all([
                    actions.queryStringWithDefaults("processing deployment request", consts_js_1.queryKeys.DeployId).then((deployId)=>{
                        return deployId === "undefined" ? undefined : deployId;
                    }),
                    Promise.resolve((0, env_js_1.parseAsBoolean)(this.env[consts_js_1.envKeys.InngestAllowInBandSync])).then((allowInBandSync)=>{
                        if (allowInBandSync !== undefined && !allowInBandSync) {
                            return consts_js_1.syncKind.OutOfBand;
                        }
                        return actions.headers("processing deployment request", consts_js_1.headerKeys.InngestSyncKind);
                    }).then((kind)=>{
                        return kind === consts_js_1.syncKind.InBand;
                    })
                ]);
                if (inBandSyncRequested) {
                    if (isMissingBody) {
                        this.log("error", "Missing body when syncing, possibly due to missing request body middleware");
                        return {
                            status: 500,
                            headers: {
                                "Content-Type": "application/json"
                            },
                            body: (0, strings_js_1.stringify)((0, errors_js_1.serializeError)(new Error("Missing request body when syncing, possibly due to missing request body middleware"))),
                            version: undefined
                        };
                    }
                    // Validation can be successful if we're in dev mode and did not
                    // actually validate a key. In this case, also check that we did indeed
                    // use a particular key to validate.
                    const sigCheck = await signatureValidation;
                    if (!sigCheck.success) {
                        return {
                            status: 401,
                            body: (0, strings_js_1.stringify)({
                                code: "sig_verification_failed"
                            }),
                            headers: {
                                "Content-Type": "application/json"
                            },
                            version: undefined
                        };
                    }
                    const res = types_js_1.inBandSyncRequestBodySchema.safeParse(body);
                    if (!res.success) {
                        return {
                            status: 400,
                            body: (0, strings_js_1.stringify)({
                                code: "invalid_request",
                                message: res.error.message
                            }),
                            headers: {
                                "Content-Type": "application/json"
                            },
                            version: undefined
                        };
                    }
                    // We can trust the URL here because it's coming from
                    // signature-verified request.
                    url = this.reqUrl(new URL(res.data.url));
                    // This should be an in-band sync
                    const respBody = await this.inBandRegisterBody({
                        actions,
                        deployId,
                        env,
                        signatureValidation,
                        url
                    });
                    return {
                        status: 200,
                        body: (0, strings_js_1.stringify)(respBody),
                        headers: {
                            "Content-Type": "application/json",
                            [consts_js_1.headerKeys.InngestSyncKind]: consts_js_1.syncKind.InBand
                        },
                        version: undefined
                    };
                }
                // If we're here, this is a legacy out-of-band sync
                const { status, message, modified } = await this.register(this.reqUrl(url), deployId, getInngestHeaders);
                return {
                    status,
                    body: (0, strings_js_1.stringify)({
                        message,
                        modified
                    }),
                    headers: {
                        "Content-Type": "application/json",
                        [consts_js_1.headerKeys.InngestSyncKind]: consts_js_1.syncKind.OutOfBand
                    },
                    version: undefined
                };
            }
        } catch (err) {
            return {
                status: 500,
                body: (0, strings_js_1.stringify)(Object.assign({
                    type: "internal"
                }, (0, errors_js_1.serializeError)(err))),
                headers: {
                    "Content-Type": "application/json"
                },
                version: undefined
            };
        }
        return {
            status: 405,
            body: JSON.stringify({
                message: "No action found; request was likely not POST, PUT, or GET",
                mode: this._mode
            }),
            headers: {},
            version: undefined
        };
    }
    runStep({ functionId, stepId, data, timer, reqArgs, headers }) {
        const fn = this.fns[functionId];
        if (!fn) {
            // TODO PrettyError
            throw new Error(`Could not find function with ID "${functionId}"`);
        }
        const immediateFnData = (0, functions_js_1.parseFnData)(data);
        let { version } = immediateFnData;
        // Handle opting in to optimized parallelism in v3.
        if (version === InngestExecution_js_1.ExecutionVersion.V1 && fn.fn["shouldOptimizeParallelism"]()) {
            version = InngestExecution_js_1.ExecutionVersion.V2;
        }
        const result = (0, promises_js_1.runAsPromise)(async ()=>{
            const anyFnData = await (0, functions_js_1.fetchAllFnData)({
                data: immediateFnData,
                api: this.client["inngestApi"],
                version
            });
            if (!anyFnData.ok) {
                throw new Error(anyFnData.error);
            }
            const executionStarters = ((s)=>s)({
                [InngestExecution_js_1.ExecutionVersion.V0]: ({ event, events, steps, ctx, version })=>{
                    var _a, _b, _c;
                    const stepState = Object.entries(steps !== null && steps !== void 0 ? steps : {}).reduce((acc, [id, data])=>{
                        return Object.assign(Object.assign({}, acc), {
                            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
                            [id]: {
                                id,
                                data
                            }
                        });
                    }, {});
                    return {
                        version,
                        partialOptions: {
                            runId: (ctx === null || ctx === void 0 ? void 0 : ctx.run_id) || "",
                            data: {
                                event: event,
                                events: events,
                                runId: (ctx === null || ctx === void 0 ? void 0 : ctx.run_id) || "",
                                attempt: (_a = ctx === null || ctx === void 0 ? void 0 : ctx.attempt) !== null && _a !== void 0 ? _a : 0
                            },
                            stepState,
                            requestedRunStep: stepId === "step" ? undefined : stepId || undefined,
                            timer,
                            isFailureHandler: fn.onFailure,
                            stepCompletionOrder: (_c = (_b = ctx === null || ctx === void 0 ? void 0 : ctx.stack) === null || _b === void 0 ? void 0 : _b.stack) !== null && _c !== void 0 ? _c : [],
                            reqArgs,
                            headers
                        }
                    };
                },
                [InngestExecution_js_1.ExecutionVersion.V1]: ({ event, events, steps, ctx, version })=>{
                    var _a, _b, _c;
                    const stepState = Object.entries(steps !== null && steps !== void 0 ? steps : {}).reduce((acc, [id, result])=>{
                        return Object.assign(Object.assign({}, acc), {
                            [id]: result.type === "data" ? {
                                id,
                                data: result.data
                            } : result.type === "input" ? {
                                id,
                                input: result.input
                            } : {
                                id,
                                error: result.error
                            }
                        });
                    }, {});
                    return {
                        version,
                        partialOptions: {
                            runId: (ctx === null || ctx === void 0 ? void 0 : ctx.run_id) || "",
                            data: {
                                event: event,
                                events: events,
                                runId: (ctx === null || ctx === void 0 ? void 0 : ctx.run_id) || "",
                                attempt: (_a = ctx === null || ctx === void 0 ? void 0 : ctx.attempt) !== null && _a !== void 0 ? _a : 0
                            },
                            stepState,
                            requestedRunStep: stepId === "step" ? undefined : stepId || undefined,
                            timer,
                            isFailureHandler: fn.onFailure,
                            disableImmediateExecution: ctx === null || ctx === void 0 ? void 0 : ctx.disable_immediate_execution,
                            stepCompletionOrder: (_c = (_b = ctx === null || ctx === void 0 ? void 0 : ctx.stack) === null || _b === void 0 ? void 0 : _b.stack) !== null && _c !== void 0 ? _c : [],
                            reqArgs,
                            headers
                        }
                    };
                },
                [InngestExecution_js_1.ExecutionVersion.V2]: ({ event, events, steps, ctx, version })=>{
                    var _a, _b, _c;
                    const stepState = Object.entries(steps !== null && steps !== void 0 ? steps : {}).reduce((acc, [id, result])=>{
                        return Object.assign(Object.assign({}, acc), {
                            [id]: result.type === "data" ? {
                                id,
                                data: result.data
                            } : result.type === "input" ? {
                                id,
                                input: result.input
                            } : {
                                id,
                                error: result.error
                            }
                        });
                    }, {});
                    return {
                        version,
                        partialOptions: {
                            runId: (ctx === null || ctx === void 0 ? void 0 : ctx.run_id) || "",
                            data: {
                                event: event,
                                events: events,
                                runId: (ctx === null || ctx === void 0 ? void 0 : ctx.run_id) || "",
                                attempt: (_a = ctx === null || ctx === void 0 ? void 0 : ctx.attempt) !== null && _a !== void 0 ? _a : 0
                            },
                            stepState,
                            requestedRunStep: stepId === "step" ? undefined : stepId || undefined,
                            timer,
                            isFailureHandler: fn.onFailure,
                            disableImmediateExecution: ctx === null || ctx === void 0 ? void 0 : ctx.disable_immediate_execution,
                            stepCompletionOrder: (_c = (_b = ctx === null || ctx === void 0 ? void 0 : ctx.stack) === null || _b === void 0 ? void 0 : _b.stack) !== null && _c !== void 0 ? _c : [],
                            reqArgs,
                            headers
                        }
                    };
                }
            });
            const executionOptions = await executionStarters[version](anyFnData.value);
            return fn.fn["createExecution"](executionOptions).start();
        });
        return {
            version,
            result
        };
    }
    configs(url) {
        const configs = Object.values(this.rawFns).reduce((acc, fn)=>[
                ...acc,
                ...fn["getConfig"]({
                    baseUrl: url,
                    appPrefix: this.id
                })
            ], []);
        for (const config of configs){
            const check = types_js_1.functionConfigSchema.safeParse(config);
            if (!check.success) {
                const errors = check.error.errors.map((err)=>err.message).join("; ");
                this.log("warn", `Config invalid for function "${config.id}" : ${errors}`);
            }
        }
        return configs;
    }
    /**
     * Return an Inngest serve endpoint URL given a potential `path` and `host`.
     *
     * Will automatically use the `serveHost` and `servePath` if they have been
     * set when registering.
     */ reqUrl(url) {
        let ret = new URL(url);
        const serveHost = this.serveHost || this.env[consts_js_1.envKeys.InngestServeHost];
        const servePath = this.servePath || this.env[consts_js_1.envKeys.InngestServePath];
        if (servePath) {
            ret.pathname = servePath;
        }
        if (serveHost) {
            ret = new URL(ret.pathname + ret.search, serveHost);
        }
        return ret;
    }
    registerBody({ url, deployId }) {
        const body = {
            url: url.href,
            deployType: "ping",
            framework: this.frameworkName,
            appName: this.id,
            functions: this.configs(url),
            sdk: `js:v${version_js_1.version}`,
            v: "0.1",
            deployId: deployId || undefined,
            capabilities: {
                trust_probe: "v1",
                connect: "v1"
            },
            appVersion: this.client.appVersion
        };
        return body;
    }
    async inBandRegisterBody({ actions, deployId, env, signatureValidation, url }) {
        const registerBody = this.registerBody({
            deployId,
            url
        });
        const introspectionBody = await this.introspectionBody({
            actions,
            env,
            signatureValidation,
            url
        });
        const body = {
            app_id: this.id,
            appVersion: this.client.appVersion,
            capabilities: registerBody.capabilities,
            env,
            framework: registerBody.framework,
            functions: registerBody.functions,
            inspection: introspectionBody,
            platform: (0, env_js_1.getPlatformName)(Object.assign(Object.assign({}, (0, env_js_1.allProcessEnv)()), this.env)),
            sdk_author: "inngest",
            sdk_language: "",
            sdk_version: "",
            sdk: registerBody.sdk,
            url: registerBody.url
        };
        if (introspectionBody.authentication_succeeded) {
            body.sdk_language = introspectionBody.sdk_language;
            body.sdk_version = introspectionBody.sdk_version;
        }
        return body;
    }
    async introspectionBody({ actions, env, signatureValidation, url }) {
        var _a, _b, _c, _d, _e;
        const registerBody = this.registerBody({
            url: this.reqUrl(url),
            deployId: null
        });
        if (!this._mode) {
            throw new Error("No mode set; cannot introspect without mode");
        }
        let introspection = {
            authentication_succeeded: null,
            extra: {
                is_mode_explicit: this._mode.isExplicit
            },
            has_event_key: this.client["eventKeySet"](),
            has_signing_key: Boolean(this.signingKey),
            function_count: registerBody.functions.length,
            mode: this._mode.type,
            schema_version: "2024-05-24"
        };
        // Only allow authenticated introspection in Cloud mode, since Dev mode skips
        // signature validation
        if (this._mode.type === "cloud") {
            try {
                const validationResult = await signatureValidation;
                if (!validationResult.success) {
                    throw new Error("Signature validation failed");
                }
                introspection = Object.assign(Object.assign({}, introspection), {
                    authentication_succeeded: true,
                    api_origin: this.apiBaseUrl,
                    app_id: this.id,
                    capabilities: {
                        trust_probe: "v1",
                        connect: "v1"
                    },
                    env,
                    event_api_origin: this.eventApiBaseUrl,
                    event_key_hash: (_a = this.hashedEventKey) !== null && _a !== void 0 ? _a : null,
                    extra: Object.assign(Object.assign({}, introspection.extra), {
                        is_streaming: await this.shouldStream(actions)
                    }),
                    framework: this.frameworkName,
                    sdk_language: "js",
                    sdk_version: version_js_1.version,
                    serve_origin: (_b = this.serveHost) !== null && _b !== void 0 ? _b : null,
                    serve_path: (_c = this.servePath) !== null && _c !== void 0 ? _c : null,
                    signing_key_fallback_hash: (_d = this.hashedSigningKeyFallback) !== null && _d !== void 0 ? _d : null,
                    signing_key_hash: (_e = this.hashedSigningKey) !== null && _e !== void 0 ? _e : null
                });
            } catch (_f) {
                // Swallow signature validation error since we'll just return the
                // unauthenticated introspection
                introspection = Object.assign(Object.assign({}, introspection), {
                    authentication_succeeded: false
                });
            }
        }
        return introspection;
    }
    async register(url, deployId, getHeaders) {
        var _a;
        const body = this.registerBody({
            url,
            deployId
        });
        let res;
        // Whenever we register, we check to see if the dev server is up.  This
        // is a noop and returns false in production. Clone the URL object to avoid
        // mutating the property between requests.
        let registerURL = new URL(this.inngestRegisterUrl.href);
        const inferredDevMode = this._mode && this._mode.isInferred && this._mode.isDev;
        if (inferredDevMode) {
            const host = (0, env_js_1.devServerHost)(this.env);
            const hasDevServer = await (0, devserver_js_1.devServerAvailable)(host, this.fetch);
            if (hasDevServer) {
                registerURL = (0, devserver_js_1.devServerUrl)(host, "/fn/register");
            }
        } else if ((_a = this._mode) === null || _a === void 0 ? void 0 : _a.explicitDevUrl) {
            registerURL = (0, devserver_js_1.devServerUrl)(this._mode.explicitDevUrl.href, "/fn/register");
        }
        if (deployId) {
            registerURL.searchParams.set(consts_js_1.queryKeys.DeployId, deployId);
        }
        try {
            res = await (0, net_js_1.fetchWithAuthFallback)({
                authToken: this.hashedSigningKey,
                authTokenFallback: this.hashedSigningKeyFallback,
                fetch: this.fetch,
                url: registerURL.href,
                options: {
                    method: "POST",
                    body: (0, strings_js_1.stringify)(body),
                    headers: Object.assign(Object.assign({}, getHeaders()), {
                        [consts_js_1.headerKeys.InngestSyncKind]: consts_js_1.syncKind.OutOfBand
                    }),
                    redirect: "follow"
                }
            });
        } catch (err) {
            this.log("error", err);
            return {
                status: 500,
                message: `Failed to register${err instanceof Error ? `; ${err.message}` : ""}`,
                modified: false
            };
        }
        const raw = await res.text();
        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
        let data = {};
        try {
            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
            data = JSON.parse(raw);
        } catch (err) {
            this.log("warn", "Couldn't unpack register response:", err);
            let message = "Failed to register";
            if (err instanceof Error) {
                message += `; ${err.message}`;
            }
            message += `; status code: ${res.status}`;
            return {
                status: 500,
                message,
                modified: false
            };
        }
        let status;
        let error;
        let skipped;
        let modified;
        try {
            ({ status, error, skipped, modified } = registerResSchema.parse(data));
        } catch (err) {
            this.log("warn", "Invalid register response schema:", err);
            let message = "Failed to register";
            if (err instanceof Error) {
                message += `; ${err.message}`;
            }
            message += `; status code: ${res.status}`;
            return {
                status: 500,
                message,
                modified: false
            };
        }
        // The dev server polls this endpoint to register functions every few
        // seconds, but we only want to log that we've registered functions if
        // the function definitions change.  Therefore, we compare the body sent
        // during registration with the body of the current functions and refuse
        // to register if the functions are the same.
        if (!skipped) {
            this.log("debug", "registered inngest functions:", res.status, res.statusText, data);
        }
        return {
            status,
            message: error,
            modified
        };
    }
    /**
     * Given an environment, upsert any missing keys. This is useful in
     * situations where environment variables are passed directly to handlers or
     * are otherwise difficult to access during initialization.
     */ upsertKeysFromEnv() {
        if (this.env[consts_js_1.envKeys.InngestSigningKey]) {
            if (!this.signingKey) {
                this.signingKey = String(this.env[consts_js_1.envKeys.InngestSigningKey]);
            }
            this.client["inngestApi"].setSigningKey(this.signingKey);
        }
        if (this.env[consts_js_1.envKeys.InngestSigningKeyFallback]) {
            if (!this.signingKeyFallback) {
                this.signingKeyFallback = String(this.env[consts_js_1.envKeys.InngestSigningKeyFallback]);
            }
            this.client["inngestApi"].setSigningKeyFallback(this.signingKeyFallback);
        }
        if (!this.client["eventKeySet"]() && this.env[consts_js_1.envKeys.InngestEventKey]) {
            this.client.setEventKey(String(this.env[consts_js_1.envKeys.InngestEventKey]));
        }
        // v2 -> v3 migration warnings
        if (this.env[consts_js_1.envKeys.InngestDevServerUrl]) {
            this.log("warn", `Use of ${consts_js_1.envKeys.InngestDevServerUrl} has been deprecated in v3; please use ${consts_js_1.envKeys.InngestBaseUrl} instead. See https://www.inngest.com/docs/sdk/migration`);
        }
    }
    /**
     * Validate the signature of a request and return the signing key used to
     * validate it.
     */ // eslint-disable-next-line @typescript-eslint/require-await
    async validateSignature(sig, body) {
        try {
            // Skip signature validation if requested (used by connect)
            if (this.skipSignatureValidation) {
                return {
                    success: true,
                    keyUsed: ""
                };
            }
            // Never validate signatures outside of prod. Make sure to check the mode
            // exists here instead of using nullish coalescing to confirm that the check
            // has been completed.
            if (this._mode && !this._mode.isCloud) {
                return {
                    success: true,
                    keyUsed: ""
                };
            }
            // If we're here, we're in production; lack of a signing key is an error.
            if (!this.signingKey) {
                // TODO PrettyError
                throw new Error(`No signing key found in client options or ${consts_js_1.envKeys.InngestSigningKey} env var. Find your keys at https://app.inngest.com/secrets`);
            }
            // If we're here, we're in production; lack of a req signature is an error.
            if (!sig) {
                // TODO PrettyError
                throw new Error(`No ${consts_js_1.headerKeys.Signature} provided`);
            }
            // Validate the signature
            return {
                success: true,
                keyUsed: new RequestSignature(sig).verifySignature({
                    body,
                    allowExpiredSignatures: this.allowExpiredSignatures,
                    signingKey: this.signingKey,
                    signingKeyFallback: this.signingKeyFallback
                })
            };
        } catch (err) {
            return {
                success: false,
                err: err
            };
        }
    }
    getResponseSignature(key, body) {
        const now = Date.now();
        const mac = (0, net_js_1.signDataWithKey)(body, key, now.toString());
        return `t=${now}&s=${mac}`;
    }
    /**
     * Log to stdout/stderr if the log level is set to include the given level.
     * The default log level is `"info"`.
     *
     * This is an abstraction over `console.log` and will try to use the correct
     * method for the given log level.  For example, `log("error", "foo")` will
     * call `console.error("foo")`.
     */ log(level, ...args) {
        const logLevels = [
            "debug",
            "info",
            "warn",
            "error",
            "fatal",
            "silent"
        ];
        const logLevelSetting = logLevels.indexOf(this.logLevel);
        const currentLevel = logLevels.indexOf(level);
        if (currentLevel >= logLevelSetting) {
            let logger = console.log;
            if (Object.prototype.hasOwnProperty.call(console, level)) {
                logger = console[level];
            }
            logger(`${consts_js_1.logPrefix} ${level} -`, ...args);
        }
    }
}
exports.InngestCommHandler = InngestCommHandler;
class RequestSignature {
    constructor(sig){
        _RequestSignature_instances.add(this);
        const params = new URLSearchParams(sig);
        this.timestamp = params.get("t") || "";
        this.signature = params.get("s") || "";
        if (!this.timestamp || !this.signature) {
            // TODO PrettyError
            throw new Error(`Invalid ${consts_js_1.headerKeys.Signature} provided`);
        }
    }
    hasExpired(allowExpiredSignatures) {
        if (allowExpiredSignatures) {
            return false;
        }
        const delta = Date.now() - new Date(parseInt(this.timestamp) * 1000).valueOf();
        return delta > 1000 * 60 * 5;
    }
    verifySignature({ body, signingKey, signingKeyFallback, allowExpiredSignatures }) {
        try {
            __classPrivateFieldGet(this, _RequestSignature_instances, "m", _RequestSignature_verifySignature).call(this, {
                body,
                signingKey,
                allowExpiredSignatures
            });
            return signingKey;
        } catch (err) {
            if (!signingKeyFallback) {
                throw err;
            }
            __classPrivateFieldGet(this, _RequestSignature_instances, "m", _RequestSignature_verifySignature).call(this, {
                body,
                signingKey: signingKeyFallback,
                allowExpiredSignatures
            });
            return signingKeyFallback;
        }
    }
}
_RequestSignature_instances = new WeakSet(), _RequestSignature_verifySignature = function _RequestSignature_verifySignature({ body, signingKey, allowExpiredSignatures }) {
    if (this.hasExpired(allowExpiredSignatures)) {
        // TODO PrettyError
        throw new Error("Signature has expired");
    }
    const mac = (0, net_js_1.signDataWithKey)(body, signingKey, this.timestamp);
    if (mac !== this.signature) {
        // TODO PrettyError
        throw new Error("Invalid signature");
    }
}; //# sourceMappingURL=InngestCommHandler.js.map
}}),
"[project]/node_modules/.pnpm/inngest@3.32.5_express@4.21.2_next@15.3.4_@opentelemetry+api@1.9.0_react-dom@19.2.0_rea_302ab31fd2a599b814fb517e8771719b/node_modules/inngest/index.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/**
 * The primary entrypoint for the Inngest SDK. This provides all the necessary
 * exports to create, run, and trigger Inngest functions.
 *
 * Typical usage involves creating a new Inngest client with `Inngest`, and then
 * using the client to create functions, middleware, and other tools.
 *
 * See {@link https://www.inngest.com/docs} for more information.
 *
 * @example Create an Inngest client
 * ```ts
 * const inngest = new Inngest({
 *   id: "my-app-id",
 * });
 * ```
 *
 * @example Create an Inngest function
 * ```ts
 * const myFn = inngest.createFunction({
 *  id: "my-function",
 * }, {
 *   event: "user/created",
 * }, async ({ event, step }) => {
 *   console.log("User created:", event.data);
 * });
 * ```
 *
 * @example Send an event
 * ```ts
 * await inngest.send({
 *   name: "user/created",
 *   data: {
 *     id: "123",
 *   },
 * });
 * ```
 *
 * @module
 */ var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = this && this.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ProxyLogger = exports.slugify = exports.queryKeys = exports.internalEvents = exports.headerKeys = exports.StepError = exports.RetryAfterError = exports.NonRetriableError = exports.InngestMiddleware = exports.referenceFunction = exports.InngestCommHandler = exports.Inngest = exports.EventSchemas = void 0;
__exportStar(__turbopack_context__.r("[project]/node_modules/.pnpm/@inngest+ai@0.1.2/node_modules/@inngest/ai/dist/index.js [app-route] (ecmascript)"), exports);
var EventSchemas_js_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/inngest@3.32.5_express@4.21.2_next@15.3.4_@opentelemetry+api@1.9.0_react-dom@19.2.0_rea_302ab31fd2a599b814fb517e8771719b/node_modules/inngest/components/EventSchemas.js [app-route] (ecmascript)");
Object.defineProperty(exports, "EventSchemas", {
    enumerable: true,
    get: function() {
        return EventSchemas_js_1.EventSchemas;
    }
});
var Inngest_js_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/inngest@3.32.5_express@4.21.2_next@15.3.4_@opentelemetry+api@1.9.0_react-dom@19.2.0_rea_302ab31fd2a599b814fb517e8771719b/node_modules/inngest/components/Inngest.js [app-route] (ecmascript)");
Object.defineProperty(exports, "Inngest", {
    enumerable: true,
    get: function() {
        return Inngest_js_1.Inngest;
    }
});
var InngestCommHandler_js_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/inngest@3.32.5_express@4.21.2_next@15.3.4_@opentelemetry+api@1.9.0_react-dom@19.2.0_rea_302ab31fd2a599b814fb517e8771719b/node_modules/inngest/components/InngestCommHandler.js [app-route] (ecmascript)");
Object.defineProperty(exports, "InngestCommHandler", {
    enumerable: true,
    get: function() {
        return InngestCommHandler_js_1.InngestCommHandler;
    }
});
var InngestFunctionReference_js_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/inngest@3.32.5_express@4.21.2_next@15.3.4_@opentelemetry+api@1.9.0_react-dom@19.2.0_rea_302ab31fd2a599b814fb517e8771719b/node_modules/inngest/components/InngestFunctionReference.js [app-route] (ecmascript)");
Object.defineProperty(exports, "referenceFunction", {
    enumerable: true,
    get: function() {
        return InngestFunctionReference_js_1.referenceFunction;
    }
});
var InngestMiddleware_js_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/inngest@3.32.5_express@4.21.2_next@15.3.4_@opentelemetry+api@1.9.0_react-dom@19.2.0_rea_302ab31fd2a599b814fb517e8771719b/node_modules/inngest/components/InngestMiddleware.js [app-route] (ecmascript)");
Object.defineProperty(exports, "InngestMiddleware", {
    enumerable: true,
    get: function() {
        return InngestMiddleware_js_1.InngestMiddleware;
    }
});
var NonRetriableError_js_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/inngest@3.32.5_express@4.21.2_next@15.3.4_@opentelemetry+api@1.9.0_react-dom@19.2.0_rea_302ab31fd2a599b814fb517e8771719b/node_modules/inngest/components/NonRetriableError.js [app-route] (ecmascript)");
Object.defineProperty(exports, "NonRetriableError", {
    enumerable: true,
    get: function() {
        return NonRetriableError_js_1.NonRetriableError;
    }
});
var RetryAfterError_js_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/inngest@3.32.5_express@4.21.2_next@15.3.4_@opentelemetry+api@1.9.0_react-dom@19.2.0_rea_302ab31fd2a599b814fb517e8771719b/node_modules/inngest/components/RetryAfterError.js [app-route] (ecmascript)");
Object.defineProperty(exports, "RetryAfterError", {
    enumerable: true,
    get: function() {
        return RetryAfterError_js_1.RetryAfterError;
    }
});
var StepError_js_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/inngest@3.32.5_express@4.21.2_next@15.3.4_@opentelemetry+api@1.9.0_react-dom@19.2.0_rea_302ab31fd2a599b814fb517e8771719b/node_modules/inngest/components/StepError.js [app-route] (ecmascript)");
Object.defineProperty(exports, "StepError", {
    enumerable: true,
    get: function() {
        return StepError_js_1.StepError;
    }
});
var consts_js_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/inngest@3.32.5_express@4.21.2_next@15.3.4_@opentelemetry+api@1.9.0_react-dom@19.2.0_rea_302ab31fd2a599b814fb517e8771719b/node_modules/inngest/helpers/consts.js [app-route] (ecmascript)");
Object.defineProperty(exports, "headerKeys", {
    enumerable: true,
    get: function() {
        return consts_js_1.headerKeys;
    }
});
Object.defineProperty(exports, "internalEvents", {
    enumerable: true,
    get: function() {
        return consts_js_1.internalEvents;
    }
});
Object.defineProperty(exports, "queryKeys", {
    enumerable: true,
    get: function() {
        return consts_js_1.queryKeys;
    }
});
var strings_js_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/inngest@3.32.5_express@4.21.2_next@15.3.4_@opentelemetry+api@1.9.0_react-dom@19.2.0_rea_302ab31fd2a599b814fb517e8771719b/node_modules/inngest/helpers/strings.js [app-route] (ecmascript)");
Object.defineProperty(exports, "slugify", {
    enumerable: true,
    get: function() {
        return strings_js_1.slugify;
    }
});
var logger_js_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/inngest@3.32.5_express@4.21.2_next@15.3.4_@opentelemetry+api@1.9.0_react-dom@19.2.0_rea_302ab31fd2a599b814fb517e8771719b/node_modules/inngest/middleware/logger.js [app-route] (ecmascript)");
Object.defineProperty(exports, "ProxyLogger", {
    enumerable: true,
    get: function() {
        return logger_js_1.ProxyLogger;
    }
}); //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/.pnpm/inngest@3.32.5_express@4.21.2_next@15.3.4_@opentelemetry+api@1.9.0_react-dom@19.2.0_rea_302ab31fd2a599b814fb517e8771719b/node_modules/inngest/experimental.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.getAsyncCtx = void 0;
var als_js_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/inngest@3.32.5_express@4.21.2_next@15.3.4_@opentelemetry+api@1.9.0_react-dom@19.2.0_rea_302ab31fd2a599b814fb517e8771719b/node_modules/inngest/components/execution/als.js [app-route] (ecmascript)");
Object.defineProperty(exports, "getAsyncCtx", {
    enumerable: true,
    get: function() {
        return als_js_1.getAsyncCtx;
    }
}); //# sourceMappingURL=experimental.js.map
}}),

};

//# sourceMappingURL=node_modules__pnpm_688f57cc._.js.map