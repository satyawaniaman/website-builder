{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 7, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 15, "column": 0}, "map": {"version":3,"sources":["file:///Users/amansatyawani/Desktop/website-builder/node_modules/.pnpm/%40dmitryrechkin%2Bjson-schema-to-zod%401.0.1/node_modules/%40dmitryrechkin/json-schema-to-zod/dist/JSONSchemaToZod.js"],"sourcesContent":["import { z, ZodSchema } from 'zod';\nimport {} from './Type.js';\nexport class JSONSchemaToZod {\n    /**\n     * Converts a JSON schema to a Zod schema.\n     *\n     * @param {JSONSchema} schema - The JSON schema.\n     * @returns {ZodSchema} - The Zod schema.\n     */\n    static convert(schema) {\n        return this.parseSchema(schema);\n    }\n    /**\n     * Checks if data matches a condition schema.\n     *\n     * @param {JSONValue} data - The data to check.\n     * @param {JSONSchema} condition - The condition schema.\n     * @returns {boolean} - Whether the data matches the condition.\n     */\n    static matchesCondition(data, condition) {\n        // If no properties to check, condition is met\n        if (!condition.properties) {\n            return true;\n        }\n        // If data is not an object or is null, it can't match a schema with properties\n        if (typeof data !== 'object' || data === null || Array.isArray(data)) {\n            return false;\n        }\n        // Now we know data is a JSONObject\n        const objectData = data;\n        // Check all property conditions\n        for (const [key, propCondition] of Object.entries(condition.properties)) {\n            // If property doesn't exist in data\n            if (!(key in objectData)) {\n                // If there's a const condition and property is missing, it doesn't match\n                if ('const' in propCondition) {\n                    return false;\n                }\n                // For other conditions, skip this property\n                continue;\n            }\n            const value = objectData[key];\n            // Check for const condition\n            if ('const' in propCondition && value !== propCondition['const']) {\n                return false;\n            }\n            // Check for minimum condition\n            if ('minimum' in propCondition && typeof value === 'number' && value < propCondition['minimum']) {\n                return false;\n            }\n            // Check for maximum condition\n            if ('maximum' in propCondition && typeof value === 'number' && value > propCondition['maximum']) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * Validates data against a conditional schema and adds issues to context if validation fails.\n     *\n     * @param {JSONValue} data - The data to validate.\n     * @param {JSONSchema} schema - The conditional schema.\n     * @param {z.RefinementCtx} ctx - The Zod refinement context.\n     */\n    static validateConditionalSchema(data, schema, ctx) {\n        this.validateRequiredProperties(data, schema, ctx);\n        this.validatePropertyPatterns(data, schema, ctx);\n        this.validateNestedConditions(data, schema, ctx);\n    }\n    /**\n     * Validates that all required properties are present in the data.\n     *\n     * @param {JSONValue} data - The data to validate.\n     * @param {JSONSchema} schema - The schema containing required properties.\n     * @param {z.RefinementCtx} ctx - The Zod refinement context.\n     */\n    static validateRequiredProperties(data, schema, ctx) {\n        if (!schema.required) {\n            return;\n        }\n        // If data is not an object or is null, all required properties are missing\n        if (typeof data !== 'object' || data === null) {\n            for (const requiredProp of schema.required) {\n                ctx.addIssue({\n                    code: z.ZodIssueCode.custom,\n                    message: `Required property '${requiredProp}' is missing`,\n                    path: [requiredProp]\n                });\n            }\n            return;\n        }\n        // Now we know data is an object (either a plain object or an array)\n        for (const requiredProp of schema.required) {\n            if (!(requiredProp in data)) {\n                ctx.addIssue({\n                    code: z.ZodIssueCode.custom,\n                    message: `Required property '${requiredProp}' is missing`,\n                    path: [requiredProp]\n                });\n            }\n        }\n    }\n    /**\n     * Validates property patterns for string properties.\n     *\n     * @param {JSONValue} data - The data to validate.\n     * @param {JSONSchema} schema - The schema containing property patterns.\n     * @param {z.RefinementCtx} ctx - The Zod refinement context.\n     */\n    static validatePropertyPatterns(data, schema, ctx) {\n        if (!schema.properties) {\n            return;\n        }\n        // If data is not an object or is null, we can't validate property patterns\n        if (typeof data !== 'object' || data === null) {\n            return;\n        }\n        // If data is an array, we can't validate property patterns\n        if (Array.isArray(data)) {\n            return;\n        }\n        // Now we know data is a JSONObject\n        const objectData = data;\n        // Process each property in the schema\n        for (const [key, propSchema] of Object.entries(schema.properties)) {\n            // Skip if property doesn't exist in data\n            if (!(key in objectData)) {\n                continue;\n            }\n            const value = objectData[key];\n            // Check pattern validation for strings\n            if (propSchema['pattern'] && typeof value === 'string') {\n                const regex = new RegExp(propSchema['pattern']);\n                if (!regex.test(value)) {\n                    ctx.addIssue({\n                        code: z.ZodIssueCode.custom,\n                        message: `String '${value}' does not match pattern '${propSchema['pattern']}'`,\n                        path: [key]\n                    });\n                }\n            }\n        }\n    }\n    /**\n     * Validates nested if-then-else conditions.\n     *\n     * @param {JSONValue} data - The data to validate.\n     * @param {JSONSchema} schema - The schema containing if-then-else conditions.\n     * @param {z.RefinementCtx} ctx - The Zod refinement context.\n     */\n    static validateNestedConditions(data, schema, ctx) {\n        if (!schema['if'] || !schema['then']) {\n            return;\n        }\n        const matchesIf = this.matchesCondition(data, schema['if']);\n        if (matchesIf) {\n            this.validateConditionalSchema(data, schema['then'], ctx);\n        }\n        else if (schema['else']) {\n            this.validateConditionalSchema(data, schema['else'], ctx);\n        }\n    }\n    /**\n     * Parses a JSON schema and returns the corresponding Zod schema.\n     * This is the main entry point for schema conversion.\n     *\n     * @param {JSONSchema} schema - The JSON schema.\n     * @returns {ZodTypeAny} - The ZodTypeAny schema.\n     */\n    static parseSchema(schema) {\n        // Handle array of types (e.g., ['string', 'null'] for nullable types)\n        if (Array.isArray(schema.type)) {\n            return this.handleTypeArray(schema);\n        }\n        // Handle combinators (oneOf, anyOf, allOf)\n        if (schema.oneOf || schema.anyOf || schema.allOf) {\n            return this.parseCombinator(schema);\n        }\n        // Handle if-then-else conditional validation\n        if (schema['if'] && schema['then']) {\n            return this.parseObject(schema);\n        }\n        // Handle object schema without explicit type but with properties\n        if (schema.properties && (!schema.type || schema.type === 'object')) {\n            return this.parseObject(schema);\n        }\n        // Handle all other types\n        return this.handleSingleType(schema);\n    }\n    /**\n     * Handles schemas with an array of types.\n     *\n     * @param {JSONSchema} schema - The JSON schema with type array.\n     * @returns {ZodTypeAny} - The ZodTypeAny schema.\n     */\n    static handleTypeArray(schema) {\n        if (!Array.isArray(schema.type)) {\n            throw new Error('Expected schema.type to be an array');\n        }\n        // Check if the type array includes 'null' to create a nullable type\n        if (schema.type.includes('null')) {\n            return this.handleNullableType(schema);\n        }\n        // If no 'null' in the type array, handle as a union of types\n        return this.createUnionFromTypes(schema.type, schema);\n    }\n    /**\n     * Handles nullable types by creating a nullable schema.\n     *\n     * @param {JSONSchema} schema - The JSON schema with nullable type.\n     * @returns {ZodTypeAny} - The nullable Zod schema.\n     */\n    static handleNullableType(schema) {\n        if (!Array.isArray(schema.type)) {\n            throw new Error('Expected schema.type to be an array');\n        }\n        // Create a copy of the schema without the 'null' type\n        const nonNullSchema = { ...schema };\n        nonNullSchema.type = schema.type.filter(t => t !== 'null');\n        // If there's only one type left, handle it as a single type and make it nullable\n        if (nonNullSchema.type.length === 1) {\n            const singleTypeSchema = this.handleSingleType({ ...schema, type: nonNullSchema.type[0] });\n            return singleTypeSchema.nullable();\n        }\n        // If multiple non-null types, create a union and make it nullable\n        const unionSchema = this.parseSchema(nonNullSchema);\n        return unionSchema.nullable();\n    }\n    /**\n     * Creates a union type from an array of types.\n     *\n     * @param {string[]} types - Array of type strings.\n     * @param {JSONSchema} baseSchema - The base schema to apply to each type.\n     * @returns {ZodTypeAny} - The union Zod schema.\n     */\n    static createUnionFromTypes(types, baseSchema) {\n        const schemas = types.map(type => {\n            const singleTypeSchema = { ...baseSchema, type };\n            return this.parseSchema(singleTypeSchema);\n        });\n        return z.union(schemas);\n    }\n    /**\n     * Handles schemas with a single type.\n     *\n     * @param {JSONSchema} schema - The JSON schema with single type.\n     * @returns {ZodTypeAny} - The ZodTypeAny schema.\n     */\n    static handleSingleType(schema) {\n        // Handle schemas without a type property\n        if (schema.type === undefined) {\n            // Check for combinators first\n            if (schema.oneOf || schema.anyOf || schema.allOf) {\n                return this.parseCombinator(schema);\n            }\n            // Check for object properties\n            if (schema.properties) {\n                return this.parseObject(schema);\n            }\n            // Default to any() for schemas with no type and no other indicators\n            return z.any();\n        }\n        // Handle specific types\n        switch (schema.type) {\n            case 'string': return this.parseString(schema);\n            case 'number':\n            case 'integer': return this.parseNumberSchema(schema);\n            case 'boolean': return z.boolean();\n            case 'array': return this.parseArray(schema);\n            case 'object': return this.parseObject(schema);\n            default: throw new Error('Unsupported schema type');\n        }\n    }\n    /**\n     * Parses a number schema.\n     *\n     * @param {JSONSchema} schema - The JSON schema for a number.\n     * @returns {ZodTypeAny} - The ZodTypeAny schema.\n     */\n    static parseNumberSchema(schema) {\n        let numberSchema = z.number();\n        // Apply all number validations\n        let result = numberSchema;\n        result = this.applyNumberBounds(numberSchema, schema);\n        result = this.applyNumberMultipleOf(numberSchema, schema);\n        result = this.applyNumberEnum(numberSchema, schema);\n        result = this.applyIntegerConstraint(numberSchema, schema);\n        return result;\n    }\n    /**\n     * Applies bounds validation to a number schema.\n     *\n     * @param {z.ZodNumber} numberSchema - The base number schema.\n     * @param {JSONSchema} schema - The JSON schema with bounds.\n     * @returns {z.ZodNumber} - The updated schema with bounds validation.\n     */\n    static applyNumberBounds(numberSchema, schema) {\n        let result = numberSchema;\n        if (schema['minimum'] !== undefined) {\n            result = schema['exclusiveMinimum'] ?\n                result.gt(schema['minimum']) :\n                result.gte(schema['minimum']);\n        }\n        if (schema['maximum'] !== undefined) {\n            result = schema['exclusiveMaximum'] ?\n                result.lt(schema['maximum']) :\n                result.lte(schema['maximum']);\n        }\n        return result;\n    }\n    /**\n     * Applies multipleOf validation to a number schema.\n     *\n     * @param {z.ZodNumber} numberSchema - The base number schema.\n     * @param {JSONSchema} schema - The JSON schema with multipleOf.\n     * @returns {z.ZodNumber} - The updated schema with multipleOf validation.\n     */\n    static applyNumberMultipleOf(numberSchema, schema) {\n        if (schema['multipleOf'] === undefined) {\n            return numberSchema;\n        }\n        return numberSchema.refine(val => val % schema['multipleOf'] === 0, { message: `Number must be a multiple of ${schema['multipleOf']}` });\n    }\n    /**\n     * Applies enum validation to a number schema.\n     *\n     * @param {z.ZodNumber} numberSchema - The base number schema.\n     * @param {JSONSchema} schema - The JSON schema with enum.\n     * @returns {z.ZodNumber} - The updated schema with enum validation.\n     */\n    static applyNumberEnum(numberSchema, schema) {\n        if (!schema.enum) {\n            return numberSchema;\n        }\n        // Filter out non-number values from enum\n        const numberEnums = schema.enum.filter(val => typeof val === 'number');\n        if (numberEnums.length === 0) {\n            return numberSchema;\n        }\n        // Use refinement to validate against enum values\n        return numberSchema.refine(val => numberEnums.includes(val), { message: `Number must be one of: ${numberEnums.join(', ')}` });\n    }\n    /**\n     * Applies integer constraint to a number schema if needed.\n     *\n     * @param {z.ZodNumber} numberSchema - The base number schema.\n     * @param {JSONSchema} schema - The JSON schema.\n     * @returns {z.ZodNumber} - The updated schema with integer validation if needed.\n     */\n    static applyIntegerConstraint(numberSchema, schema) {\n        if (schema.type !== 'integer') {\n            return numberSchema;\n        }\n        return numberSchema.refine(val => Number.isInteger(val), { message: 'Number must be an integer' });\n    }\n    /**\n     * Parses a string schema.\n     *\n     * @param {JSONSchema} schema - The JSON schema for a string.\n     * @returns {ZodTypeAny} - The ZodTypeAny schema.\n     */\n    static parseString(schema) {\n        let stringSchema = z.string();\n        let result = stringSchema;\n        // Apply all string validations\n        if (schema.format) {\n            // Handle format-specific string validation\n            return this.applyStringFormat(stringSchema, schema);\n        }\n        else {\n            // Only apply other validations if format is not specified\n            // or apply them to the formatted string\n            result = this.applyStringPattern(stringSchema, schema);\n            result = this.applyStringLength(stringSchema, schema);\n            result = this.applyStringEnum(stringSchema, schema);\n        }\n        return result;\n    }\n    /**\n     * Applies format validation to a string schema.\n     *\n     * @param {z.ZodString} stringSchema - The base string schema.\n     * @param {JSONSchema} schema - The JSON schema with format.\n     * @returns {ZodTypeAny} - The updated schema with format validation.\n     */\n    static applyStringFormat(stringSchema, schema) {\n        if (!schema.format) {\n            return stringSchema;\n        }\n        switch (schema.format) {\n            case 'email':\n                return stringSchema.email();\n            case 'date-time':\n                return stringSchema.datetime();\n            case 'uri':\n                return stringSchema.url();\n            case 'uuid':\n                return stringSchema.uuid();\n            case 'date':\n                return stringSchema.date();\n            default:\n                return stringSchema;\n        }\n    }\n    /**\n     * Applies pattern validation to a string schema.\n     *\n     * @param {z.ZodString} stringSchema - The base string schema.\n     * @param {JSONSchema} schema - The JSON schema with pattern.\n     * @returns {z.ZodString} - The updated schema with pattern validation.\n     */\n    static applyStringPattern(stringSchema, schema) {\n        if (!schema['pattern']) {\n            return stringSchema;\n        }\n        const regex = new RegExp(schema['pattern']);\n        return stringSchema.regex(regex, { message: `String must match pattern: ${schema['pattern']}` });\n    }\n    /**\n     * Applies length constraints to a string schema.\n     *\n     * @param {z.ZodString} stringSchema - The base string schema.\n     * @param {JSONSchema} schema - The JSON schema with length constraints.\n     * @returns {z.ZodString} - The updated schema with length validation.\n     */\n    static applyStringLength(stringSchema, schema) {\n        let result = stringSchema;\n        if (schema['minLength'] !== undefined) {\n            stringSchema = stringSchema.min(schema['minLength']);\n        }\n        if (schema['maxLength'] !== undefined) {\n            stringSchema = stringSchema.max(schema['maxLength']);\n        }\n        return result;\n    }\n    /**\n     * Applies enum validation to a string schema.\n     *\n     * @param {z.ZodString} stringSchema - The base string schema.\n     * @param {JSONSchema} schema - The JSON schema with enum.\n     * @returns {ZodTypeAny} - The updated schema with enum validation.\n     */\n    static applyStringEnum(stringSchema, schema) {\n        if (!schema.enum) {\n            return stringSchema;\n        }\n        // Use refinement to validate against enum values\n        return stringSchema.refine((val) => schema.enum?.includes(val), {\n            message: `Value must be one of: ${schema.enum?.join(', ')}`\n        });\n    }\n    /**\n     * Parses a JSON schema of type array and returns the corresponding Zod schema.\n     *\n     * @param {JSONSchema} schema - The JSON schema.\n     * @returns {ZodTypeAny} - The ZodTypeAny schema.\n     */\n    static parseArray(schema) {\n        // Handle tuple validation (items is an array)\n        if (Array.isArray(schema.items)) {\n            const tupleSchemas = schema.items.map(item => this.parseSchema(item));\n            return z.union(tupleSchemas);\n        }\n        // Create regular array schema\n        const itemSchema = schema.items ? this.parseSchema(schema.items) : z.any();\n        let arraySchema = z.array(itemSchema);\n        // Apply array constraints\n        let result = arraySchema;\n        result = this.applyArrayConstraints(arraySchema, schema);\n        return result;\n    }\n    /**\n     * Applies constraints to an array schema.\n     *\n     * @param {z.ZodArray<any>} arraySchema - The base array schema.\n     * @param {JSONSchema} schema - The JSON schema with array constraints.\n     * @returns {z.ZodTypeAny} - The updated array schema with constraints.\n     */\n    static applyArrayConstraints(arraySchema, schema) {\n        // Handle minItems\n        if (schema['minItems'] !== undefined) {\n            arraySchema = arraySchema.min(schema['minItems']);\n        }\n        // Handle maxItems\n        if (schema['maxItems'] !== undefined) {\n            arraySchema = arraySchema.max(schema['maxItems']);\n        }\n        // Handle uniqueItems\n        if (schema['uniqueItems']) {\n            return arraySchema.refine((items) => new Set(items).size === items.length, { message: 'Array items must be unique' });\n        }\n        return arraySchema;\n    }\n    /**\n     * Parses an object schema.\n     *\n     * @param {JSONSchema} schema - The JSON schema for an object.\n     * @returns {ZodTypeAny} - The ZodTypeAny schema.\n     */\n    static parseObject(schema) {\n        // Handle conditional validation (if-then-else) first\n        if (schema['if'] && schema['then']) {\n            return this.parseConditional(schema);\n        }\n        // Create shape object for Zod\n        const shape = {};\n        // Process properties\n        this.processObjectProperties(schema, shape);\n        // Create the object schema and handle additionalProperties\n        return this.processAdditionalProperties(schema, z.object(shape));\n    }\n    /**\n     * Processes object properties and builds the shape object.\n     *\n     * @param {JSONSchema} schema - The JSON schema for an object.\n     * @param {Record<string, ZodTypeAny>} shape - The shape object to populate.\n     */\n    static processObjectProperties(schema, shape) {\n        const required = new Set(schema.required || []);\n        if (!schema.properties) {\n            return;\n        }\n        for (const [key, propSchema] of Object.entries(schema.properties)) {\n            const zodSchema = this.parseSchema(propSchema);\n            shape[key] = required.has(key) ? zodSchema : zodSchema.optional();\n        }\n    }\n    /**\n     * Processes additionalProperties configuration.\n     *\n     * @param {JSONSchema} schema - The JSON schema for an object.\n     * @param {z.ZodObject<any, any>} objectSchema - The Zod object schema.\n     * @returns {z.ZodObject<any, any>} - The updated Zod object schema.\n     */\n    static processAdditionalProperties(schema, objectSchema) {\n        if (schema.additionalProperties === true) {\n            return objectSchema.passthrough();\n        }\n        else if (schema.additionalProperties && typeof schema.additionalProperties === 'object') {\n            // Handle schema for additional properties\n            const additionalPropSchema = this.parseSchema(schema.additionalProperties);\n            return objectSchema.catchall(additionalPropSchema);\n        }\n        else {\n            return objectSchema.strict();\n        }\n    }\n    /**\n     * Parses a conditional schema with if-then-else.\n     *\n     * @param {JSONSchema} schema - The JSON schema with conditional validation.\n     * @returns {ZodTypeAny} - The conditional Zod schema.\n     */\n    static parseConditional(schema) {\n        // Create base object schema\n        const zodObject = this.createBaseObjectSchema(schema);\n        // Extract conditional parts\n        const ifCondition = schema['if'];\n        const thenSchema = schema['then'];\n        const elseSchema = schema['else'];\n        // Apply conditional validation using superRefine\n        return zodObject.superRefine((data, ctx) => {\n            // Apply default values to data for condition checking\n            const dataWithDefaults = this.applyDefaultValues(data, schema);\n            // Apply appropriate validation based on condition\n            if (this.matchesCondition(dataWithDefaults, ifCondition)) {\n                this.validateConditionalSchema(dataWithDefaults, thenSchema, ctx);\n            }\n            else if (elseSchema) {\n                this.validateConditionalSchema(dataWithDefaults, elseSchema, ctx);\n            }\n        });\n    }\n    /**\n     * Creates a base object schema from the given JSON schema.\n     *\n     * @param {JSONSchema} schema - The JSON schema.\n     * @returns {z.ZodObject<any, any>} - The base Zod object schema.\n     */\n    static createBaseObjectSchema(schema) {\n        const shape = {};\n        const required = new Set(schema.required || []);\n        for (const [key, value] of Object.entries(schema.properties || {})) {\n            const zodSchema = this.parseSchema(value);\n            shape[key] = required.has(key) ? zodSchema : zodSchema.optional();\n        }\n        const zodObject = z.object(shape);\n        return this.processAdditionalProperties(schema, zodObject);\n    }\n    /**\n     * Applies default values from schema properties to data object.\n     *\n     * @param {JSONValue} data - The original data object.\n     * @param {JSONSchema} schema - The schema with default values.\n     * @returns {JSONValue} - The data object with defaults applied.\n     */\n    static applyDefaultValues(data, schema) {\n        // If data is not an object or is null, we can't apply defaults\n        if (typeof data !== 'object' || data === null) {\n            return data;\n        }\n        // If data is an array, we can't apply defaults from schema properties\n        if (Array.isArray(data)) {\n            return data;\n        }\n        // Now we know data is a JSONObject\n        const objectData = data;\n        const dataWithDefaults = { ...objectData };\n        if (!schema.properties) {\n            return dataWithDefaults;\n        }\n        for (const [key, propSchema] of Object.entries(schema.properties)) {\n            if (!(key in dataWithDefaults) && 'default' in propSchema) {\n                dataWithDefaults[key] = propSchema['default'];\n            }\n        }\n        return dataWithDefaults;\n    }\n    /**\n     * Parses a schema with combinators (oneOf, anyOf, allOf).\n     * Delegates to the appropriate combinator parser based on which combinator is present.\n     *\n     * @param {JSONSchema} schema - The JSON schema with combinators.\n     * @returns {ZodTypeAny} - The ZodTypeAny schema.\n     */\n    static parseCombinator(schema) {\n        if (schema.oneOf) {\n            return this.parseOneOf(schema.oneOf);\n        }\n        if (schema.anyOf) {\n            return this.parseAnyOf(schema.anyOf);\n        }\n        if (schema.allOf) {\n            return this.parseAllOf(schema.allOf);\n        }\n        // Should not reach here if schema has combinators\n        throw new Error('Unsupported schema type');\n    }\n    /**\n     * Parses a oneOf combinator schema.\n     *\n     * @param {JSONSchema[]} schemas - Array of JSON schemas in the oneOf.\n     * @returns {ZodTypeAny} - The ZodTypeAny schema.\n     */\n    static parseOneOf(schemas) {\n        return this.createUnionFromSchemas(schemas);\n    }\n    /**\n     * Parses an anyOf combinator schema.\n     *\n     * @param {JSONSchema[]} schemas - Array of JSON schemas in the anyOf.\n     * @returns {ZodTypeAny} - The ZodTypeAny schema.\n     */\n    static parseAnyOf(schemas) {\n        return this.createUnionFromSchemas(schemas);\n    }\n    /**\n     * Creates a union from an array of schemas, handling special cases.\n     *\n     * @param {JSONSchema[]} schemas - Array of JSON schemas to create a union from.\n     * @returns {ZodTypeAny} - The union Zod schema.\n     */\n    static createUnionFromSchemas(schemas) {\n        // Handle empty array case\n        if (schemas.length === 0) {\n            return z.any();\n        }\n        // Handle single schema case\n        if (schemas.length === 1) {\n            return this.parseSchema(schemas[0]);\n        }\n        // Process each subschema individually\n        const zodSchemas = [];\n        for (const subSchema of schemas) {\n            // Handle null type specially\n            if (subSchema.type === 'null') {\n                zodSchemas.push(z.null());\n            }\n            else {\n                zodSchemas.push(this.parseSchema(subSchema));\n            }\n        }\n        // Return appropriate schema based on number of valid schemas\n        if (zodSchemas.length >= 2) {\n            return z.union(zodSchemas);\n        }\n        else if (zodSchemas.length === 1) {\n            return zodSchemas[0];\n        }\n        // Fallback if no valid schemas were created\n        return z.any();\n    }\n    /**\n     * Parses an allOf combinator schema by merging all schemas.\n     *\n     * @param {JSONSchema[]} schemas - Array of JSON schemas in the allOf.\n     * @returns {ZodTypeAny} - The ZodTypeAny schema.\n     */\n    static parseAllOf(schemas) {\n        // Handle empty array case\n        if (schemas.length === 0) {\n            return z.any();\n        }\n        // Handle single schema case\n        if (schemas.length === 1) {\n            return this.parseSchema(schemas[0]);\n        }\n        // Merge all schemas together\n        const mergedSchema = schemas.reduce((acc, currentSchema) => this.mergeSchemas(acc, currentSchema));\n        return this.parseSchema(mergedSchema);\n    }\n    /**\n     * Merges two JSON schemas together.\n     *\n     * @param {JSONSchema} baseSchema - The base JSON schema.\n     * @param {JSONSchema} addSchema - The JSON schema to add.\n     * @returns {JSONSchema} - The merged JSON schema\n     */\n    static mergeSchemas(baseSchema, addSchema) {\n        const merged = { ...baseSchema, ...addSchema };\n        if (baseSchema.properties && addSchema.properties) {\n            const mergedProperties = { ...baseSchema.properties, ...addSchema.properties };\n            merged.properties = mergedProperties;\n        }\n        if (baseSchema.required && addSchema.required) {\n            const mergedRequired = [...new Set([...baseSchema.required, ...addSchema.required])];\n            merged.required = mergedRequired;\n        }\n        return merged;\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 753, "column": 0}, "map": {"version":3,"sources":["file:///Users/amansatyawani/Desktop/website-builder/node_modules/.pnpm/%40dmitryrechkin%2Bjson-schema-to-zod%401.0.1/node_modules/%40dmitryrechkin/json-schema-to-zod/dist/index.js"],"sourcesContent":["export * from './JSONSchemaToZod.js';\nexport * from './Type.js';\n"],"names":[],"mappings":";AAAA;AACA","ignoreList":[0],"debugId":null}}]
}